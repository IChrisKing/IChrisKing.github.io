<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>IChrisKing</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="IChrisKing">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="IChrisKing">
<meta property="og:locale" content="zh-Hant-TW">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="IChrisKing">
  
    <link rel="alternate" href="/atom.xml" title="IChrisKing" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">IChrisKing</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">#IMNOTCHRISLEE</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Sort" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/02/Sort/" class="article-date">
  <time datetime="2016-11-02T10:42:33.000Z" itemprop="datePublished">2016-11-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/算法/">算法</a>►<a class="article-category-link" href="/categories/算法/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/02/Sort/">各种排序算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h2><p><a href="https://github.com/IChrisKing/SortAndFind" target="_blank" rel="external">SortAndFind</a><br><code>git@github.com:IChrisKing/SortAndFind.git</code></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所需辅助空间最多：归并排序 </p>
<p>所需辅助空间最少：堆排序 </p>
<p>平均速度最快：快速排序 </p>
<p>不稳定：快速排序，希尔排序，堆排序。 </p>
<h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><p>在要排序的一组数中，假设前面(n-1)[n&gt;=2] 个数已经是排好顺序的，现在要把第n 个数插到前面的有序数中，使得这n个数也是排好顺序的。如此反复循环，直到全部排好顺序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> public static void insertSort(int[] arr)&#123;    </div><div class="line">	array = arr;</div><div class="line">     int temp=0;   </div><div class="line">     for(int i=1;i&lt;array.length;i++)&#123;   </div><div class="line">        int j=i-1;   </div><div class="line">       temp=array[i];   </div><div class="line">       for(;j&gt;=0&amp;&amp;temp&lt;array[j];j--)&#123;   </div><div class="line">           array[j+1]=array[j];  //将大于temp 的值整体后移一个单位   </div><div class="line">       &#125;   </div><div class="line">       array[j+1]=temp;   </div><div class="line">    &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>算法先将要排序的一组数按某个增量 d（n/2,n为要排序数的个数）分成若干组，每组中记录的下标相差 d.对每组中全部元素进行直接插入排序，然后再用一个较小的增量（d/2）对它进行分组，在每组中再进行直接插入排序。当增量减到 1 时，进行直接插入排序后，排序完成。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public static void shellSort(int[] arr)&#123;</div><div class="line">	array = arr;</div><div class="line">	d=arr.length/2;</div><div class="line"></div><div class="line">	while(d&gt;1)&#123;</div><div class="line">		begin = 0;</div><div class="line">		while(begin&lt;d)&#123;</div><div class="line">			insertSortForShell(begin,d);</div><div class="line">			begin++;</div><div class="line">		&#125;</div><div class="line">		d=d/2;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	insertSortForShell(0,1);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">  public static void insertSortForShell(int begin, int d)&#123;    </div><div class="line">      int temp;   </div><div class="line">      for(int i=begin+d;i&lt;array.length;i+=d)&#123;   </div><div class="line">         int j=i-d;   </div><div class="line">        temp=array[i];   </div><div class="line">        for(;j&gt;=0&amp;&amp;temp&lt;array[j];j-=d)&#123;   </div><div class="line">            array[j+d]=array[j];  </div><div class="line">        &#125;   </div><div class="line">        array[j+d]=temp;   </div><div class="line">     &#125;   </div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><p>在要排序的一组数中，选出最小的一个数与第一个位置的数交换；然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public static void selectSort(int[] arr)&#123;</div><div class="line">		array = arr;</div><div class="line">		for(int i=0;i&lt;array.length;i++)&#123;</div><div class="line">			pos = findMinPos(i);</div><div class="line">			int temp = array[i];</div><div class="line">			array[i]=array[pos];</div><div class="line">			array[pos]=temp;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private static int findMinPos(int i) &#123;</div><div class="line">		int min = array[i];</div><div class="line">		int minPos = i;</div><div class="line">		for(int j=i+1;j&lt;array.length;j++)&#123;</div><div class="line">			if(array[j]&lt;min)&#123;</div><div class="line">				min = array[j];</div><div class="line">				minPos = j;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return minPos;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序是一种树形选择排序，是对直接选择排序的有效改进。</p>
<p>堆的定义如下：具有n个元素的序列（h1,h2,…,hn),当且仅当满足（hi&gt;=h2i,hi&gt;=2i+1）或（hi&lt;=h2i,hi&lt;=2i+1） (i=1,2,…,n/2)时称之为堆。在这里只讨论满足前者条件的堆。由堆的定义可以看出，堆顶元素（即第一个元素）必为最大项（大顶堆）。完全二叉树可以很直观地表示堆的结构。堆顶为根，其它为左子树、右子树。初始时把要排序的数的序列看作是一棵顺序存储的二叉树，调整它们的存储序，使之成为一个堆，这时堆的根节点的数最大。然后将根节点与堆的最后一个节点交换。然后对前面(n-1)个数重新调整使之成为堆。依此类推，直到只有两个节点的堆，并对它们作交换，最后得到有n个节点的有序序列。从算法描述来看，堆排序需要两个过程，一是建立堆，二是堆顶与堆的最后一个元素交换位置。所以堆排序有两个函数组成。一是建堆的渗透函数，二是反复调用渗透函数实现排序的函数。</p>
<p>堆排序是不稳定的排序方法，辅助空间为O(1)， 最坏时间复杂度为O(nlog2n) ，堆排序的堆序的平均性能较接近于最坏性能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">public static int[] array;</div><div class="line">static int end;</div><div class="line"></div><div class="line">public static void sortArray(int[] arr)&#123;</div><div class="line">	array = arr;</div><div class="line">	end = array.length - 1;</div><div class="line">	for(int i=0;i&lt;array.length-1;i++)&#123;</div><div class="line">		buildMaxHeap(end);</div><div class="line">		swap(0,end);</div><div class="line">		end--;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">private static void swap(int i, int end) &#123;</div><div class="line">	// TODO Auto-generated method stub</div><div class="line">	int temp = array[i];</div><div class="line">	array[i] = array[end];</div><div class="line">	array[end] = temp;</div><div class="line">&#125;</div><div class="line"></div><div class="line">private static void buildMaxHeap(int end) &#123;</div><div class="line">	// TODO Auto-generated method stub</div><div class="line">	int biggerIndex = 0;</div><div class="line">	//从最后一个节点的父节点开始</div><div class="line">	for(int j = (end-1)/2;j&gt;=0;j--)&#123;</div><div class="line">		//k标记当前比较的节点</div><div class="line">		int k = j;</div><div class="line">		//当节点的左孩子存在时</div><div class="line">		while(k*2+1&lt;=end)&#123;</div><div class="line">			//现假设左孩子是两个孩子中的较大者</div><div class="line">			biggerIndex = k*2+1;</div><div class="line">			//查看右孩子是否存在</div><div class="line">			if(biggerIndex+1&lt;=end)&#123;</div><div class="line">				//查看左右孩子哪个更大</div><div class="line">				if(array[biggerIndex]&lt; array[biggerIndex+1])&#123;</div><div class="line">					//如果右孩子更大，更改biggerIndex，使它指向右孩子</div><div class="line">					biggerIndex++;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			</div><div class="line">			//查看当前节点和孩子中的较大节点哪个更大</div><div class="line">			if(array[k]&lt;array[biggerIndex])&#123;</div><div class="line">				//如果孩子中的较大节点更大，交换当前节点和较大孩子节点的值</div><div class="line">				swap(k,biggerIndex);</div><div class="line">				//把较大孩子节点作为下一次while的当前节点，来考察经过一次交换之后，有没有影响到子树的正确性。</div><div class="line">				k=biggerIndex;</div><div class="line">			&#125;else&#123;</div><div class="line">				break;//没有交换操作，则不需要检查子树的正确性</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public static int[] array;</div><div class="line"></div><div class="line">public static void sortArray(int[] arr)&#123;</div><div class="line">	array = arr;</div><div class="line">	for(int i=0;i&lt;array.length;i++)&#123;</div><div class="line">		bubble(i);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">private static void bubble(int i) &#123;</div><div class="line">	// TODO Auto-generated method stub</div><div class="line">	int tag=array.length-1;</div><div class="line">	while(tag&gt;i)&#123;</div><div class="line">		if(array[tag]&lt;array[tag-1])&#123;</div><div class="line">			swap(tag,tag-1);</div><div class="line">		&#125;</div><div class="line">		tag--;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">private static void swap(int i, int end) &#123;</div><div class="line">	// TODO Auto-generated method stub</div><div class="line">	int temp = array[i];</div><div class="line">	array[i] = array[end];</div><div class="line">	array[end] = temp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>选择一个基准元素,通常选择第一个元素或者最后一个元素,通过一趟扫描，</p>
<p>将待排序列分成两部分,一部分比基准元素小,一部分大于等于基准元素,此时基准元素在其</p>
<p>排好序后的正确位置,然后再用同样的方法递归地排序划分的两部分。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public static void sortArray(int[] arr)&#123;</div><div class="line">		array=arr;</div><div class="line">		sort(0,array.length-1);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private static void sort(int low, int high) &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		if(low&lt;high)&#123;</div><div class="line">			int middle =getMiddle(low, high);  </div><div class="line">            sort(low, middle - 1);       //对低字表进行递归排序     </div><div class="line">            sort(middle + 1, high);       //对高字表进行递归排</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public static int getMiddle(int low, int high) &#123;     </div><div class="line">             int tmp =array[low];    //数组的第一个作为中轴     </div><div class="line">             while (low &lt; high)&#123;     </div><div class="line">                 while (low &lt; high&amp;&amp; array[high] &gt;= tmp) &#123;     </div><div class="line">                    high--;     </div><div class="line">                 &#125;     </div><div class="line">    </div><div class="line">                 array[low] =array[high];   //比中轴小的记录移到低端     </div><div class="line">                 while (low &lt; high&amp;&amp; array[low] &lt;= tmp) &#123;     </div><div class="line">                     low++;     </div><div class="line">                 &#125;     </div><div class="line">    </div><div class="line">                 array[high] =array[low];   //比中轴大的记录移到高端     </div><div class="line">             &#125;     </div><div class="line">            array[low] = tmp;              //中轴记录到尾     </div><div class="line">             return low;                   //返回中轴的位置     </div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序（Merge）是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。</p>
<p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。 将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p>
<p>归并排序算法稳定，数组需要O(n)的额外空间，链表需要O(log(n))的额外空间，时间复杂度为O(nlog(n))，算法不是自适应的，不需要对数据的随机读取。</p>
<ul>
<li>工作原理</li>
</ul>
<ol>
<li><p>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</p>
</li>
<li><p>设定两个指针，最初位置分别为两个已经排序序列的起始位置</p>
</li>
<li><p>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</p>
</li>
<li><p>重复步骤3直到某一指针达到序列尾</p>
</li>
<li><p>将另一序列剩下的所有元素直接复制到合并序列尾</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">	static int[] array;</div><div class="line">//	static int left,right,mid;</div><div class="line">	public static void sortArray(int[] arr)&#123;</div><div class="line">		array = arr;</div><div class="line">		sort(0,array.length-1);</div><div class="line">	&#125;</div><div class="line">	private static void sort(int left, int right) &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		if(left&lt;right)&#123;</div><div class="line">			int center = (left+right)/2;</div><div class="line">			sort(left,center);</div><div class="line">			sort(center+1,right);</div><div class="line">			merge(left,center,right);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	private static void merge(int left, int center, int right) &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		int[] tmpArr = new int[array.length];</div><div class="line">		int tmpTag = left;</div><div class="line">		int leftTag = left;</div><div class="line">		int rightTag = center+1;</div><div class="line">		while(leftTag&lt;=center &amp;&amp; rightTag&lt;=right)&#123;</div><div class="line">			if(array[leftTag]&lt;array[rightTag])&#123;</div><div class="line">				tmpArr[tmpTag]=array[leftTag];</div><div class="line">				tmpTag++;</div><div class="line">				leftTag++;</div><div class="line">			&#125;else&#123;</div><div class="line">				tmpArr[tmpTag]=array[rightTag];</div><div class="line">				tmpTag++;</div><div class="line">				rightTag++;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		while(leftTag&lt;=center)&#123;</div><div class="line">			tmpArr[tmpTag]=array[leftTag];</div><div class="line">			tmpTag++;</div><div class="line">			leftTag++;</div><div class="line">		&#125;</div><div class="line">		while(rightTag&lt;=right)&#123;</div><div class="line">			tmpArr[tmpTag]=array[rightTag];</div><div class="line">			tmpTag++;</div><div class="line">			rightTag++;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		tmpTag = left;</div><div class="line">		while(tmpTag&lt;=right)&#123;</div><div class="line">			array[tmpTag]=tmpArr[tmpTag];</div><div class="line">			tmpTag++;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/02/Sort/" data-id="cje6pjw0n000nweyx9iyzcrm5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/排序算法/">排序算法</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-oneday-ShardPreferences" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/01/oneday-ShardPreferences/" class="article-date">
  <time datetime="2016-11-01T12:35:00.000Z" itemprop="datePublished">2016-11-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>►<a class="article-category-link" href="/categories/Android/Android-everyday/">Android_everyday</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/01/oneday-ShardPreferences/">ShardPreferences</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://www.jianshu.com/p/4dd53e1be5ba" target="_blank" rel="external">修改SharedPreferences后两种提交方式有什么区别？</a></p>
<h2 id="使用SharedPreferences的一个例子"><a href="#使用SharedPreferences的一个例子" class="headerlink" title="使用SharedPreferences的一个例子"></a>使用SharedPreferences的一个例子</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">SharedPreferences sp = context.getSharedPreferences(&quot;name&quot;,Context.MODE_PRIVATE);</div><div class="line"></div><div class="line">int val1 = sp.getInt(&quot;val1&quot;,0);</div><div class="line"></div><div class="line">SharedPreferences.Editor editor = sp.edit();</div><div class="line"></div><div class="line">editor.putInt(&quot;val1&quot;, val1+1);</div><div class="line"></div><div class="line">editor.apply();//异步写入</div><div class="line"></div><div class="line">// editor.commit();//同步写入</div></pre></td></tr></table></figure>
<h2 id="SharedPreferences源码"><a href="#SharedPreferences源码" class="headerlink" title="SharedPreferences源码"></a>SharedPreferences源码</h2><p>以上面的使用为例，分析SharedPreferences的相关实现过程。</p>
<h3 id="获取SharedPreferences：getSharedPreferences"><a href="#获取SharedPreferences：getSharedPreferences" class="headerlink" title="获取SharedPreferences：getSharedPreferences"></a>获取SharedPreferences：getSharedPreferences</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SharedPreferences sp = context.getSharedPreferences(&quot;name&quot;,Context.MODE_PRIVATE);</div></pre></td></tr></table></figure>
<p>我们通过context的getSharedPreferences方法来获取SharedPreferences，context的实现类是ContextImpl，查看这个函数(源码位置frameworks/base/core/java/android/app/ContextImpl.java)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">public SharedPreferences getSharedPreferences(String name, int mode) &#123;</div><div class="line">    SharedPreferencesImpl sp;</div><div class="line">    synchronized (ContextImpl.class) &#123;</div><div class="line">        if (sSharedPrefs == null) &#123;</div><div class="line">            sSharedPrefs = new ArrayMap&lt;String, ArrayMap&lt;String, SharedPreferencesImpl&gt;&gt;();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        final String packageName = getPackageName();</div><div class="line">        ArrayMap&lt;String, SharedPreferencesImpl&gt; packagePrefs = sSharedPrefs.get(packageName);</div><div class="line">        if (packagePrefs == null) &#123;</div><div class="line">            packagePrefs = new ArrayMap&lt;String, SharedPreferencesImpl&gt;();</div><div class="line">            sSharedPrefs.put(packageName, packagePrefs);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // At least one application in the world actually passes in a null</div><div class="line">        // name.  This happened to work because when we generated the file name</div><div class="line">        // we would stringify it to &quot;null.xml&quot;.  Nice.</div><div class="line">        if (mPackageInfo.getApplicationInfo().targetSdkVersion &lt;</div><div class="line">                Build.VERSION_CODES.KITKAT) &#123;</div><div class="line">            if (name == null) &#123;</div><div class="line">                name = &quot;null&quot;;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        sp = packagePrefs.get(name);</div><div class="line">        if (sp == null) &#123;</div><div class="line">            File prefsFile = getSharedPrefsFile(name);</div><div class="line">            sp = new SharedPreferencesImpl(prefsFile, mode);</div><div class="line">            packagePrefs.put(name, sp);</div><div class="line">            return sp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if ((mode &amp; Context.MODE_MULTI_PROCESS) != 0 ||</div><div class="line">        getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.HONEYCOMB) &#123;</div><div class="line">        // If somebody else (some other process) changed the prefs</div><div class="line">        // file behind our back, we reload it.  This has been the</div><div class="line">        // historical (if undocumented) behavior.</div><div class="line">        sp.startReloadIfChangedUnexpectedly();</div><div class="line">    &#125;</div><div class="line">    return sp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先可以看到的就是，整段代码是被一个synchronized (ContextImpl.class)同步锁包裹起来的。</p>
<p>然后代码依次做了以下操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">if (sSharedPrefs == null) &#123;</div><div class="line">                sSharedPrefs = new ArrayMap&lt;String, ArrayMap&lt;String, SharedPreferencesImpl&gt;&gt;();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            final String packageName = getPackageName();</div><div class="line">            ArrayMap&lt;String, SharedPreferencesImpl&gt; packagePrefs = sSharedPrefs.get(packageName);</div><div class="line">            if (packagePrefs == null) &#123;</div><div class="line">                packagePrefs = new ArrayMap&lt;String, SharedPreferencesImpl&gt;();</div><div class="line">                sSharedPrefs.put(packageName, packagePrefs);</div><div class="line">            &#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>判断sSharedPrefs是否为空，如果为空则执行初始化操作。从初始化代码可以看到，sSharedPrefs是一个用来缓存SharedPreferences的ArrayMap，它的key为包名，它的value为ArrayMap，这个ArrayMap保存的键值对是SharedPreferences文件名和对应的SharedPreferencesImpl（是SharedPreferences的实现类）。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// At least one application in the world actually passes in a null</div><div class="line">// name.  This happened to work because when we generated the file name</div><div class="line">// we would stringify it to &quot;null.xml&quot;.  Nice.</div><div class="line">if (mPackageInfo.getApplicationInfo().targetSdkVersion &lt;</div><div class="line">        Build.VERSION_CODES.KITKAT) &#123;</div><div class="line">    if (name == null) &#123;</div><div class="line">        name = &quot;null&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>对于KITKAT以前的版本做一个name的处理，不用分析了，可以忽略。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">sp = packagePrefs.get(name);</div><div class="line">if (sp == null) &#123;</div><div class="line">    File prefsFile = getSharedPrefsFile(name);</div><div class="line">    sp = new SharedPreferencesImpl(prefsFile, mode);</div><div class="line">    packagePrefs.put(name, sp);</div><div class="line">    return sp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>根据参数传入的name，获取SharedPreferencesImpl。如果SharedPreferencesImpl已经存在，它会直接返回已经存在的SharedPreferencesImpl。</li>
</ol>
<p>其中调用到getSharedPrefsFile(name)这个方法来获取存储数据的xml文件，查看与之相关的函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public File getSharedPrefsFile(String name) &#123;</div><div class="line">    return makeFilename(getPreferencesDir(), name + &quot;.xml&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">private File makeFilename(File base, String name) &#123;</div><div class="line">    if (name.indexOf(File.separatorChar) &lt; 0) &#123;</div><div class="line">        return new File(base, name);</div><div class="line">    &#125;</div><div class="line">    throw new IllegalArgumentException(</div><div class="line">            &quot;File &quot; + name + &quot; contains a path separator&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">    private File getPreferencesDir() &#123;</div><div class="line">    synchronized (mSync) &#123;</div><div class="line">        if (mPreferencesDir == null) &#123;</div><div class="line">            mPreferencesDir = new File(getDataDirFile(), &quot;shared_prefs&quot;);</div><div class="line">        &#125;</div><div class="line">        return mPreferencesDir;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">    private File getDataDirFile() &#123;</div><div class="line">    if (mPackageInfo != null) &#123;</div><div class="line">        return mPackageInfo.getDataDirFile();</div><div class="line">    &#125;</div><div class="line">    throw new RuntimeException(&quot;Not supported in system context&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到getSharedPrefsFile主要是一个文件路径的拼接过程，根据拼接的文件路径来打开文件。</p>
<p><strong>至此，同步锁内的代码结束</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">if ((mode &amp; Context.MODE_MULTI_PROCESS) != 0 ||</div><div class="line">    getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.HONEYCOMB) &#123;</div><div class="line">    // If somebody else (some other process) changed the prefs</div><div class="line">    // file behind our back, we reload it.  This has been the</div><div class="line">    // historical (if undocumented) behavior.</div><div class="line">    sp.startReloadIfChangedUnexpectedly();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>如果是在多进程模式下，或者目标版本低于HONEYCOMB的时候，会检查是否需要重新从磁盘中加载文件。但是需要说的是MODE_MULTI_PROCESS模式已经被deprecated了，官方建议使用ContentProvider来处理多进程访问.</li>
</ol>
<h3 id="SharedPreferencesImpl构造函数"><a href="#SharedPreferencesImpl构造函数" class="headerlink" title="SharedPreferencesImpl构造函数"></a>SharedPreferencesImpl构造函数</h3><p>根据上面的代码，可以得知，SharedPreferencesImpl是SharedPreferences的实现类。源码位置：frameworks/base/core/java/android/app/SharedPreferencesImpl.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">SharedPreferencesImpl(File file, int mode) &#123;</div><div class="line">    mFile = file;</div><div class="line">    mBackupFile = makeBackupFile(file);</div><div class="line">    mMode = mode;</div><div class="line">    mLoaded = false;</div><div class="line">    mMap = null;</div><div class="line">    startLoadFromDisk();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>除了赋值操作外，构造函数主要完成了以下操作：</p>
<ol>
<li>makeBackupFile(file)创建了一个.bak的备份文件</li>
<li>调用startLoadFromDisk()方法读出xml文件，这个读取过程是使用DOM方式解析的（一开始就把整个XML给读取出来）。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">private void startLoadFromDisk() &#123;</div><div class="line">    synchronized (this) &#123;</div><div class="line">        mLoaded = false;</div><div class="line">    &#125;</div><div class="line">    new Thread(&quot;SharedPreferencesImpl-load&quot;) &#123;</div><div class="line">        public void run() &#123;</div><div class="line">            synchronized (SharedPreferencesImpl.this) &#123;</div><div class="line">                loadFromDiskLocked();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;.start();</div><div class="line">&#125;</div><div class="line"></div><div class="line">    private void loadFromDiskLocked() &#123;</div><div class="line">    if (mLoaded) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    if (mBackupFile.exists()) &#123;</div><div class="line">        mFile.delete();</div><div class="line">        mBackupFile.renameTo(mFile);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Debugging</div><div class="line">    if (mFile.exists() &amp;&amp; !mFile.canRead()) &#123;</div><div class="line">        Log.w(TAG, &quot;Attempt to read preferences file &quot; + mFile + &quot; without permission&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Map map = null;</div><div class="line">    StructStat stat = null;</div><div class="line">    try &#123;</div><div class="line">        stat = Os.stat(mFile.getPath());</div><div class="line">        if (mFile.canRead()) &#123;</div><div class="line">            BufferedInputStream str = null;</div><div class="line">            try &#123;</div><div class="line">                str = new BufferedInputStream(</div><div class="line">                        new FileInputStream(mFile), 16*1024);</div><div class="line">                map = XmlUtils.readMapXml(str);</div><div class="line">            &#125; catch (XmlPullParserException e) &#123;</div><div class="line">                Log.w(TAG, &quot;getSharedPreferences&quot;, e);</div><div class="line">            &#125; catch (FileNotFoundException e) &#123;</div><div class="line">                Log.w(TAG, &quot;getSharedPreferences&quot;, e);</div><div class="line">            &#125; catch (IOException e) &#123;</div><div class="line">                Log.w(TAG, &quot;getSharedPreferences&quot;, e);</div><div class="line">            &#125; finally &#123;</div><div class="line">                IoUtils.closeQuietly(str);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; catch (ErrnoException e) &#123;</div><div class="line">    &#125;</div><div class="line">    mLoaded = true;</div><div class="line">    if (map != null) &#123;</div><div class="line">        mMap = map;</div><div class="line">        mStatTimestamp = stat.st_mtime;</div><div class="line">        mStatSize = stat.st_size;</div><div class="line">    &#125; else &#123;</div><div class="line">        mMap = new HashMap&lt;String, Object&gt;();</div><div class="line">    &#125;</div><div class="line">    notifyAll();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>startLoadFromDisk()方法使用了一个异步线程来读取xml，同时使用了同步锁调用loadFromDiskLocked()来执行真正的读取操作。读取操作最终调用了XmlUtils.readMapXml(str)方法，读取整个xml的内容，放到mMap当中。</p>
<h2 id="读取：getxxx"><a href="#读取：getxxx" class="headerlink" title="读取：getxxx"></a>读取：getxxx</h2><p>以getInt为例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public int getInt(String key, int defValue) &#123;</div><div class="line">    synchronized (this) &#123;</div><div class="line">        awaitLoadedLocked();</div><div class="line">        Integer v = (Integer)mMap.get(key);</div><div class="line">        return v != null ? v : defValue;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先获取锁awaitLoadedLocked()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">private void awaitLoadedLocked() &#123;</div><div class="line">    if (!mLoaded) &#123;</div><div class="line">        // Raise an explicit StrictMode onReadFromDisk for this</div><div class="line">        // thread, since the real read will be in a different</div><div class="line">        // thread and otherwise ignored by StrictMode.</div><div class="line">        BlockGuard.getThreadPolicy().onReadFromDisk();</div><div class="line">    &#125;</div><div class="line">    while (!mLoaded) &#123;</div><div class="line">        try &#123;</div><div class="line">            wait();</div><div class="line">        &#125; catch (InterruptedException unused) &#123;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后根据key获取value，因为在构造函数中已经完整的读出了xml文件，所以这个获取过程很简单。</p>
<p>最后根据获取到的值判空并返回Value。</p>
<h3 id="editor的获取"><a href="#editor的获取" class="headerlink" title="editor的获取"></a>editor的获取</h3><p>SharedPreferences的写入过程主要分三步，获取editor；put操作（以putInt为例）；apply/commit。</p>
<p>首先分析获取editor的过程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public Editor edit() &#123;</div><div class="line">    // TODO: remove the need to call awaitLoadedLocked() when</div><div class="line">    // requesting an editor.  will require some work on the</div><div class="line">    // Editor, but then we should be able to do:</div><div class="line">    //</div><div class="line">    //      context.getSharedPreferences(..).edit().putString(..).apply()</div><div class="line">    //</div><div class="line">    // ... all without blocking.</div><div class="line">    synchronized (this) &#123;</div><div class="line">        awaitLoadedLocked();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return new EditorImpl();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>new了一个EditorImpl的实例。</p>
<h3 id="putInt"><a href="#putInt" class="headerlink" title="putInt"></a>putInt</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">private final Map&lt;String, Object&gt; mModified = Maps.newHashMap();</div><div class="line"></div><div class="line">public Editor putInt(String key, int value) &#123;</div><div class="line">    synchronized (this) &#123;</div><div class="line">        mModified.put(key, value);</div><div class="line">        return this;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出执行putxxx操作时，数据只是写入到了一个名为mModified的map当中，写入到xml文件的过程将在下一步进行。</p>
<h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public void apply() &#123;</div><div class="line">    final MemoryCommitResult mcr = commitToMemory();</div><div class="line">    final Runnable awaitCommit = new Runnable() &#123;</div><div class="line">            public void run() &#123;</div><div class="line">                try &#123;</div><div class="line">                    mcr.writtenToDiskLatch.await();</div><div class="line">                &#125; catch (InterruptedException ignored) &#123;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">    QueuedWork.add(awaitCommit);</div><div class="line"></div><div class="line">    Runnable postWriteRunnable = new Runnable() &#123;</div><div class="line">            public void run() &#123;</div><div class="line">                awaitCommit.run();</div><div class="line">                QueuedWork.remove(awaitCommit);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">    SharedPreferencesImpl.this.enqueueDiskWrite(mcr, postWriteRunnable);</div><div class="line"></div><div class="line">    // Okay to notify the listeners before it&apos;s hit disk</div><div class="line">    // because the listeners should always get the same</div><div class="line">    // SharedPreferences instance back, which has the</div><div class="line">    // changes reflected in memory.</div><div class="line">    notifyListeners(mcr);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public boolean commit() &#123;</div><div class="line">    MemoryCommitResult mcr = commitToMemory();</div><div class="line">    SharedPreferencesImpl.this.enqueueDiskWrite(</div><div class="line">        mcr, null /* sync write on this thread okay */);</div><div class="line">    try &#123;</div><div class="line">        mcr.writtenToDiskLatch.await();</div><div class="line">    &#125; catch (InterruptedException e) &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">    notifyListeners(mcr);</div><div class="line">    return mcr.writeToDiskResult;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>apply和commit的主要差别在于apply是异步执行的，而commit是同步执行的。两者都调用了几个核心的函数：commitToMemory；mcr.writtenToDiskLatch.await()；<br>SharedPreferencesImpl.this.enqueueDiskWrite；notifyListeners<br>依次分析核心函数：</p>
<h4 id="commitToMemory"><a href="#commitToMemory" class="headerlink" title="commitToMemory"></a>commitToMemory</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">private MemoryCommitResult commitToMemory() &#123;</div><div class="line">    MemoryCommitResult mcr = new MemoryCommitResult();</div><div class="line">    synchronized (SharedPreferencesImpl.this) &#123;</div><div class="line">        // We optimistically don&apos;t make a deep copy until</div><div class="line">        // a memory commit comes in when we&apos;re already</div><div class="line">        // writing to disk.</div><div class="line">        if (mDiskWritesInFlight &gt; 0) &#123;</div><div class="line">            // We can&apos;t modify our mMap as a currently</div><div class="line">            // in-flight write owns it.  Clone it before</div><div class="line">            // modifying it.</div><div class="line">            // noinspection unchecked</div><div class="line">            mMap = new HashMap&lt;String, Object&gt;(mMap);</div><div class="line">        &#125;</div><div class="line">        mcr.mapToWriteToDisk = mMap;</div><div class="line">        mDiskWritesInFlight++;</div><div class="line"></div><div class="line">        boolean hasListeners = mListeners.size() &gt; 0;</div><div class="line">        if (hasListeners) &#123;</div><div class="line">            mcr.keysModified = new ArrayList&lt;String&gt;();</div><div class="line">            mcr.listeners =</div><div class="line">                            new HashSet&lt;OnSharedPreferenceChangeListener&gt;(mListeners.keySet());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        synchronized (this) &#123;</div><div class="line">            if (mClear) &#123;</div><div class="line">                if (!mMap.isEmpty()) &#123;</div><div class="line">                    mcr.changesMade = true;</div><div class="line">                    mMap.clear();</div><div class="line">               &#125;</div><div class="line">              mClear = false;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">           for (Map.Entry&lt;String, Object&gt; e : mModified.entrySet()) &#123;</div><div class="line">                String k = e.getKey();</div><div class="line">                Object v = e.getValue();</div><div class="line">                // &quot;this&quot; is the magic value for a removal mutation. In addition,</div><div class="line">                // setting a value to &quot;null&quot; for a given key is specified to be</div><div class="line">                // equivalent to calling remove on that key.</div><div class="line">                if (v == this || v == null) &#123;</div><div class="line">                    if (!mMap.containsKey(k)) &#123;</div><div class="line">                       continue;</div><div class="line">                    &#125;</div><div class="line">                    mMap.remove(k);</div><div class="line">                &#125; else &#123;</div><div class="line">                    if (mMap.containsKey(k)) &#123;</div><div class="line">                        Object existingValue = mMap.get(k);</div><div class="line">                        if (existingValue != null &amp;&amp; existingValue.equals(v)) &#123;</div><div class="line">                            continue;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    mMap.put(k, v);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                 = true;</div><div class="line">                if (hasListeners) &#123;</div><div class="line">                    mcr.keysModified.add(k);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            mModified.clear();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return mcr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>首先是一个SharedPreferencesImpl.this的同步锁，所有代码都被这个同步锁包裹。</li>
<li>对写操作的数量做了判断，如果大于0，就做一个mMap的copy，并增加计数器。</li>
<li>对监听数量做了判断。</li>
<li>对EditorImpl加同步锁，在这两重锁的作用下，同一个线程中如果有后续的get操作，都会被阻塞。</li>
<li>先处理clear的情况，所以这次clear不会情调本次写操作的数据，只会清除掉之前的数据</li>
<li>遍历mModified，处理各个key，value，将mModified中的值更新到mMap当中。</li>
<li>标记mcr.changesMade为true，表示有更新</li>
<li>清空mModified，并返回MemoryCommitResult mcr。</li>
</ul>
<h4 id="异步写入MemoryCommitResult"><a href="#异步写入MemoryCommitResult" class="headerlink" title="异步写入MemoryCommitResult"></a>异步写入MemoryCommitResult</h4><p>这是apply函数中的一部分。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">final Runnable awaitCommit = new Runnable() &#123;</div><div class="line">                    public void run() &#123;</div><div class="line">                        try &#123;</div><div class="line">                            mcr.writtenToDiskLatch.await();</div><div class="line">                        &#125; catch (InterruptedException ignored) &#123;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;;</div><div class="line"></div><div class="line">            QueuedWork.add(awaitCommit);</div><div class="line"></div><div class="line">            Runnable postWriteRunnable = new Runnable() &#123;</div><div class="line">                    public void run() &#123;</div><div class="line">                        awaitCommit.run();</div><div class="line">                        QueuedWork.remove(awaitCommit);</div><div class="line">                    &#125;</div><div class="line">                &#125;;</div></pre></td></tr></table></figure></p>
<p>这一段的主要作用是将mcr.writtenToDiskLatch.await放入线程队列中异步执行。在执行的过程中会阻塞住线程，并且在执行结束后从队列中删除这个任务。</p>
<h4 id="SharedPreferencesImpl-this-enqueueDiskWrite"><a href="#SharedPreferencesImpl-this-enqueueDiskWrite" class="headerlink" title="SharedPreferencesImpl.this.enqueueDiskWrite"></a>SharedPreferencesImpl.this.enqueueDiskWrite</h4><p>将mcr写到磁盘中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">private void enqueueDiskWrite(final MemoryCommitResult mcr,</div><div class="line">                              final Runnable postWriteRunnable) &#123;</div><div class="line">    final Runnable writeToDiskRunnable = new Runnable() &#123;</div><div class="line">            public void run() &#123;</div><div class="line">                synchronized (mWritingToDiskLock) &#123;</div><div class="line">                    writeToFile(mcr);</div><div class="line">                &#125;</div><div class="line">                synchronized (SharedPreferencesImpl.this) &#123;</div><div class="line">                    mDiskWritesInFlight--;</div><div class="line">                &#125;</div><div class="line">                if (postWriteRunnable != null) &#123;</div><div class="line">                    postWriteRunnable.run();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">    final boolean isFromSyncCommit = (postWriteRunnable == null);</div><div class="line"></div><div class="line">    // Typical #commit() path with fewer allocations, doing a write on</div><div class="line">    // the current thread.</div><div class="line">    if (isFromSyncCommit) &#123;</div><div class="line">        boolean wasEmpty = false;</div><div class="line">        synchronized (SharedPreferencesImpl.this) &#123;</div><div class="line">            wasEmpty = mDiskWritesInFlight == 1;</div><div class="line">        &#125;</div><div class="line">        if (wasEmpty) &#123;</div><div class="line">            writeToDiskRunnable.run();</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    QueuedWork.singleThreadExecutor().execute(writeToDiskRunnable);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>writeToDiskRunnable是真正执行写操作的runnable，其中首先使用同步锁保护，执行writeToFile操作，然后使用同步锁保护，将写操作的计数减一。</p>
<p>postWriteRunnable是apply时才有的，如果时apply调用了enqueueDiskWrite，则执行传过来的postWriteRunnable。</p>
<p>如果是commit调用了enqueueDiskWrite，执行if (isFromSyncCommit) 包裹的内容，直接调用writeToDiskRunnable.run()，将数据写入磁盘；如果是apply调用了enqueueDiskWrite，将其交给单线程的thread executor去执行。</p>
<p>####<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">private void writeToFile(MemoryCommitResult mcr) &#123;</div><div class="line">    // Rename the current file so it may be used as a backup during the next read</div><div class="line">    if (mFile.exists()) &#123;//如果文件已经存在</div><div class="line">        if (!mcr.changesMade) &#123;//并且changesMade为false，说明没有什么更新和变化</div><div class="line">            // If the file already exists, but no changes were</div><div class="line">            // made to the underlying map, it&apos;s wasteful to</div><div class="line">            // re-write the file.  Return as if we wrote it</div><div class="line">            // out.</div><div class="line">            mcr.setDiskWriteResult(true);//写入文件结果为true</div><div class="line">            return;//直接返回</div><div class="line">        &#125;</div><div class="line">        if (!mBackupFile.exists()) &#123;//如果备份文件不存在，试着将mFile重命名，作为备份文件。这样如果本次写操作失败了，还有备份文件可以恢复。</div><div class="line">            if (!mFile.renameTo(mBackupFile)) &#123;//如果重命名失败了</div><div class="line">                Log.e(TAG, &quot;Couldn&apos;t rename file &quot; + mFile</div><div class="line">                      + &quot; to backup file &quot; + mBackupFile);</div><div class="line">                mcr.setDiskWriteResult(false);//报错，并表示写入文件结果为false</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            mFile.delete();//如果重命名成功了，删除mFile</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Attempt to write the file, delete the backup and return true as atomically as</div><div class="line">    // possible.  If any exception occurs, delete the new file; next time we will restore</div><div class="line">    // from the backup.</div><div class="line">    try &#123;</div><div class="line">        FileOutputStream str = createFileOutputStream(mFile);//创建新的mFile</div><div class="line">        if (str == null) &#123;</div><div class="line">            mcr.setDiskWriteResult(false);//如果失败的话，将写入文件的结果设为false，并返回</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        XmlUtils.writeMapXml(mcr.mapToWriteToDisk, str);//将mcr的mapToWriteToDisk写入到新的mFile当中</div><div class="line">        FileUtils.sync(str);</div><div class="line">        str.close();//关闭文件流</div><div class="line">        ContextImpl.setFilePermissionsFromMode(mFile.getPath(), mMode, 0);//根据mMode设置权限</div><div class="line">        try &#123;</div><div class="line">            final StructStat stat = Os.stat(mFile.getPath());</div><div class="line">            synchronized (this) &#123;//处理相关的变量</div><div class="line">                mStatTimestamp = stat.st_mtime;</div><div class="line">                mStatSize = stat.st_size;</div><div class="line">            &#125;</div><div class="line">        &#125; catch (ErrnoException e) &#123;</div><div class="line">            // Do nothing</div><div class="line">        &#125;</div><div class="line">        // Writing was successful, delete the backup file if there is one.</div><div class="line">        mBackupFile.delete();//删除备份文件</div><div class="line">        mcr.setDiskWriteResult(true);//标记写入成功</div><div class="line">        return;//返回</div><div class="line">    &#125; catch (XmlPullParserException e) &#123;</div><div class="line">        Log.w(TAG, &quot;writeToFile: Got exception:&quot;, e);</div><div class="line">    &#125; catch (IOException e) &#123;</div><div class="line">        Log.w(TAG, &quot;writeToFile: Got exception:&quot;, e);</div><div class="line">    &#125;</div><div class="line">    // Clean up an unsuccessfully written file</div><div class="line">    if (mFile.exists()) &#123;//如果在以上的写入过程中除了问题，删除mFile</div><div class="line">        if (!mFile.delete()) &#123;</div><div class="line">            Log.e(TAG, &quot;Couldn&apos;t clean up partially-written file &quot; + mFile);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    mcr.setDiskWriteResult(false);//标记写入失败</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>至此，写入操作就分析完了。可以看出，每次调用put的时候并没有真的将数据写入磁盘中，而是在调用commit或者apply时，将整个文件重写一遍。所以，在修改多个条目时，应该将所有的put操作执行完，最后调用依次commit或者apply。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>SharedPreferences的读取，是一个异步的过程，在context.getSharedPreferences时，已经将整个xml文件都读取出来了。另外，会使用ArrayMap对SharedPreferences进行缓存，以SharedPreferences的name作为key。</p>
<p>SharedPreferences的写入是通过editor完成的。有两种方式写入，异步的apply和同步的commit。所以如果是在主线程执行写入操作，要考虑到ANR的问题，最好使用apply。</p>
<p>所有的线程读取的时候都会加SharedPreferencesImpl.this锁，editor写入内存的时候（写入SharedPreferencesImpl.this.mMap）也会加SharedPreferencesImpl.this锁，另外editor调用put，clear, remove方法的时候都会加上EditorImpl.this锁，这些是线程安全的保证，只有在commit/apply后才会写入内存（mMap, xml内容缓存的map变量）和磁盘。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/01/oneday-ShardPreferences/" data-id="cje6pjw1s003iweyx0diwz8pl" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android-everyday/">Android_everyday</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-oneday-AsyncTask" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/31/oneday-AsyncTask/" class="article-date">
  <time datetime="2016-10-31T11:07:51.000Z" itemprop="datePublished">2016-10-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>►<a class="article-category-link" href="/categories/Android/Android-everyday/">Android_everyday</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/31/oneday-AsyncTask/">AsyncTask</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://www.jianshu.com/p/c925b3ea1444" target="_blank" rel="external">在項目中使用AsyncTask會有什麼問題麼</a></p>
<h2 id="使用AsyncTask的例子"><a href="#使用AsyncTask的例子" class="headerlink" title="使用AsyncTask的例子"></a>使用AsyncTask的例子</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line">import android.app.Activity;  </div><div class="line">import android.app.ProgressDialog;  </div><div class="line">import android.os.AsyncTask;  </div><div class="line">import android.os.Bundle;  </div><div class="line">import android.util.Log;  </div><div class="line">import android.widget.TextView;  </div><div class="line">  </div><div class="line">public class MainActivity extends Activity  </div><div class="line">&#123;  </div><div class="line">  </div><div class="line">    private static final String TAG = &quot;MainActivity&quot;;  </div><div class="line">    private ProgressDialog mDialog;  </div><div class="line">    private TextView mTextView;  </div><div class="line">  </div><div class="line">    @Override  </div><div class="line">    protected void onCreate(Bundle savedInstanceState)  </div><div class="line">    &#123;  </div><div class="line">        super.onCreate(savedInstanceState);  </div><div class="line">        setContentView(R.layout.activity_main);  </div><div class="line">  </div><div class="line">        mTextView = (TextView) findViewById(R.id.id_tv);  </div><div class="line">  </div><div class="line">        mDialog = new ProgressDialog(this);  </div><div class="line">        mDialog.setMax(100);  </div><div class="line">        mDialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);  </div><div class="line">        mDialog.setCancelable(false);  </div><div class="line">  </div><div class="line">        new MyAsyncTask().execute();  </div><div class="line">  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    private class MyAsyncTask extends AsyncTask&lt;Void, Integer, Void&gt;  </div><div class="line">    &#123;  </div><div class="line">  </div><div class="line">        @Override  </div><div class="line">        protected void onPreExecute()  </div><div class="line">        &#123;  </div><div class="line">            mDialog.show();  </div><div class="line">            Log.e(TAG, Thread.currentThread().getName() + &quot; onPreExecute &quot;);  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        @Override  </div><div class="line">        protected Void doInBackground(Void... params)  </div><div class="line">        &#123;  </div><div class="line">  </div><div class="line">            // 模拟数据的加载,耗时的任务  </div><div class="line">            for (int i = 0; i &lt; 100; i++)  </div><div class="line">            &#123;  </div><div class="line">                try  </div><div class="line">                &#123;  </div><div class="line">                    Thread.sleep(80);  </div><div class="line">                &#125; catch (InterruptedException e)  </div><div class="line">                &#123;  </div><div class="line">                    e.printStackTrace();  </div><div class="line">                &#125;  </div><div class="line">                publishProgress(i);  </div><div class="line">            &#125;  </div><div class="line">  </div><div class="line">            Log.e(TAG, Thread.currentThread().getName() + &quot; doInBackground &quot;);  </div><div class="line">            return null;  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        @Override  </div><div class="line">        protected void onProgressUpdate(Integer... values)  </div><div class="line">        &#123;  </div><div class="line">            mDialog.setProgress(values[0]);  </div><div class="line">            Log.e(TAG, Thread.currentThread().getName() + &quot; onProgressUpdate &quot;);  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        @Override  </div><div class="line">        protected void onPostExecute(Void result)  </div><div class="line">        &#123;  </div><div class="line">            // 进行数据加载完成后的UI操作  </div><div class="line">            mDialog.dismiss();  </div><div class="line">            mTextView.setText(&quot;LOAD DATA SUCCESS &quot;);  </div><div class="line">            Log.e(TAG, Thread.currentThread().getName() + &quot; onPostExecute &quot;);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>MyAsyncTask繼承自AsyncTask,需要重寫的函數主要有四個：onPreExecute,doInBackground,onProgressUpdate,onPostExecute</p>
<h2 id="AsyncTask源碼"><a href="#AsyncTask源碼" class="headerlink" title="AsyncTask源碼"></a>AsyncTask源碼</h2><p>以下源碼基於android sdk 21版本，源碼位置：android/os/AsyncTask.java</p>
<h3 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h3><p>在AsyncTask的使用中，只要寫好繼承於AsyncTask的類之後，就可以直接使用<code>new MyAsyncTask().execute();</code>來執行調用。所以，對於源碼的分析，也從execute()方法開始。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123;</div><div class="line">    return executeOnExecutor(sDefaultExecutor, params);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec,</div><div class="line">        Params... params) &#123;</div><div class="line">    if (mStatus != Status.PENDING) &#123;</div><div class="line">        switch (mStatus) &#123;</div><div class="line">            case RUNNING:</div><div class="line">                throw new IllegalStateException(&quot;Cannot execute task:&quot;</div><div class="line">                        + &quot; the task is already running.&quot;);</div><div class="line">            case FINISHED:</div><div class="line">                throw new IllegalStateException(&quot;Cannot execute task:&quot;</div><div class="line">                        + &quot; the task has already been executed &quot;</div><div class="line">                        + &quot;(a task can be executed only once)&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mStatus = Status.RUNNING;</div><div class="line"></div><div class="line">    onPreExecute();</div><div class="line"></div><div class="line">    mWorker.mParams = params;</div><div class="line">    exec.execute(mFuture);</div><div class="line"></div><div class="line">    return this;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>分析executeOnExecutor這個函數，</p>
<ul>
<li>首先，判斷了AsyncTask的狀態mStatus，如果不是PENDING狀態，就根據當前狀態拋出對應的exception,由此可見，每個AsyncTask在完成之前只能執行一次。</li>
<li>然後將mStatus設置爲RUNNING</li>
<li>執行onPreExecute()，這是依然在UI線程，可以根據需要執行一些準備工作</li>
<li>接下來兩行，出現了兩個沒見過的變量：一個是mWorker,我們將params賦值給了mWorker.mParams。第二個是mFuture，我們執行了exec.execute(mFuture)。分別來分析這兩個變量和這兩行代碼。</li>
</ul>
<h3 id="mWorker和mFuture"><a href="#mWorker和mFuture" class="headerlink" title="mWorker和mFuture"></a>mWorker和mFuture</h3><p>在源碼上部，可以看到這兩個變量的定義<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">private final WorkerRunnable&lt;Params, Result&gt; mWorker;</div><div class="line">private final FutureTask&lt;Result&gt; mFuture;</div></pre></td></tr></table></figure></p>
<p>WorkerRunnable是Callable的子类，且包含一个mParams用于保存我们传入的参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">  private static abstract class WorkerRunnable&lt;Params, Result&gt; implements Callable&lt;Result&gt; &#123;  </div><div class="line">        Params[] mParams;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>mWorker和mFuture的初始化都在AsyncTask的構造函數中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public AsyncTask() &#123;</div><div class="line">    mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123;</div><div class="line">        public Result call() throws Exception &#123;</div><div class="line">            mTaskInvoked.set(true);</div><div class="line"></div><div class="line">            Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line">            //noinspection unchecked</div><div class="line">            return postResult(doInBackground(mParams));</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123;</div><div class="line">        @Override</div><div class="line">        protected void done() &#123;</div><div class="line">            try &#123;</div><div class="line">                postResultIfNotInvoked(get());</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                android.util.Log.w(LOG_TAG, e);</div><div class="line">            &#125; catch (ExecutionException e) &#123;</div><div class="line">                throw new RuntimeException(&quot;An error occured while executing doInBackground()&quot;,</div><div class="line">                        e.getCause());</div><div class="line">            &#125; catch (CancellationException e) &#123;</div><div class="line">                postResultIfNotInvoked(null);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>先看mWorker<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123;</div><div class="line">    public Result call() throws Exception &#123;</div><div class="line">        mTaskInvoked.set(true);</div><div class="line"></div><div class="line">        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line">        //noinspection unchecked</div><div class="line">        return postResult(doInBackground(mParams));</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>new了一個WorkerRunnable的實現類，並且實現了call方法，在call方法中，</p>
<ul>
<li>首先設置了mTaskInvoked爲true，這個在後面會用到</li>
<li>最終調用到了<code>postResult(doInBackground(mParams));</code>查看這個函數<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">private Result postResult(Result result) &#123;</div><div class="line">        @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">        Message message = sHandler.obtainMessage(MESSAGE_POST_RESULT,</div><div class="line">                new AsyncTaskResult&lt;Result&gt;(this, result));</div><div class="line">        message.sendToTarget();</div><div class="line">        return result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>handler，message那一套東西。在這裏send了一個消息。</p>
<ul>
<li>這個消息的message.what爲MESSAGE_POST_RESULT</li>
<li>message.object是一個AsyncTaskResult類的對象，查看這個類的源碼<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">private static class AsyncTaskResult&lt;Data&gt; &#123;</div><div class="line">    final AsyncTask mTask;</div><div class="line">    final Data[] mData;</div><div class="line"></div><div class="line">    AsyncTaskResult(AsyncTask task, Data... data) &#123;</div><div class="line">        mTask = task;</div><div class="line">        mData = data;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>AsyncTaskResult就是一个简单的携带参数的对象。</p>
<p>有message的發出方，就肯定有接收方，查看sHandler的初始化過程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">private static final InternalHandler sHandler = new InternalHandler();</div></pre></td></tr></table></figure></p>
<p>查看InternalHandler類：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">private static class InternalHandler extends Handler &#123;</div><div class="line">    @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;&#125;)</div><div class="line">    @Override</div><div class="line">    public void handleMessage(Message msg) &#123;</div><div class="line">        AsyncTaskResult result = (AsyncTaskResult) msg.obj;</div><div class="line">        switch (msg.what) &#123;</div><div class="line">            case MESSAGE_POST_RESULT:</div><div class="line">                // There is only one result</div><div class="line">                result.mTask.finish(result.mData[0]);</div><div class="line">                break;</div><div class="line">            case MESSAGE_POST_PROGRESS:</div><div class="line">                result.mTask.onProgressUpdate(result.mData);</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>InternalHandler接收兩種message，其中對MESSAGE_POST_RESULT消息的處理調用了finish()方法，查看這個方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">private void finish(Result result) &#123;</div><div class="line">    if (isCancelled()) &#123;</div><div class="line">        onCancelled(result);</div><div class="line">    &#125; else &#123;</div><div class="line">        onPostExecute(result);</div><div class="line">    &#125;</div><div class="line">    mStatus = Status.FINISHED;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>調用了onPostExecute方法，並且把mStatus設置爲FINISHED。</p>
<p>mWorker分析完了，接下來看mFuture，在AsyncTask的構造方法中初始化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123;</div><div class="line">    @Override</div><div class="line">    protected void done() &#123;</div><div class="line">        try &#123;</div><div class="line">            postResultIfNotInvoked(get());</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line">            android.util.Log.w(LOG_TAG, e);</div><div class="line">        &#125; catch (ExecutionException e) &#123;</div><div class="line">            throw new RuntimeException(&quot;An error occured while executing doInBackground()&quot;,</div><div class="line">                    e.getCause());</div><div class="line">        &#125; catch (CancellationException e) &#123;</div><div class="line">            postResultIfNotInvoked(null);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>new了一個FutureTask的實現類，並把mWorker作爲參數傳入。重寫了done方法。在任務執行結束後會調用postResultIfNotInvoked(get())，其中get()方法獲取mWorker的call的返回值，也就是result。</p>
<p>查看postResultIfNotInvoked方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">private void postResultIfNotInvoked(Result result) &#123;</div><div class="line">    final boolean wasTaskInvoked = mTaskInvoked.get();</div><div class="line">    if (!wasTaskInvoked) &#123;</div><div class="line">        postResult(result);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>這裏首先判斷了wasTaskInvoked，如果是false，則調用postResult方法。然而在前面mWorker的初始化過程中，就已經將mTaskInvoked設爲true了，所以，postResult方法並不會調用到。</p>
<h3 id="繼續execute方法"><a href="#繼續execute方法" class="headerlink" title="繼續execute方法"></a>繼續execute方法</h3><p>mWorker和mFuture的初始化已經分析完，接下來繼續看execute方法中的exec.execute(mFuture)</p>
<p>exec，也就是sDefaultExecutor，查看它的初始化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public static final Executor SERIAL_EXECUTOR = new SerialExecutor();</div><div class="line">private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;</div></pre></td></tr></table></figure></p>
<p>它是一個SerialExecutor類的實例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">private static class SerialExecutor implements Executor &#123;</div><div class="line">        final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;();</div><div class="line">        Runnable mActive;</div><div class="line"></div><div class="line">        public synchronized void execute(final Runnable r) &#123;</div><div class="line">            mTasks.offer(new Runnable() &#123;</div><div class="line">                public void run() &#123;</div><div class="line">                    try &#123;</div><div class="line">                        r.run();</div><div class="line">                    &#125; finally &#123;</div><div class="line">                        scheduleNext();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">            if (mActive == null) &#123;</div><div class="line">                scheduleNext();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        protected synchronized void scheduleNext() &#123;</div><div class="line">            if ((mActive = mTasks.poll()) != null) &#123;</div><div class="line">                THREAD_POOL_EXECUTOR.execute(mActive);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>SerialExecutor內部維護着一個任務隊列ArrayDeque<runnable> mTasks。</runnable></p>
<p>查看execute（Runnable runnable）方法，將Runnable r放到mTask的隊尾，然後調用scheduleNext，依次取出隊首的任務，執行任務。其中，THREAD_POOL_EXECUTOR是一個線程池。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();</div><div class="line">private static final int CORE_POOL_SIZE = CPU_COUNT + 1;</div><div class="line">private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;</div><div class="line">private static final int KEEP_ALIVE = 1;</div><div class="line"></div><div class="line">public static final Executor THREAD_POOL_EXECUTOR</div><div class="line">        = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE,</div><div class="line">                TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);</div><div class="line">                </div><div class="line">                    private static final BlockingQueue&lt;Runnable&gt; sPoolWorkQueue =</div><div class="line">        new LinkedBlockingQueue&lt;Runnable&gt;(128);</div></pre></td></tr></table></figure></p>
<p>這個線程池最大支持CPU_COUNT * 2 + 1個線程，再加上長度爲128的阻塞隊列。</p>
<p>然而在執行的時候，是依次取出任務，線性執行的。</p>
<h2 id="整個過程"><a href="#整個過程" class="headerlink" title="整個過程"></a>整個過程</h2><p>AsyncTask內部維護了一個線程池，一個任務隊列，從任務隊列中依次取出任務，並使用線程池中的線程來執行。執行完成後，使用handler，message機制更新狀態。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec,</div><div class="line">        Params... params) &#123;</div><div class="line">    if (mStatus != Status.PENDING) &#123;</div><div class="line">        switch (mStatus) &#123;</div><div class="line">            case RUNNING:</div><div class="line">                throw new IllegalStateException(&quot;Cannot execute task:&quot;</div><div class="line">                        + &quot; the task is already running.&quot;);</div><div class="line">            case FINISHED:</div><div class="line">                throw new IllegalStateException(&quot;Cannot execute task:&quot;</div><div class="line">                        + &quot; the task has already been executed &quot;</div><div class="line">                        + &quot;(a task can be executed only once)&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mStatus = Status.RUNNING;</div><div class="line"></div><div class="line">    onPreExecute();</div><div class="line"></div><div class="line">    mWorker.mParams = params;</div><div class="line">    exec.execute(mFuture);</div><div class="line"></div><div class="line">    return this;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>狀態判斷</li>
<li>設置mStatus爲RUNNING</li>
<li>onPreExecute()進行準備操作</li>
<li>將參數賦值給mWorker.mParams，mWorker是一个Callable的子類，並且在內部的call()方法中，調用了doInBackground(mParams)，然后得到的返回值作为postResult的参数进行执行；postResult中通过sHandler发送消息，最终sHandler的handleMessage中完成onPostExecute的调用。</li>
<li>exec.execute(mFuture)，mFuture为真正的执行任务的单元，将mWorker进行封装，然后由sDefaultExecutor交给线程池进行执行。</li>
</ul>
<h2 id="publishProgress"><a href="#publishProgress" class="headerlink" title="publishProgress"></a>publishProgress</h2><p>AsyncTask還有一個重要的方法：更新進度條的publishProgress方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">protected final void publishProgress(Progress... values) &#123;</div><div class="line">    if (!isCancelled()) &#123;</div><div class="line">        sHandler.obtainMessage(MESSAGE_POST_PROGRESS,</div><div class="line">                new AsyncTaskResult&lt;Progress&gt;(this, values)).sendToTarget();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>發送了一條message<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">private static class InternalHandler extends Handler &#123;</div><div class="line">    @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;&#125;)</div><div class="line">    @Override</div><div class="line">    public void handleMessage(Message msg) &#123;</div><div class="line">        AsyncTaskResult result = (AsyncTaskResult) msg.obj;</div><div class="line">        switch (msg.what) &#123;</div><div class="line">            case MESSAGE_POST_RESULT:</div><div class="line">                // There is only one result</div><div class="line">                result.mTask.finish(result.mData[0]);</div><div class="line">                break;</div><div class="line">            case MESSAGE_POST_PROGRESS:</div><div class="line">                result.mTask.onProgressUpdate(result.mData);</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>InternalHandler對其進行處理，調用<code>result.mTask.onProgressUpdate(result.mData);</code></p>
<h2 id="AsyncTask的缺陷"><a href="#AsyncTask的缺陷" class="headerlink" title="AsyncTask的缺陷"></a>AsyncTask的缺陷</h2><h3 id="3-0之前的崩潰"><a href="#3-0之前的崩潰" class="headerlink" title="3.0之前的崩潰"></a>3.0之前的崩潰</h3><p>Android 3.0之前（1.6之前的版本不再关注）规定线程池的核心线程数为5个（corePoolSize），线程池总大小为128（maximumPoolSize），还有一个缓冲队列（sWorkQueue，缓冲队列可以放10个任务），当我们尝试去添加第139个任务时，程序就会崩溃。</p>
<h3 id="內存泄漏"><a href="#內存泄漏" class="headerlink" title="內存泄漏"></a>內存泄漏</h3><p>如果AsyncTask被声明为Activity的非静态的内部类，那么AsyncTask会保留一个对创建了AsyncTask的Activity的引用。如果Activity已经被销毁，AsyncTask的后台线程还在执行，它将继续在内存里保留这个引用，导致Activity无法被回收，引起内存泄露。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">new AsyncTask&lt;String, Void, Void&gt;() &#123;</div><div class="line">	@override</div><div class="line">	protected Void doInBackground(String... params) &#123;</div><div class="line">		//do something</div><div class="line">		return null;</div><div class="line">	&#125;</div><div class="line">&#125;.execute(&quot;hello&quot;);</div></pre></td></tr></table></figure></p>
<p>上述代碼使用了匿名內部類創建AsyncTask實例，非靜態內部類會隱式持有外部類的實例引用，即上面的AsyncTask會隱式持有Activity的實例引用。</p>
<p>而在AsyncTask的源碼中，mFuture也使用了匿名內部類來創建對象，而mFuture會被放入到一個靜態成員變量SERIAL_EXECUTOR指向的對象SerialExecutor的一個ArrayDeque類型的集閤中。</p>
<p>當任務處於排隊狀態時，Activity實例引用被靜態常量SERIAL_EXECUTOR間接持有。</p>
<p>此時，如果Activity被銷燬（比如旋轉屏幕），因爲AsyncTask的引用，該Activity無法被回收，造成內存泄漏。</p>
<p>爲了避免內存泄漏，可以使用靜態內部類和弱引用的方式解決。</p>
<h3 id="cancel的問題"><a href="#cancel的問題" class="headerlink" title="cancel的問題"></a>cancel的問題</h3><p>AsyncTask是支持cancel()方法取消提交的，然而cancel並非真的能起作用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public final boolean cancel(boolean mayInterruptIfRunning) &#123;</div><div class="line">    mCancelled.set(true);</div><div class="line">    return mFuture.cancel(mayInterruptIfRunning);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>cancel方法有一個boolean型的參數mayInterruptIfRunning，表示是否可以打斷正在執行的任務。</p>
<ol>
<li>當調用cancel(false)，不打斷正在執行的任務</li>
</ol>
<ul>
<li>處於doInBackground的任務不受影響，繼續執行</li>
<li>任務結束後調用onCancelled方法，而非onPostExecute方法</li>
</ul>
<ol>
<li>當調用cancel(true),打斷正在執行的任務</li>
</ol>
<ul>
<li>如果doInBackground方法處於阻塞狀態（如調用Thread.sleep,wait方法等），則拋出InterruptedException</li>
<li>正在執行的任務並非都能打斷，有時會打斷失敗</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/10/31/oneday-AsyncTask/" data-id="cje6pjw1t003mweyxnn0syzwl" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android-everyday/">Android_everyday</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-pattern-singleton" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/26/pattern-singleton/" class="article-date">
  <time datetime="2016-10-25T23:57:24.000Z" itemprop="datePublished">2016-10-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/设计模式/">设计模式</a>►<a class="article-category-link" href="/categories/设计模式/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/26/pattern-singleton/">Android中的设计模式之单例模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h2><p>创建模式的一种，单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。这个类称为单例类。</p>
<p>由于单例模式在内存中只有一个实例，减少了内存开销。</p>
<p>单例模式可以避免对资源的多重占用，例如一个写文件时，由于只有一个实例存在内存中，避免对同一个资源文件的同时写操作。</p>
<p>单例模式可以在系统设置全局的访问点，优化和共享资源访问。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="1-饿汉式"><a href="#1-饿汉式" class="headerlink" title="1.饿汉式"></a>1.饿汉式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/*  </div><div class="line"> * 饿汉式，这种方式基于classloder机制避免了多线程的同步问题  </div><div class="line"> * 不过，instance在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调getInstance方法 </div><div class="line"> * 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化instance显然没有达到lazy loading的效果。 </div><div class="line"> */  </div><div class="line">public class Singleton &#123;  </div><div class="line">	private static Singleton instance=new Singleton();</div><div class="line">	private Singleton()&#123;&#125;   </div><div class="line">	public static Singleton getInstance() &#123;</div><div class="line">	   return instance;   </div><div class="line">	   	&#125;  </div><div class="line">	   &#125;</div></pre></td></tr></table></figure>
<h3 id="2-饿汉变形式"><a href="#2-饿汉变形式" class="headerlink" title="2.饿汉变形式"></a>2.饿汉变形式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/*   </div><div class="line"> * 饿汉变形式 </div><div class="line"> */  </div><div class="line">public class Singleton1 &#123;  </div><div class="line">	private  static Singleton1 instance = null;</div><div class="line">	static &#123;</div><div class="line">	   instance = new Singleton1();   		</div><div class="line">	&#125;    </div><div class="line">	private Singleton1() &#123;  &#125;    		</div><div class="line">	public static Singleton1 getInstance() &#123;   </div><div class="line">		return instance;  </div><div class="line">	&#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3懒汉式"><a href="#3懒汉式" class="headerlink" title="3懒汉式"></a>3懒汉式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/*   </div><div class="line"> * 懒汉式,线程不安全  </div><div class="line"> */  </div><div class="line">public class Singleton2 &#123;     </div><div class="line">	private static Singleton2 instance;      </div><div class="line">	private Singleton2()&#123;&#125; </div><div class="line">	</div><div class="line">	public static Singleton2 getInstance()&#123;   </div><div class="line">		if(instance==null)&#123;</div><div class="line">		    instance=new Singleton2();    </div><div class="line">		&#125;    </div><div class="line">		return instance;   </div><div class="line">	&#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-懒汉变形式"><a href="#4-懒汉变形式" class="headerlink" title="4.懒汉变形式"></a>4.懒汉变形式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/*  </div><div class="line"> * 懒汉式，线程安全，但是效率很低，99%情况下不需要同步  </div><div class="line"> */  </div><div class="line">public class Singleton3 &#123;  </div><div class="line">	private static Singleton3 instance;    </div><div class="line">	private Singleton3() &#123;  &#125;    </div><div class="line">	public static synchronized Singleton3 getInstance() &#123;</div><div class="line">	   if (instance == null) &#123;</div><div class="line">	       instance = new Singleton3();</div><div class="line">	   &#125;    </div><div class="line">	   return instance;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="5-静态内部类"><a href="#5-静态内部类" class="headerlink" title="5.静态内部类"></a>5.静态内部类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">/*  </div><div class="line"> * 静态内部类  </div><div class="line"> * 这种方式同样利用了classloder的机制来保证初始化instance时只有一个线程，  </div><div class="line"> * 它跟第三种和第四种方式不同的是（很细微的差别）：第三种和第四种方式是只要Singleton类被装载了，  </div><div class="line"> * 那么instance就会被实例化（没有达到lazy loading效果），  </div><div class="line"> * 而这种方式是Singleton类被装载了，instance不一定被初始化。因为SingletonHolder类没有被主动使用，</div><div class="line"> * 只有显示通过调用getInstance方法时，才会显示装载SingletonHolder类，从而实例化instance。  </div><div class="line"> * 想象一下，如果实例化instance很消耗资源，我想让他延迟加载，   </div><div class="line"> * 另外一方面，我不希望在Singleton类加载时就实例化，因为我不能确保Singleton类还可能在其他的地方被主动使用从而被加载，   </div><div class="line"> * 那么这个时候实例化instance显然是不合适的。这个时候，这种方式相比第三和第四种方式就显得很合理。  </div><div class="line"> */ </div><div class="line"></div><div class="line">public class Singleton4 &#123;  </div><div class="line">	private static class SingletonHolder&#123;</div><div class="line">	   private static Singleton4 INSTANCE=new Singleton4();</div><div class="line">       &#125;   </div><div class="line">       private Singleton4()&#123;      &#125;   </div><div class="line">       public static Singleton4 getInstance()&#123;</div><div class="line">          return SingletonHolder.INSTANCE;  </div><div class="line">       &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="6-枚举式"><a href="#6-枚举式" class="headerlink" title="6.枚举式"></a>6.枚举式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/*   </div><div class="line"> * 枚举式，这种方式是Effective Java作者</div><div class="line">Josh Bloch 提倡的方式 </div><div class="line"> * 它不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象  </div><div class="line"> */  </div><div class="line">public enum Singleton5 &#123;  </div><div class="line">	INSTANCE;   </div><div class="line">	public void wheverMethod()&#123;      &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="7-双重校检锁式"><a href="#7-双重校检锁式" class="headerlink" title="7.双重校检锁式"></a>7.双重校检锁式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">/*  </div><div class="line"> * 双重校检锁  </div><div class="line"> */  </div><div class="line">public class Singleton6 &#123;  </div><div class="line">	private volatile static Singleton6 singleton;  </div><div class="line">	private Singleton6()&#123;&#125;   </div><div class="line">	public static Singleton6 getInstance()&#123;   </div><div class="line">		if(singleton==null)&#123;    </div><div class="line">			synchronized(Singleton.class)&#123;     </div><div class="line">				if(singleton==null)&#123;      </div><div class="line">					singleton=new Singleton6();      </div><div class="line">				&#125;     </div><div class="line">			&#125;    </div><div class="line">		&#125;    </div><div class="line">		return singleton;   </div><div class="line">	&#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Android中的单例模式"><a href="#Android中的单例模式" class="headerlink" title="Android中的单例模式"></a>Android中的单例模式</h2><h3 id="InputMethodManager"><a href="#InputMethodManager" class="headerlink" title="InputMethodManager"></a>InputMethodManager</h3><p>frameworks/base/core/java/android/view/inputmethod/InputMethodManager.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public static  getInstance() &#123;</div><div class="line">    synchronized (InputMethodManager.class) &#123;</div><div class="line">        if (sInstance == null) &#123;</div><div class="line">            IBinder b = ServiceManager.getService(Context.INPUT_METHOD_SERVICE);</div><div class="line">            IInputMethodManager service = IInputMethodManager.Stub.asInterface(b);</div><div class="line">            sInstance = new InputMethodManager(service, Looper.getMainLooper());</div><div class="line">        &#125;</div><div class="line">        return sInstance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="TextServicesManager"><a href="#TextServicesManager" class="headerlink" title="TextServicesManager"></a>TextServicesManager</h3><p>frameworks/base/core/java/android/view/textservice/TextServicesManager.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public static TextServicesManager getInstance() &#123;</div><div class="line">    synchronized (TextServicesManager.class) &#123;</div><div class="line">        if (sInstance != null) &#123;</div><div class="line">            return sInstance;</div><div class="line">        &#125;</div><div class="line">        sInstance = new TextServicesManager();</div><div class="line">    &#125;</div><div class="line">    return sInstance;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="WindowManagerGlobal"><a href="#WindowManagerGlobal" class="headerlink" title="WindowManagerGlobal"></a>WindowManagerGlobal</h3><p>frameworks/base/core/java/android/view/WindowManagerGlobal.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public static WindowManagerGlobal getInstance() &#123;</div><div class="line">    synchronized (WindowManagerGlobal.class) &#123;</div><div class="line">        if (sDefaultWindowManager == null) &#123;</div><div class="line">            sDefaultWindowManager = new WindowManagerGlobal();</div><div class="line">        &#125;</div><div class="line">        return sDefaultWindowManager;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/10/26/pattern-singleton/" data-id="cje6pjw2m005hweyxf0py0bls" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-oneday-listview" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/10/oneday-listview/" class="article-date">
  <time datetime="2016-10-10T15:00:34.000Z" itemprop="datePublished">2016-10-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>►<a class="article-category-link" href="/categories/Android/Android-everyday/">Android_everyday</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/10/oneday-listview/">如何优化listView</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://www.jianshu.com/p/8fd5fa90ee6c" target="_blank" rel="external">如何优化ListView的性能？</a></p>
<h2 id="重用ConvertView和使用ViewHolder模式"><a href="#重用ConvertView和使用ViewHolder模式" class="headerlink" title="重用ConvertView和使用ViewHolder模式"></a>重用ConvertView和使用ViewHolder模式</h2><p>这两项是优化listview的重要方法，基本上已经是写自定义adapter的标配了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">static class ViewHolder &#123;</div><div class="line">	TextView text;</div><div class="line">	ImageView icon;</div><div class="line">&#125;</div><div class="line">public View getView(int position, View convertView, ViewGroup parent) </div><div class="line">&#123;</div><div class="line">	ViewHolder holder;</div><div class="line">	if (convertView == null) &#123;</div><div class="line">	convertView = mInflater.inflate(R.layout.list_item_icon_text,parent, false);</div><div class="line">	holder = new ViewHolder();</div><div class="line">	holder.text = (TextView)	convertView.findViewById(R.id.text);</div><div class="line">	holder.icon = (ImageView) convertView.findViewById(R.id.icon);</div><div class="line">	convertView.setTag(holder);</div><div class="line">&#125; else &#123;</div><div class="line">	holder = (ViewHolder) convertView.getTag();</div><div class="line">&#125;</div><div class="line"></div><div class="line">//set values to the viewHolder</div><div class="line">holder.text.setText(DATA[position]);</div><div class="line">holder.icon.setImageBitmap((position &amp; 1) == 1 ? mIcon1 : </div><div class="line">mIcon2);</div><div class="line">return convertView;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到优化ListView的性能很多时候都是在getView中完成的。</p>
<p>先说ViewHolder:ViewHolder的使用，降低了进行findViewById的次数，当convertView不为空的情况下，可以直接执行set value的操作。</p>
<p>然后说convertView：convertView是getView函数的第二个参数。也就是说，getView对convertView的复用，是依靠调用它的函数传入一个convertView实现的。那么是哪里调用了getView函数呢？</p>
<h2 id="ListView的复用机制"><a href="#ListView的复用机制" class="headerlink" title="ListView的复用机制"></a>ListView的复用机制</h2><p>ListView中有一个RecycleBin类复负回收不可见且可能被再次使用的ItemView，由ScrapView存储。</p>
<p>RecycleBin机制是ListView能够实现成百上千条数据都不会OOM最重要的一个原因。它是写在AbsListView中的一个内部类，所以所有继承自AbsListView的子类，也就是ListView和GridView，都可以使用这个机制。RecycleBin有几个重要的函数:</p>
<h3 id="fillActiveViews"><a href="#fillActiveViews" class="headerlink" title="fillActiveViews"></a>fillActiveViews</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">         * Fill ActiveViews with all of the children of the AbsListView.</div><div class="line">         *</div><div class="line">         * @param childCount The minimum number of views mActiveViews should hold</div><div class="line">         * @param firstActivePosition The position of the first view that will be stored in</div><div class="line">         *        mActiveViews</div><div class="line">         */</div><div class="line">        void fillActiveViews(int childCount, int firstActivePosition) &#123;</div><div class="line">            if (mActiveViews.length &lt; childCount) &#123;</div><div class="line">                mActiveViews = new View[childCount];</div><div class="line">            &#125;</div><div class="line">            mFirstActivePosition = firstActivePosition;</div><div class="line"></div><div class="line">            //noinspection MismatchedReadAndWriteOfArray</div><div class="line">            final View[] activeViews = mActiveViews;</div><div class="line">            for (int i = 0; i &lt; childCount; i++) &#123;</div><div class="line">                View child = getChildAt(i);</div><div class="line">                AbsListView.LayoutParams lp = (AbsListView.LayoutParams) child.getLayoutParams();</div><div class="line">                // Don&apos;t put header or footer views into the scrap heap</div><div class="line">                if (lp != null &amp;&amp; lp.viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) &#123;</div><div class="line">                    // Note:  We do place AdapterView.ITEM_VIEW_TYPE_IGNORE in active views.</div><div class="line">                    //        However, we will NOT place them into scrap views.</div><div class="line">                    activeViews[i] = child;</div><div class="line">                    // Remember the position so that setupChild() doesn&apos;t reset state.</div><div class="line">                    lp.scrappedFromPosition = firstActivePosition + i;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>这个方法接收两个参数，第一个参数表示要存储的view的数量，第二个参数表示ListView中第一个可见元素的position值。RecycleBin当中使用mActiveViews这个数组来存储View，调用这个方法后就会根据传入的参数来将ListView中的指定元素存储到mActiveViews数组当中。</p>
<h3 id="getActiveView"><a href="#getActiveView" class="headerlink" title="getActiveView"></a>getActiveView</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/**</div><div class="line"> * Get the view corresponding to the specified position. The view will be removed from</div><div class="line"> * mActiveViews if it is found.</div><div class="line"> *</div><div class="line"> * @param position The position to look up in mActiveViews</div><div class="line"> * @return The view if it is found, null otherwise</div><div class="line"> */</div><div class="line">View getActiveView(int position) &#123;</div><div class="line">    int index = position - mFirstActivePosition;</div><div class="line">    final View[] activeViews = mActiveViews;</div><div class="line">    if (index &gt;=0 &amp;&amp; index &lt; activeViews.length) &#123;</div><div class="line">        final View match = activeViews[index];</div><div class="line">        activeViews[index] = null;</div><div class="line">        return match;</div><div class="line">    &#125;</div><div class="line">    return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>getActiveView() 这个方法和fillActiveViews()是对应的，用于从mActiveViews数组当中获取数据。该方法接收一个position参数，表示元素在ListView当中的位置，方法内部会自动将position值转换成mActiveViews数组对应的下标值。需要注意的是，mActiveViews当中所存储的View，一旦被获取了之后就会从mActiveViews当中移除，下次获取同样位置的View将会返回null，也就是说mActiveViews不能被重复利用。</p>
<h3 id="addScrapView"><a href="#addScrapView" class="headerlink" title="addScrapView()"></a>addScrapView()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">         * Puts a view into the list of scrap views.</div><div class="line">         * &lt;p&gt;</div><div class="line">         * If the list data hasn&apos;t changed or the adapter has stable IDs, views</div><div class="line">         * with transient state will be preserved for later retrieval.</div><div class="line">         *</div><div class="line">         * @param scrap The view to add</div><div class="line">         * @param position The view&apos;s position within its parent</div><div class="line">         */</div><div class="line">        void addScrapView(View scrap, int position) &#123;</div><div class="line">            final AbsListView.LayoutParams lp = (AbsListView.LayoutParams) scrap.getLayoutParams();</div><div class="line">            if (lp == null) &#123;</div><div class="line">                // Can&apos;t recycle, but we don&apos;t know anything about the view.</div><div class="line">                // Ignore it completely.</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            lp.scrappedFromPosition = position;</div><div class="line"></div><div class="line">            // Remove but don&apos;t scrap header or footer views, or views that</div><div class="line">            // should otherwise not be recycled.</div><div class="line">            final int viewType = lp.viewType;</div><div class="line">            if (!shouldRecycleViewType(viewType)) &#123;</div><div class="line">                // Can&apos;t recycle. If it&apos;s not a header or footer, which have</div><div class="line">                // special handling and should be ignored, then skip the scrap</div><div class="line">                // heap and we&apos;ll fully detach the view later.</div><div class="line">                if (viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) &#123;</div><div class="line">                    getSkippedScrap().add(scrap);</div><div class="line">                &#125;</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            scrap.dispatchStartTemporaryDetach();</div><div class="line"></div><div class="line">            // The the accessibility state of the view may change while temporary</div><div class="line">            // detached and we do not allow detached views to fire accessibility</div><div class="line">            // events. So we are announcing that the subtree changed giving a chance</div><div class="line">            // to clients holding on to a view in this subtree to refresh it.</div><div class="line">            notifyViewAccessibilityStateChangedIfNeeded(</div><div class="line">                    AccessibilityEvent.CONTENT_CHANGE_TYPE_SUBTREE);</div><div class="line"></div><div class="line">            // Don&apos;t scrap views that have transient state.</div><div class="line">            final boolean scrapHasTransientState = scrap.hasTransientState();</div><div class="line">            if (scrapHasTransientState) &#123;</div><div class="line">                if (mAdapter != null &amp;&amp; mAdapterHasStableIds) &#123;</div><div class="line">                    // If the adapter has stable IDs, we can reuse the view for</div><div class="line">                    // the same data.</div><div class="line">                    if (mTransientStateViewsById == null) &#123;</div><div class="line">                        mTransientStateViewsById = new LongSparseArray&lt;&gt;();</div><div class="line">                    &#125;</div><div class="line">                    mTransientStateViewsById.put(lp.itemId, scrap);</div><div class="line">                &#125; else if (!mDataChanged) &#123;</div><div class="line">                    // If the data hasn&apos;t changed, we can reuse the views at</div><div class="line">                    // their old positions.</div><div class="line">                    if (mTransientStateViews == null) &#123;</div><div class="line">                        mTransientStateViews = new SparseArray&lt;&gt;();</div><div class="line">                    &#125;</div><div class="line">                    mTransientStateViews.put(position, scrap);</div><div class="line">                &#125; else &#123;</div><div class="line">                    // Otherwise, we&apos;ll have to remove the view and start over.</div><div class="line">                    getSkippedScrap().add(scrap);</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                if (mViewTypeCount == 1) &#123;</div><div class="line">                    mCurrentScrap.add(scrap);</div><div class="line">                &#125; else &#123;</div><div class="line">                    mScrapViews[viewType].add(scrap);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                if (mRecyclerListener != null) &#123;</div><div class="line">                    mRecyclerListener.onMovedToScrapHeap(scrap);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>用于将一个废弃的View进行缓存，该方法接收一个View参数，当有某个View确定要废弃掉的时候(比如滚动出了屏幕)，就应该调用这个方法来对View进行缓存，RecycleBin当中使用mScrapViews和mCurrentScrap这两个List来存储废弃View。</p>
<h3 id="getScrapView"><a href="#getScrapView" class="headerlink" title="getScrapView"></a>getScrapView</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @return A view from the ScrapViews collection. These are unordered.</div><div class="line"> */</div><div class="line">View getScrapView(int position) &#123;</div><div class="line">    final int whichScrap = mAdapter.getItemViewType(position);</div><div class="line">    if (whichScrap &lt; 0) &#123;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">    if (mViewTypeCount == 1) &#123;</div><div class="line">        return retrieveFromScrap(mCurrentScrap, position);</div><div class="line">    &#125; else if (whichScrap &lt; mScrapViews.length) &#123;</div><div class="line">        return retrieveFromScrap(mScrapViews[whichScrap], position);</div><div class="line">    &#125;</div><div class="line">    return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用于从废弃缓存中取出一个View，这些废弃缓存中的View是没有顺序可言的，因此getScrapView()方法中的算法也非常简单，就是直接从mCurrentScrap当中获取尾部的一个scrap view进行返回。</p>
<h2 id="ListView的绘制流程"><a href="#ListView的绘制流程" class="headerlink" title="ListView的绘制流程"></a>ListView的绘制流程</h2><p>上面讲到的getView和RecycleBin都只是提供了缓存数据，优化ListView的方法，如何调用这些方法来实现优化的目的呢？要看ListView的绘制过程中，对这些方法的使用了<br>ListView也是继承自View，所以，他的执行流程也会经过三步：onMeasure()用于测量View的大小，onLayout()用于确定View的布局，onDraw()用于将View绘制到界面上。在ListView当中，onMeasure()并没有什么特殊的地方，因为它终归是一个View，占用的空间最多并且通常也就是整个屏幕。onDraw()在ListView当中也没有什么意义，因为ListView本身并不负责绘制，而是由ListView当中的子元素来进行绘制的。那么ListView大部分的功能其实都是在onLayout()方法中进行。但其实，ListView的onLayout是在其父类AbsListView中实现的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Subclasses should NOT override this method but</div><div class="line"> *  &#123;@link #layoutChildren()&#125; instead.</div><div class="line"> */</div><div class="line">@Override</div><div class="line">protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;</div><div class="line">    super.onLayout(changed, l, t, r, b);</div><div class="line"></div><div class="line">    mInLayout = true;</div><div class="line"></div><div class="line">    final int childCount = getChildCount();</div><div class="line">    if (changed) &#123;</div><div class="line">        for (int i = 0; i &lt; childCount; i++) &#123;</div><div class="line">            getChildAt(i).forceLayout();</div><div class="line">        &#125;</div><div class="line">        mRecycler.markChildrenDirty();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    layoutChildren();</div><div class="line">    mInLayout = false;</div><div class="line"></div><div class="line">    mOverscrollMax = (b - t) / OVERSCROLL_LIMIT_DIVISOR;</div><div class="line"></div><div class="line">    // TODO: Move somewhere sane. This doesn&apos;t belong in onLayout().</div><div class="line">    if (mFastScroll != null) &#123;</div><div class="line">        mFastScroll.onItemCountChanged(getChildCount(), mItemCount);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数，前面主要判断了一下ListView的大小或者位置有没有发生变化，如果变化了，就强制重绘。然后就是核心的一行：layoutChildren();然而这个函数的实现，又在ListView中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div></pre></td><td class="code"><pre><div class="line">protected void layoutChildren() &#123;</div><div class="line">    final boolean blockLayoutRequests = mBlockLayoutRequests;</div><div class="line">    if (blockLayoutRequests) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mBlockLayoutRequests = true;</div><div class="line"></div><div class="line">    try &#123;</div><div class="line">        super.layoutChildren();</div><div class="line"></div><div class="line">        invalidate();</div><div class="line"></div><div class="line">        if (mAdapter == null) &#123;</div><div class="line">            resetList();</div><div class="line">            invokeOnItemScrollListener();</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        final int childrenTop = mListPadding.top;</div><div class="line">        final int childrenBottom = mBottom - mTop - mListPadding.bottom;</div><div class="line">        final int childCount = getChildCount();</div><div class="line"></div><div class="line">        int index = 0;</div><div class="line">        int delta = 0;</div><div class="line"></div><div class="line">        View sel;</div><div class="line">        View oldSel = null;</div><div class="line">        View oldFirst = null;</div><div class="line">        View newSel = null;</div><div class="line"></div><div class="line">        // Remember stuff we will need down below</div><div class="line">        switch (mLayoutMode) &#123;</div><div class="line">        case LAYOUT_SET_SELECTION:</div><div class="line">            index = mNextSelectedPosition - mFirstPosition;</div><div class="line">            if (index &gt;= 0 &amp;&amp; index &lt; childCount) &#123;</div><div class="line">                newSel = getChildAt(index);</div><div class="line">            &#125;</div><div class="line">            break;</div><div class="line">        case LAYOUT_FORCE_TOP:</div><div class="line">        case LAYOUT_FORCE_BOTTOM:</div><div class="line">        case LAYOUT_SPECIFIC:</div><div class="line">        case LAYOUT_SYNC:</div><div class="line">            break;</div><div class="line">        case LAYOUT_MOVE_SELECTION:</div><div class="line">        default:</div><div class="line">            // Remember the previously selected view</div><div class="line">            index = mSelectedPosition - mFirstPosition;</div><div class="line">            if (index &gt;= 0 &amp;&amp; index &lt; childCount) &#123;</div><div class="line">                oldSel = getChildAt(index);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // Remember the previous first child</div><div class="line">            oldFirst = getChildAt(0);</div><div class="line"></div><div class="line">            if (mNextSelectedPosition &gt;= 0) &#123;</div><div class="line">                delta = mNextSelectedPosition - mSelectedPosition;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // Caution: newSel might be null</div><div class="line">            newSel = getChildAt(index + delta);</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">        boolean dataChanged = mDataChanged;</div><div class="line">        if (dataChanged) &#123;</div><div class="line">            handleDataChanged();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // Handle the empty set by removing all views that are visible</div><div class="line">        // and calling it a day</div><div class="line">        if (mItemCount == 0) &#123;</div><div class="line">            resetList();</div><div class="line">            invokeOnItemScrollListener();</div><div class="line">            return;</div><div class="line">        &#125; else if (mItemCount != mAdapter.getCount()) &#123;</div><div class="line">            throw new IllegalStateException(&quot;The content of the adapter has changed but &quot;</div><div class="line">                    + &quot;ListView did not receive a notification. Make sure the content of &quot;</div><div class="line">                    + &quot;your adapter is not modified from a background thread, but only from &quot;</div><div class="line">                    + &quot;the UI thread. Make sure your adapter calls notifyDataSetChanged() &quot;</div><div class="line">                    + &quot;when its content changes. [in ListView(&quot; + getId() + &quot;, &quot; + getClass()</div><div class="line">                    + &quot;) with Adapter(&quot; + mAdapter.getClass() + &quot;)]&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        setSelectedPositionInt(mNextSelectedPosition);</div><div class="line"></div><div class="line">        AccessibilityNodeInfo accessibilityFocusLayoutRestoreNode = null;</div><div class="line">        View accessibilityFocusLayoutRestoreView = null;</div><div class="line">        int accessibilityFocusPosition = INVALID_POSITION;</div><div class="line"></div><div class="line">        // Remember which child, if any, had accessibility focus. This must</div><div class="line">        // occur before recycling any views, since that will clear</div><div class="line">        // accessibility focus.</div><div class="line">        final ViewRootImpl viewRootImpl = getViewRootImpl();</div><div class="line">        if (viewRootImpl != null) &#123;</div><div class="line">            final View focusHost = viewRootImpl.getAccessibilityFocusedHost();</div><div class="line">            if (focusHost != null) &#123;</div><div class="line">                final View focusChild = getAccessibilityFocusedChild(focusHost);</div><div class="line">                if (focusChild != null) &#123;</div><div class="line">                    if (!dataChanged || isDirectChildHeaderOrFooter(focusChild)</div><div class="line">                            || focusChild.hasTransientState() || mAdapterHasStableIds) &#123;</div><div class="line">                        // The views won&apos;t be changing, so try to maintain</div><div class="line">                        // focus on the current host and virtual view.</div><div class="line">                        accessibilityFocusLayoutRestoreView = focusHost;</div><div class="line">                        accessibilityFocusLayoutRestoreNode = viewRootImpl</div><div class="line">                                .getAccessibilityFocusedVirtualView();</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    // If all else fails, maintain focus at the same</div><div class="line">                    // position.</div><div class="line">                    accessibilityFocusPosition = getPositionForView(focusChild);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        View focusLayoutRestoreDirectChild = null;</div><div class="line">        View focusLayoutRestoreView = null;</div><div class="line"></div><div class="line">        // Take focus back to us temporarily to avoid the eventual call to</div><div class="line">        // clear focus when removing the focused child below from messing</div><div class="line">        // things up when ViewAncestor assigns focus back to someone else.</div><div class="line">        final View focusedChild = getFocusedChild();</div><div class="line">        if (focusedChild != null) &#123;</div><div class="line">            // TODO: in some cases focusedChild.getParent() == null</div><div class="line"></div><div class="line">            // We can remember the focused view to restore after re-layout</div><div class="line">            // if the data hasn&apos;t changed, or if the focused position is a</div><div class="line">            // header or footer.</div><div class="line">            if (!dataChanged || isDirectChildHeaderOrFooter(focusedChild)</div><div class="line">                    || focusedChild.hasTransientState() || mAdapterHasStableIds) &#123;</div><div class="line">                focusLayoutRestoreDirectChild = focusedChild;</div><div class="line">                // Remember the specific view that had focus.</div><div class="line">                focusLayoutRestoreView = findFocus();</div><div class="line">                if (focusLayoutRestoreView != null) &#123;</div><div class="line">                    // Tell it we are going to mess with it.</div><div class="line">                    focusLayoutRestoreView.onStartTemporaryDetach();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            requestFocus();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // Pull all children into the RecycleBin.</div><div class="line">        // These views will be reused if possible</div><div class="line">        final int firstPosition = mFirstPosition;</div><div class="line">        final RecycleBin recycleBin = mRecycler;</div><div class="line">        if (dataChanged) &#123;</div><div class="line">            for (int i = 0; i &lt; childCount; i++) &#123;</div><div class="line">                recycleBin.addScrapView(getChildAt(i), firstPosition+i);</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            recycleBin.fillActiveViews(childCount, firstPosition);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // Clear out old views</div><div class="line">        detachAllViewsFromParent();</div><div class="line">        recycleBin.removeSkippedScrap();</div><div class="line"></div><div class="line">        switch (mLayoutMode) &#123;</div><div class="line">        case LAYOUT_SET_SELECTION:</div><div class="line">            if (newSel != null) &#123;</div><div class="line">                sel = fillFromSelection(newSel.getTop(), childrenTop, childrenBottom);</div><div class="line">            &#125; else &#123;</div><div class="line">                sel = fillFromMiddle(childrenTop, childrenBottom);</div><div class="line">            &#125;</div><div class="line">            break;</div><div class="line">        case LAYOUT_SYNC:</div><div class="line">            sel = fillSpecific(mSyncPosition, mSpecificTop);</div><div class="line">            break;</div><div class="line">        case LAYOUT_FORCE_BOTTOM:</div><div class="line">            sel = fillUp(mItemCount - 1, childrenBottom);</div><div class="line">            adjustViewsUpOrDown();</div><div class="line">            break;</div><div class="line">        case LAYOUT_FORCE_TOP:</div><div class="line">            mFirstPosition = 0;</div><div class="line">            sel = fillFromTop(childrenTop);</div><div class="line">            adjustViewsUpOrDown();</div><div class="line">            break;</div><div class="line">        case LAYOUT_SPECIFIC:</div><div class="line">            sel = fillSpecific(reconcileSelectedPosition(), mSpecificTop);</div><div class="line">            break;</div><div class="line">        case LAYOUT_MOVE_SELECTION:</div><div class="line">            sel = moveSelection(oldSel, newSel, delta, childrenTop, childrenBottom);</div><div class="line">            break;</div><div class="line">        default:</div><div class="line">            if (childCount == 0) &#123;</div><div class="line">                if (!mStackFromBottom) &#123;</div><div class="line">                    final int position = lookForSelectablePosition(0, true);</div><div class="line">                    setSelectedPositionInt(position);</div><div class="line">                    sel = fillFromTop(childrenTop);</div><div class="line">                &#125; else &#123;</div><div class="line">                    final int position = lookForSelectablePosition(mItemCount - 1, false);</div><div class="line">                    setSelectedPositionInt(position);</div><div class="line">                    sel = fillUp(mItemCount - 1, childrenBottom);</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                if (mSelectedPosition &gt;= 0 &amp;&amp; mSelectedPosition &lt; mItemCount) &#123;</div><div class="line">                    sel = fillSpecific(mSelectedPosition,</div><div class="line">                            oldSel == null ? childrenTop : oldSel.getTop());</div><div class="line">                &#125; else if (mFirstPosition &lt; mItemCount) &#123;</div><div class="line">                    sel = fillSpecific(mFirstPosition,</div><div class="line">                            oldFirst == null ? childrenTop : oldFirst.getTop());</div><div class="line">                &#125; else &#123;</div><div class="line">                    sel = fillSpecific(0, childrenTop);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // Flush any cached views that did not get reused above</div><div class="line">        recycleBin.scrapActiveViews();</div><div class="line"></div><div class="line">        if (sel != null) &#123;</div><div class="line">            // The current selected item should get focus if items are</div><div class="line">            // focusable.</div><div class="line">            if (mItemsCanFocus &amp;&amp; hasFocus() &amp;&amp; !sel.hasFocus()) &#123;</div><div class="line">                final boolean focusWasTaken = (sel == focusLayoutRestoreDirectChild &amp;&amp;</div><div class="line">                        focusLayoutRestoreView != null &amp;&amp;</div><div class="line">                        focusLayoutRestoreView.requestFocus()) || sel.requestFocus();</div><div class="line">                if (!focusWasTaken) &#123;</div><div class="line">                    // Selected item didn&apos;t take focus, but we still want to</div><div class="line">                    // make sure something else outside of the selected view</div><div class="line">                    // has focus.</div><div class="line">                    final View focused = getFocusedChild();</div><div class="line">                    if (focused != null) &#123;</div><div class="line">                        focused.clearFocus();</div><div class="line">                    &#125;</div><div class="line">                    positionSelector(INVALID_POSITION, sel);</div><div class="line">                &#125; else &#123;</div><div class="line">                    sel.setSelected(false);</div><div class="line">                    mSelectorRect.setEmpty();</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                positionSelector(INVALID_POSITION, sel);</div><div class="line">            &#125;</div><div class="line">            mSelectedTop = sel.getTop();</div><div class="line">        &#125; else &#123;</div><div class="line">            final boolean inTouchMode = mTouchMode == TOUCH_MODE_TAP</div><div class="line">                    || mTouchMode == TOUCH_MODE_DONE_WAITING;</div><div class="line">            if (inTouchMode) &#123;</div><div class="line">                // If the user&apos;s finger is down, select the motion position.</div><div class="line">                final View child = getChildAt(mMotionPosition - mFirstPosition);</div><div class="line">                if (child != null) &#123;</div><div class="line">                    positionSelector(mMotionPosition, child);</div><div class="line">                &#125;</div><div class="line">            &#125; else if (mSelectorPosition != INVALID_POSITION) &#123;</div><div class="line">                // If we had previously positioned the selector somewhere,</div><div class="line">                // put it back there. It might not match up with the data,</div><div class="line">                // but it&apos;s transitioning out so it&apos;s not a big deal.</div><div class="line">                final View child = getChildAt(mSelectorPosition - mFirstPosition);</div><div class="line">                if (child != null) &#123;</div><div class="line">                    positionSelector(mSelectorPosition, child);</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                // Otherwise, clear selection.</div><div class="line">                mSelectedTop = 0;</div><div class="line">                mSelectorRect.setEmpty();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // Even if there is not selected position, we may need to</div><div class="line">            // restore focus (i.e. something focusable in touch mode).</div><div class="line">            if (hasFocus() &amp;&amp; focusLayoutRestoreView != null) &#123;</div><div class="line">                focusLayoutRestoreView.requestFocus();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // Attempt to restore accessibility focus, if necessary.</div><div class="line">        if (viewRootImpl != null) &#123;</div><div class="line">            final View newAccessibilityFocusedView = viewRootImpl.getAccessibilityFocusedHost();</div><div class="line">            if (newAccessibilityFocusedView == null) &#123;</div><div class="line">                if (accessibilityFocusLayoutRestoreView != null</div><div class="line">                        &amp;&amp; accessibilityFocusLayoutRestoreView.isAttachedToWindow()) &#123;</div><div class="line">                    final AccessibilityNodeProvider provider =</div><div class="line">                            accessibilityFocusLayoutRestoreView.getAccessibilityNodeProvider();</div><div class="line">                    if (accessibilityFocusLayoutRestoreNode != null &amp;&amp; provider != null) &#123;</div><div class="line">                        final int virtualViewId = AccessibilityNodeInfo.getVirtualDescendantId(</div><div class="line">                                accessibilityFocusLayoutRestoreNode.getSourceNodeId());</div><div class="line">                        provider.performAction(virtualViewId,</div><div class="line">                                AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS, null);</div><div class="line">                    &#125; else &#123;</div><div class="line">                        accessibilityFocusLayoutRestoreView.requestAccessibilityFocus();</div><div class="line">                    &#125;</div><div class="line">                &#125; else if (accessibilityFocusPosition != INVALID_POSITION) &#123;</div><div class="line">                    // Bound the position within the visible children.</div><div class="line">                    final int position = MathUtils.constrain(</div><div class="line">                            accessibilityFocusPosition - mFirstPosition, 0,</div><div class="line">                            getChildCount() - 1);</div><div class="line">                    final View restoreView = getChildAt(position);</div><div class="line">                    if (restoreView != null) &#123;</div><div class="line">                        restoreView.requestAccessibilityFocus();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // Tell focus view we are done mucking with it, if it is still in</div><div class="line">        // our view hierarchy.</div><div class="line">        if (focusLayoutRestoreView != null</div><div class="line">                &amp;&amp; focusLayoutRestoreView.getWindowToken() != null) &#123;</div><div class="line">            focusLayoutRestoreView.onFinishTemporaryDetach();</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        mLayoutMode = LAYOUT_NORMAL;</div><div class="line">        mDataChanged = false;</div><div class="line">        if (mPositionScrollAfterLayout != null) &#123;</div><div class="line">            post(mPositionScrollAfterLayout);</div><div class="line">            mPositionScrollAfterLayout = null;</div><div class="line">        &#125;</div><div class="line">        mNeedSync = false;</div><div class="line">        setNextSelectedPositionInt(mSelectedPosition);</div><div class="line"></div><div class="line">        updateScrollIndicators();</div><div class="line"></div><div class="line">        if (mItemCount &gt; 0) &#123;</div><div class="line">            checkSelectionChanged();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        invokeOnItemScrollListener();</div><div class="line">    &#125; finally &#123;</div><div class="line">        if (!blockLayoutRequests) &#123;</div><div class="line">            mBlockLayoutRequests = false;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>太长了，将第一次layout时用到的重要部分单独提取出来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">protected void layoutChildren() &#123;</div><div class="line">	...</div><div class="line">          final int childCount = getChildCount();</div><div class="line">	</div><div class="line"></div><div class="line">	...</div><div class="line">          boolean dataChanged = mDataChanged;</div><div class="line">	...</div><div class="line">          if (dataChanged) &#123;</div><div class="line">		...</div><div class="line">          &#125; else &#123;</div><div class="line">              recycleBin.fillActiveViews(childCount, firstPosition);</div><div class="line">          &#125;</div><div class="line"></div><div class="line">	...</div><div class="line">          switch (mLayoutMode) &#123;</div><div class="line">          case LAYOUT_SET_SELECTION:</div><div class="line">              ...</div><div class="line">          case LAYOUT_SYNC:</div><div class="line">              ...</div><div class="line">          case LAYOUT_FORCE_BOTTOM:</div><div class="line">              ...</div><div class="line">          case LAYOUT_FORCE_TOP:</div><div class="line">              ...</div><div class="line">          case LAYOUT_SPECIFIC:</div><div class="line">              ...</div><div class="line">          case LAYOUT_MOVE_SELECTION:</div><div class="line">              ...</div><div class="line">          default:</div><div class="line">              if (childCount == 0) &#123;</div><div class="line">                  if (!mStackFromBottom) &#123;</div><div class="line">                      ...</div><div class="line">                      sel = fillFromTop(childrenTop);</div><div class="line">                  &#125; else &#123;</div><div class="line">                      ...</div><div class="line">                  &#125;</div><div class="line">              &#125; else &#123;</div><div class="line">                  ...</div><div class="line">              &#125;</div><div class="line">              break;</div><div class="line">          &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>ListView当中目前还没有任何子View，数据都还是由Adapter管理的，并没有展示到界面上，因此getChildCount()方法得到的值肯定是0。接着会根据dataChanged这个布尔型的值来判断执行逻辑，dataChanged只有在数据源发生改变的情况下才会变成true，其它情况都是false，因此这里调用RecycleBin的fillActiveViews()方法。按理来说，调用fillActiveViews()方法是为了将ListView的子View进行缓存的，可是目前ListView中还没有任何的子View，因此这一行暂时还起不了任何作用。<br>接下来根据mLayoutMode的值来决定布局模式，默认情况下都是普通模式LAYOUT_NORMAL，因此会进入到default语句当中。而下面又会紧接着进行两次if判断，childCount目前是等于0的，并且默认的布局顺序是从上往下，因此会进入到fillFromTop()方法中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">private View fillFromTop(int nextTop) &#123;</div><div class="line">    mFirstPosition = Math.min(mFirstPosition, mSelectedPosition);</div><div class="line">    mFirstPosition = Math.min(mFirstPosition, mItemCount - 1);</div><div class="line">    if (mFirstPosition &lt; 0) &#123;</div><div class="line">        mFirstPosition = 0;</div><div class="line">    &#125;</div><div class="line">    return fillDown(mFirstPosition, nextTop);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>基本上，只是调用了fillDown<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">private View fillDown(int pos, int nextTop) &#123;</div><div class="line">    View selectedView = null;</div><div class="line"></div><div class="line">    int end = (mBottom - mTop);</div><div class="line">    if ((mGroupFlags &amp; CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) &#123;</div><div class="line">        end -= mListPadding.bottom;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    while (nextTop &lt; end &amp;&amp; pos &lt; mItemCount) &#123;</div><div class="line">        // is this the selected item?</div><div class="line">        boolean selected = pos == mSelectedPosition;</div><div class="line">        View child = makeAndAddView(pos, nextTop, true, mListPadding.left, selected);</div><div class="line"></div><div class="line">        nextTop = child.getBottom() + mDividerHeight;</div><div class="line">        if (selected) &#123;</div><div class="line">            selectedView = child;</div><div class="line">        &#125;</div><div class="line">        pos++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    setVisibleRangeHint(mFirstPosition, mFirstPosition + getChildCount() - 1);</div><div class="line">    return selectedView;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里使用了一个while循环来执行重复逻辑，一开始nextTop的值是第一个子元素顶部距离整个ListView顶部的像素值，pos则是刚刚传入的mFirstPosition的值，而end是ListView底部减去顶部所得的像素值，mItemCount则是Adapter中的元素数量。因此一开始的情况下nextTop必定是小于end值的，并且pos也是小于mItemCount值的。那么每执行一次while循环，pos的值都会加1，并且nextTop也会增加，当nextTop大于等于end时，也就是子元素已经超出当前屏幕了，或者pos大于等于mItemCount时，也就是所有Adapter中的元素都被遍历结束了，就会跳出while循环。<br>while循环中，主要调用了makeAndAddView()方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">private View makeAndAddView(int position, int y, boolean flow, int childrenLeft,</div><div class="line">        boolean selected) &#123;</div><div class="line">    View child;</div><div class="line"></div><div class="line"></div><div class="line">    if (!mDataChanged) &#123;</div><div class="line">        // Try to use an existing view for this position</div><div class="line">        child = mRecycler.getActiveView(position);</div><div class="line">        if (child != null) &#123;</div><div class="line">            // Found it -- we&apos;re using an existing child</div><div class="line">            // This just needs to be positioned</div><div class="line">            setupChild(child, position, y, flow, childrenLeft, selected, true);</div><div class="line"></div><div class="line">            return child;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Make a new view for this position, or convert an unused view if possible</div><div class="line">    child = obtainView(position, mIsScrap);</div><div class="line"></div><div class="line">    // This needs to be positioned and measured</div><div class="line">    setupChild(child, position, y, flow, childrenLeft, selected, mIsScrap[0]);</div><div class="line"></div><div class="line">    return child;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先尝试从RecycleBin当中快速获取一个active view，不过很遗憾的是目前RecycleBin当中还没有缓存任何的View，所以这里得到的值肯定是null。那么取得了null之后就会继续向下运行，会调用obtainView()方法来再次尝试获取一个View，这次的obtainView()方法是可以保证一定返回一个View的，于是下面立刻将获取到的View传入到了setupChild()方法当中。这个方法在AbsListView.java中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">  View obtainView(int position, boolean[] isScrap) &#123;</div><div class="line">...</div><div class="line">      final View scrapView = mRecycler.getScrapView(position);</div><div class="line">      final View child = mAdapter.getView(position, scrapView, this);</div><div class="line">      if (scrapView != null) &#123;</div><div class="line">          if (child != scrapView) &#123;</div><div class="line">              // Failed to re-bind the data, return scrap to the heap.</div><div class="line">              mRecycler.addScrapView(scrapView, position);</div><div class="line">          &#125; else &#123;</div><div class="line">              isScrap[0] = true;</div><div class="line"></div><div class="line">              // Finish the temporary detach started in addScrapView().</div><div class="line">              child.dispatchFinishTemporaryDetach();</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">...</div><div class="line"></div><div class="line">      return child;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>调用了RecycleBin的getScrapView()方法来尝试获取一个废弃缓存中的View，赋值给scrapView,同样的道理，这里肯定是获取不到的，getScrapView()方法会返回一个null。然后调用mAdapter的getView()方法来去获取一个View，赋值给child。如果scrapView不为空，且不等于child，就更新recyclerBin。在首次layout的时候， 必定是每行都需要去调用mAdapter的getView()方法来去获取View，也就是调用到了前面章节介绍到的getView方法。这个View会赋值给child并作为函数结果返回，并最终传入到setupChild()方法当中。其实也就是说，第一次layout过程当中，所有的子View都是调用LayoutInflater的inflate()方法加载出来的，这样就会相对比较耗时，但是不用担心，后面就不会再有这种情况了.接着看setupChild方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">private void setupChild(View child, int position, int y, boolean flowDown, int childrenLeft,</div><div class="line">        boolean selected, boolean recycled) &#123;</div><div class="line">    ...</div><div class="line">    if ((recycled &amp;&amp; !p.forceAdd) || (p.recycledHeaderFooter</div><div class="line">            &amp;&amp; p.viewType == AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER)) &#123;</div><div class="line">        ...</div><div class="line">    &#125; else &#123;</div><div class="line">        ...</div><div class="line">        addViewInLayout(child, flowDown ? -1 : 0, p, true);</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>刚才调用obtainView()方法获取到的子元素View，这里调用了addViewInLayout()方法将它添加到了ListView当中。那么根据fillDown()方法中的while循环，会让子元素View将整个ListView控件填满然后就跳出，也就是说即使我们的Adapter中有一千条数据，ListView也只会加载第一屏的数据，剩下的数据反正目前在屏幕上也看不到，所以不会去做多余的加载工作，这样就可以保证ListView中的内容能够迅速展示到屏幕上。<br>那么到此为止，第一次Layout过程结束。</p>
<h3 id="第二次layout"><a href="#第二次layout" class="headerlink" title="第二次layout"></a>第二次layout</h3><p>View，在展示到界面上之前都会经历至少两次onMeasure()和两次onLayout()的过程。</p>
<p>还是从layoutChildren()方法开始：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">protected void layoutChildren() &#123;</div><div class="line">        	...</div><div class="line">            final int childCount = getChildCount();</div><div class="line"></div><div class="line">            ...</div><div class="line">            if (dataChanged) &#123;</div><div class="line">                ...</div><div class="line">            &#125; else &#123;</div><div class="line">                recycleBin.fillActiveViews(childCount, firstPosition);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // Clear out old views</div><div class="line">            detachAllViewsFromParent();</div><div class="line">            recycleBin.removeSkippedScrap();</div><div class="line"></div><div class="line">            switch (mLayoutMode) &#123;</div><div class="line">            case LAYOUT_SET_SELECTION:</div><div class="line">                ...</div><div class="line">            case LAYOUT_SYNC:</div><div class="line">                ...</div><div class="line">            case LAYOUT_FORCE_BOTTOM:</div><div class="line">                ...</div><div class="line">            case LAYOUT_FORCE_TOP:</div><div class="line">                ...</div><div class="line">            case LAYOUT_SPECIFIC:</div><div class="line">                ...</div><div class="line">            case LAYOUT_MOVE_SELECTION:</div><div class="line">                ...</div><div class="line">            default:</div><div class="line">                if (childCount == 0) &#123;</div><div class="line">                    ...</div><div class="line">                &#125; else &#123;</div><div class="line">                    if (mSelectedPosition &gt;= 0 &amp;&amp; mSelectedPosition &lt; mItemCount) &#123;</div><div class="line">                        sel = fillSpecific(mSelectedPosition,</div><div class="line">                                oldSel == null ? childrenTop : oldSel.getTop());</div><div class="line">                    &#125; else if (mFirstPosition &lt; mItemCount) &#123;</div><div class="line">                        sel = fillSpecific(mFirstPosition,</div><div class="line">                                oldFirst == null ? childrenTop : oldFirst.getTop());</div><div class="line">                    &#125; else &#123;</div><div class="line">                        sel = fillSpecific(0, childrenTop);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            ...</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>同样还是调用getChildCount()方法来获取子View的数量，只不过现在得到的值不会再是0了，而是ListView中一屏可以显示的子View数量，因为我们刚刚在第一次Layout过程当中向ListView添加了这么多的子View。下面调用了RecycleBin的fillActiveViews()方法，这次效果可就不一样了，因为目前ListView中已经有子View了，这样所有的子View都会被缓存到RecycleBin的mActiveViews数组当中，后面将会用到它们。<br>接下来将会是非常非常重要的一个操作，调用了detachAllViewsFromParent()方法。这个方法会将所有ListView当中的子View全部清除掉，从而保证第二次Layout过程不会产生一份重复的数据。这样把已经加载好的View又清除掉，待会还要再重新加载一遍，这不是严重影响效率吗？不用担心，还记得我们刚刚调用了RecycleBin的fillActiveViews()方法来缓存子View吗，待会儿将会直接使用这些缓存好的View来进行加载，而并不会重新执行一遍inflate过程，因此效率方面并不会有什么明显的影响。<br>在接下来的判断逻辑当中，由于不再等于0了，因此会进入到else语句当中。而else语句中又有三个逻辑判断，第一个逻辑判断不成立，因为默认情况下我们没有选中任何子元素，mSelectedPosition应该等于-1。第二个逻辑判断通常是成立的，因为mFirstPosition的值一开始是等于0的，只要adapter中的数据大于0条件就成立。那么进入到fillSpecific()方法当中，代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">private View fillSpecific(int position, int top) &#123;</div><div class="line">    boolean tempIsSelected = position == mSelectedPosition;</div><div class="line">    View temp = makeAndAddView(position, top, true, mListPadding.left, tempIsSelected);</div><div class="line">    // Possibly changed again in fillUp if we add rows above this one.</div><div class="line">    mFirstPosition = position;</div><div class="line"></div><div class="line">    View above;</div><div class="line">    View below;</div><div class="line"></div><div class="line">    final int dividerHeight = mDividerHeight;</div><div class="line">    if (!mStackFromBottom) &#123;</div><div class="line">        above = fillUp(position - 1, temp.getTop() - dividerHeight);</div><div class="line">        // This will correct for the top of the first view not touching the top of the list</div><div class="line">        adjustViewsUpOrDown();</div><div class="line">        below = fillDown(position + 1, temp.getBottom() + dividerHeight);</div><div class="line">        int childCount = getChildCount();</div><div class="line">        if (childCount &gt; 0) &#123;</div><div class="line">            correctTooHigh(childCount);</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        below = fillDown(position + 1, temp.getBottom() + dividerHeight);</div><div class="line">        // This will correct for the bottom of the last view not touching the bottom of the list</div><div class="line">        adjustViewsUpOrDown();</div><div class="line">        above = fillUp(position - 1, temp.getTop() - dividerHeight);</div><div class="line">        int childCount = getChildCount();</div><div class="line">        if (childCount &gt; 0) &#123;</div><div class="line">             correctTooLow(childCount);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (tempIsSelected) &#123;</div><div class="line">        return temp;</div><div class="line">    &#125; else if (above != null) &#123;</div><div class="line">        return above;</div><div class="line">    &#125; else &#123;</div><div class="line">        return below;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>fillSpecific()这算是一个新方法了，不过其实它和fillUp()、fillDown()方法功能也是差不多的，主要的区别在于，fillSpecific()方法会优先将指定位置的子View先加载到屏幕上，然后再加载该子View往上以及往下的其它子View。那么由于这里我们传入的position就是第一个子View的位置，于是fillSpecific()方法的作用就基本上和fillDown()方法是差不多的了，核心函数依然是makeAndAddView</p>
<p><a href="http://m.blog.csdn.net/article/details?id=44996879" target="_blank" rel="external">详细分析</a></p>
<h2 id="滑动时不加载图片"><a href="#滑动时不加载图片" class="headerlink" title="滑动时不加载图片"></a>滑动时不加载图片</h2><p><a href="http://www.aichengxu.com/view/507689" target="_blank" rel="external">示例</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/10/10/oneday-listview/" data-id="cje6pjw2o005lweyxla864lxk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android-everyday/">Android_everyday</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-oneday-context" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/08/oneday-context/" class="article-date">
  <time datetime="2016-10-07T23:07:28.000Z" itemprop="datePublished">2016-10-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>►<a class="article-category-link" href="/categories/Android/Android-everyday/">Android_everyday</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/08/oneday-context/">Android中的context详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://www.jianshu.com/p/0754e65a5744" target="_blank" rel="external">如何理解Android中的Context，它有什么用？</a></p>
<h2 id="Context相关类的继承关系"><a href="#Context相关类的继承关系" class="headerlink" title="Context相关类的继承关系"></a>Context相关类的继承关系</h2><p>Activity类 、Service类 、Application类本质上都是Context子类<br><img src="/assets/img/android_context/context.png" alt="image"><br>(上图中的mPackageInfo是一个LoadApk对象,frameworks/base/core/java/android/app/LoadedApk.java)<br>context的直系子类有两个，一个是ContextWrapper，一个是ContextImpl。那么从名字上就可以看出，ContextWrapper是上下文功能的封装类，而ContextImpl则是上下文功能的实现类。而ContextWrapper又有三个直接的子类，ContextThemeWrapper、Service和Application。其中，ContextThemeWrapper是一个带主题的封装类，而它有一个直接子类就是Activity。</p>
<h2 id="相关类介绍"><a href="#相关类介绍" class="headerlink" title="相关类介绍"></a>相关类介绍</h2><h3 id="context类"><a href="#context类" class="headerlink" title="context类"></a>context类</h3><p>位置：/frameworks/base/core/java/android/context/Context.java</p>
<p>context是一个抽象类，提供一组通用的API<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public abstract class Context &#123;  </div><div class="line">     ...  </div><div class="line">     public abstract Object getSystemService(String name);  //获得系统级服务  </div><div class="line">     public abstract void startActivity(Intent intent);     //通过一个Intent启动Activity  </div><div class="line">     public abstract ComponentName startService(Intent service);  //启动Service  </div><div class="line">     //根据文件名得到SharedPreferences对象  </div><div class="line">     public abstract SharedPreferences getSharedPreferences(String name,int mode);  </div><div class="line">     ...  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="ContextImpl类"><a href="#ContextImpl类" class="headerlink" title="ContextImpl类"></a>ContextImpl类</h3><p>位置：frameworks/base/core/java/android/app/ContextImpl.java</p>
<p>该类实现了Context类的功能。请注意，该函数的大部分功能都是直接调用其属性mPackageInfo去完成，这点我们后面会讲到。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">/** </div><div class="line"> * Common implementation of Context API, which provides the base </div><div class="line"> * context object for Activity and other application components. </div><div class="line"> */  </div><div class="line">class ContextImpl extends Context&#123;  </div><div class="line">    //所有Application程序公用一个mPackageInfo对象  </div><div class="line">    /*package*/ ActivityThread.PackageInfo mPackageInfo;  </div><div class="line">      </div><div class="line">    @Override  </div><div class="line">    public Object getSystemService(String name)&#123;  </div><div class="line">        ...  </div><div class="line">        else if (ACTIVITY_SERVICE.equals(name)) &#123;  </div><div class="line">            return getActivityManager();  </div><div class="line">        &#125;   </div><div class="line">        else if (INPUT_METHOD_SERVICE.equals(name)) &#123;  </div><div class="line">            return InputMethodManager.getInstance(this);  </div><div class="line">        &#125;  </div><div class="line">    &#125;   </div><div class="line">    @Override  </div><div class="line">    public void startActivity(Intent intent) &#123;  </div><div class="line">        ...  </div><div class="line">        //开始启动一个Activity  </div><div class="line">        mMainThread.getInstrumentation().execStartActivity(  </div><div class="line">            getOuterContext(), mMainThread.getApplicationThread(), null, null, intent, -1);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="ContextWrapper类"><a href="#ContextWrapper类" class="headerlink" title="ContextWrapper类"></a>ContextWrapper类</h3><p>位置：frameworks/base/core/java/android/content/ContextWrapper.java<br>该类只是对Context类的一种包装，该类的构造函数包含了一个真正的Context引用，即ContextIml对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class ContextWrapper extends Context &#123;  </div><div class="line">    Context mBase;  //该属性指向一个ContextIml实例，一般在创建Application、Service、Activity时赋值  </div><div class="line">      </div><div class="line">    //创建Application、Service、Activity，会调用该方法给mBase属性赋值  </div><div class="line">    protected void attachBaseContext(Context base) &#123;  </div><div class="line">        if (mBase != null) &#123;  </div><div class="line">            throw new IllegalStateException(&quot;Base context already set&quot;);  </div><div class="line">        &#125;  </div><div class="line">        mBase = base;  </div><div class="line">    &#125;  </div><div class="line">    @Override  </div><div class="line">    public void startActivity(Intent intent) &#123;  </div><div class="line">        mBase.startActivity(intent);  //调用mBase实例方法  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="ContextThemeWrapper类"><a href="#ContextThemeWrapper类" class="headerlink" title="ContextThemeWrapper类"></a>ContextThemeWrapper类</h3><p>位置：frameworks/base/core/java/android/view/ContextThemeWrapper.java<br>该类内部包含了主题(Theme)相关的接口，即android:theme属性指定的。只有Activity需要主题，Service不需要主题，所以Service直接继承于ContextWrapper类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class ContextThemeWrapper extends ContextWrapper &#123;  </div><div class="line">     //该属性指向一个ContextIml实例，一般在创建Application、Service、Activity时赋值  </div><div class="line">       </div><div class="line">     private Context mBase;  </div><div class="line">    //mBase赋值方式同样有一下两种  </div><div class="line">     public ContextThemeWrapper(Context base, int themeres) &#123;  </div><div class="line">            super(base);  </div><div class="line">            mBase = base;  </div><div class="line">            mThemeResource = themeres;  </div><div class="line">     &#125;  </div><div class="line">  </div><div class="line">     @Override  </div><div class="line">     protected void attachBaseContext(Context newBase) &#123;  </div><div class="line">            super.attachBaseContext(newBase);  </div><div class="line">            mBase = newBase;  </div><div class="line">     &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="何时创建Context实例"><a href="#何时创建Context实例" class="headerlink" title="何时创建Context实例"></a>何时创建Context实例</h2><p>应用程序创建Context实例的情况有如下几种情况：</p>
<ol>
<li>创建Application 对象时， 而且整个App共一个Application对象</li>
<li>创建Service对象时</li>
<li>创建Activity对象时</li>
</ol>
<p>因此应用程序App共有的Context数目公式为：</p>
<p>总Context实例个数 = Service个数 + Activity个数 + 1（Application对应的Context实例）</p>
<h3 id="创建Application对象"><a href="#创建Application对象" class="headerlink" title="创建Application对象"></a>创建Application对象</h3><p>应用程序在第一次启动时，都会首先创建Application对象。这个创建过程在frameworks/base/core/java/android/app/ActivityThread.java的handleBindApplication()方法中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">private void handleBindApplication(AppBindData data) &#123;</div><div class="line">  ....</div><div class="line">  Application app = data.info.makeApplication(data.restrictedBackupMode, null);</div><div class="line">  ...     </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>函数调用了LoadedApk中的makeApplication方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public Application makeApplication(boolean forceDefaultAppClass, Instrumentation instrumentation) &#123;  </div><div class="line">    ...  </div><div class="line">    try &#123;</div><div class="line">        java.lang.ClassLoader cl = getClassLoader();</div><div class="line">        if (!mPackageName.equals(&quot;android&quot;)) &#123;</div><div class="line">                initializeJavaContextClassLoader();</div><div class="line">            &#125;</div><div class="line">        ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);//创建并初始化一个ContextIml实例 </div><div class="line">        app = mActivityThread.mInstrumentation.newApplication(</div><div class="line">                cl, appClass, appContext);</div><div class="line">        appContext.setOuterContext(app);//将该Application实例传递给该ContextImpl实例</div><div class="line">                 </div><div class="line">    &#125;   </div><div class="line">    ...  </div><div class="line">    return app;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="创建Activity对象"><a href="#创建Activity对象" class="headerlink" title="创建Activity对象"></a>创建Activity对象</h3><p>通过startActivity()或startActivityForResult()请求启动一个Activity时，如果系统检测需要新建一个Activity对象时，就会回调handleLaunchActivity()方法，该方法继而调用performLaunchActivity()方法，去创建一个Activity实例，并且回调onCreate()，onStart()方法等， 函数都位于 ActivityThread.java类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">private final void handleLaunchActivity(ActivityRecord r, Intent customIntent) &#123;  </div><div class="line">    ...  </div><div class="line">    Activity a = performLaunchActivity(r, customIntent);  //启动一个Activity  </div><div class="line">&#125; </div><div class="line"></div><div class="line">private final Activity performLaunchActivity(ActivityRecord r, Intent customIntent) &#123;  </div><div class="line">    ...  </div><div class="line">    Activity activity = null;  </div><div class="line">    try &#123;  </div><div class="line">        //创建一个Activity对象实例  </div><div class="line">        java.lang.ClassLoader cl = r.packageInfo.getClassLoader();  </div><div class="line">        activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);  </div><div class="line">    ...</div><div class="line">    &#125;  </div><div class="line">    if (activity != null) &#123;  </div><div class="line">    	Context appContext = createBaseContextForActivity(r, activity);</div><div class="line">    	...</div><div class="line">    	activity.attach(appContext, this, getInstrumentation(), r.token,</div><div class="line">    	r.ident, app, r.intent, r.activityInfo, title, r.parent,</div><div class="line">    	r.embeddedID, r.lastNonConfigurationInstances, config,</div><div class="line">    	r.referrer, r.voiceInteractor);</div><div class="line">        ...  </div><div class="line">    &#125;  </div><div class="line">    ...      </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="创建Service对象"><a href="#创建Service对象" class="headerlink" title="创建Service对象"></a>创建Service对象</h3><p> 通过startService或者bindService时，如果系统检测到需要新创建一个Service实例，就会回调handleCreateService()方法，<br> 完成相关数据操作。handleCreateService()函数位于 ActivityThread.java类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">private void handleCreateService(CreateServiceData data) &#123;</div><div class="line">    Service service = null;//创建一个Service实例 </div><div class="line">    try &#123;</div><div class="line">        java.lang.ClassLoader cl = packageInfo.getClassLoader();</div><div class="line">        service = (Service) cl.loadClass(data.info.name).newInstance();</div><div class="line">      catch (Exception e) &#123;</div><div class="line">      	...</div><div class="line">      &#125;</div><div class="line">      </div><div class="line">    try &#123;</div><div class="line">	 ...</div><div class="line">        ContextImpl context = ContextImpl.createAppContext(this, packageInfo);//创建并初始化一个ContextImpl对象实例 </div><div class="line">        context.setOuterContext(service);//将该Service信息传递给该ContextImpl实例</div><div class="line"></div><div class="line">        Application app = packageInfo.makeApplication(false, mInstrumentation);</div><div class="line">        service.attach(context, this, data.info.name, data.token, app,</div><div class="line">                ActivityManagerNative.getDefault());</div><div class="line">        service.onCreate();</div><div class="line">	...</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h2 id="Context的应用场景"><a href="#Context的应用场景" class="headerlink" title="Context的应用场景"></a>Context的应用场景</h2><p><img src="/assets/img/android_context/use_context.png" alt="image"></p>
<p>NO1：启动Activity在这些类中是可以的，但是需要创建一个新的task。一般情况不推荐。(在Application或者Service需要给Intent设置Intent.FLAG_ACTIVITY_NEW_TASK才能正常启动Activity，这就会引出Activity的Task栈问题)<br>NO2：在这些类中去layout inflate是合法的，但是会使用系统默认的主题样式，如果你自定义了某些样式可能不会被使用。<br>NO3：在receiver为null时允许，在4.2或以上的版本中，用于获取黏性广播的当前值。（可以无视）<br>注：ContentProvider、BroadcastReceiver之所以在上述表格中，是因为在其内部方法中都有一个context用于使用。</p>
<p>看Activity和Application，可以看到，和UI相关的方法基本都不建议或者不可使用Application，并且，前三个操作基本不可能在Application中出现。实际上，只要把握住一点，凡是跟UI相关的，都应该使用Activity做为Context来处理；其他的一些操作，Service,Activity,Application等实例都可以。</p>
<h2 id="getApplication-与getApplicationContext"><a href="#getApplication-与getApplicationContext" class="headerlink" title="getApplication()与getApplicationContext()"></a>getApplication()与getApplicationContext()</h2><p>Application本身就是一个Context，所以getApplication()和getApplicationContext()得到的结果都是MyApplication本身的实例。</p>
<p>但这两个方法在作用域上有比较大的区别。getApplication()方法的语义性非常强，一看就知道是用来获取Application实例的，但是这个方法只有在Activity和Service中才能调用的到。那么也许在绝大多数情况下我们都是在Activity或者Service中使用Application的，但是如果在一些其它的场景，比如BroadcastReceiver中也想获得Application的实例，这时就可以借助getApplicationContext()方法了</p>
<h2 id="使用Application的正确方法"><a href="#使用Application的正确方法" class="headerlink" title="使用Application的正确方法"></a>使用Application的正确方法</h2><p>Application全局只有一个，它本身就已经是单例了，无需再用单例模式去为它做多重实例保护了，代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class MyApplication extends Application &#123;</div><div class="line">	</div><div class="line">	private static MyApplication app;</div><div class="line">	</div><div class="line">	public static MyApplication getInstance() &#123;</div><div class="line">		return app;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void onCreate() &#123;</div><div class="line">		super.onCreate();</div><div class="line">		app = this;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>getInstance()方法可以照常提供，但是里面不要做任何逻辑判断，直接返回app对象就可以了，而app对象又是什么呢？在onCreate()方法中我们将app对象赋值成this，this就是当前Application的实例，那么app也就是当前Application的实例了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/10/08/oneday-context/" data-id="cje6pjw1v003qweyx4ysgyrun" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android-everyday/">Android_everyday</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-android-parcelable" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/27/android-parcelable/" class="article-date">
  <time datetime="2016-09-27T11:44:03.000Z" itemprop="datePublished">2016-09-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>►<a class="article-category-link" href="/categories/Android/Android-everyday/">Android_everyday</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/27/android-parcelable/">activity之间传递数据的方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://www.jianshu.com/p/be593134eeae" target="_blank" rel="external">两个Activity之间如何传递参数？</a></p>
<h2 id="基于消息的通信机制-intent"><a href="#基于消息的通信机制-intent" class="headerlink" title="基于消息的通信机制 intent"></a>基于消息的通信机制 intent</h2><p>使用bundle和extra来传递数据</p>
<ol>
<li>直接使用putExtra传递简单的数据</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//存</div><div class="line">Intent intent = new Intent(LoginActivity.this, MainActivity.class);</div><div class="line"></div><div class="line">intent.putExtra(&quot;flag&quot;, flag);</div><div class="line"></div><div class="line">startActivity(intent);</div><div class="line"></div><div class="line">//取</div><div class="line">String flag = &quot;   &quot;;</div><div class="line"></div><div class="line">Intent intent1 = this.getIntent(); </div><div class="line"></div><div class="line">flag = intent1.getStringExtra(&quot;flag&quot;);</div></pre></td></tr></table></figure>
<p>2.使用bundle传递简单的数据包<br>Bundle就是一个简单的数据包，它可以传递Serializable数据。</p>
<p>例如，我们创建一个Serializable的类Person<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class Person implements Serializable &#123;</div><div class="line"></div><div class="line">	private static final long serialVersionUID = 1L;</div><div class="line">	private String name;</div><div class="line">	private String passwd;</div><div class="line">	private String gender;</div><div class="line"></div><div class="line">	public Person(String name, String passwd, String gender) &#123;</div><div class="line">		this.name = name;</div><div class="line">		this.passwd = passwd;</div><div class="line">		this.gender = gender;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public String getName() &#123;</div><div class="line">		return name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public String getPasswd() &#123;</div><div class="line">		return passwd;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public String getGender() &#123;</div><div class="line">		return gender;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该类就可以使用bundle来传递<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Person person = new Person(name, passwd, gender);</div><div class="line">Bundle bundle = new Bundle();</div><div class="line">					bundle.putSerializable(&quot;person&quot;, person);</div><div class="line">Intent intent = new Intent(RegisterActivity.this,							ResultActivity.class);</div><div class="line">intent.putExtras(bundle);</div><div class="line">// 启动另一个Activity。					</div><div class="line">startActivity(intent);</div></pre></td></tr></table></figure></p>
<p>此外，Bundle对象包含了多个方法来存入、取出数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">putXxx(String key, Xxx data)：向Bundle放入Int、Long等各种类型的数据；</div><div class="line"></div><div class="line">putSerializable(String key, Serializable data)：向Bundle放入一个可序列化的对象；</div><div class="line"></div><div class="line">getXxx(String key)：从Bundle取出Int、Long等各种类型的数据；</div><div class="line"></div><div class="line">getSerializable(String key)：从Bundle取出一个可序列化的对象。</div></pre></td></tr></table></figure></p>
<h2 id="利用static静态数据，public-static成员变量"><a href="#利用static静态数据，public-static成员变量" class="headerlink" title="利用static静态数据，public static成员变量"></a>利用static静态数据，public static成员变量</h2><p>注意，static的变量不能太大，不然容易引起异常<br>ERROR/AndroidRuntime(4958): Caused by: java.lang.OutOfMemoryError: bitmap size exceeds VM budget</p>
<h2 id="基于外部存储的传输"><a href="#基于外部存储的传输" class="headerlink" title="基于外部存储的传输"></a>基于外部存储的传输</h2><p>比如File SharedPreference Sqlite，如果针对第三方应用，可以使用Content Provider</p>
<h2 id="基于全局变量，使用application的context"><a href="#基于全局变量，使用application的context" class="headerlink" title="基于全局变量，使用application的context"></a>基于全局变量，使用application的context</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">package net.blogjava.mobile1;</div><div class="line"></div><div class="line">import android.app.Application;</div><div class="line">import android.graphics.Bitmap;</div><div class="line"></div><div class="line">public class MyApp extends Application</div><div class="line">&#123;</div><div class="line">    private Bitmap mBitmap;</div><div class="line"></div><div class="line">    public Bitmap getBitmap()</div><div class="line">    &#123;</div><div class="line">        return mBitmap;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setBitmap(Bitmap bitmap)</div><div class="line">    &#123;</div><div class="line">        this.mBitmap = bitmap;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div><div class="line">&lt;application android:name=&quot;.MyApp&quot; android:icon=&quot;@drawable/icon&quot; android:label=&quot;@string/app_name&quot;&gt;</div><div class="line"></div><div class="line">&lt;/application&gt;</div><div class="line">获得Bitmap对象的代码：</div><div class="line">    ImageView imageview = (ImageView)findViewById(R.id.ivImageView);</div><div class="line">        </div><div class="line">    MyApp myApp = (MyApp)getApplication();</div><div class="line">        </div><div class="line">    imageview.setImageBitmap(myApp.getBitmap());</div></pre></td></tr></table></figure>
<h2 id="使用Parcelable"><a href="#使用Parcelable" class="headerlink" title="使用Parcelable"></a>使用Parcelable</h2><h3 id="对比Parcelable和Serializable"><a href="#对比Parcelable和Serializable" class="headerlink" title="对比Parcelable和Serializable"></a>对比Parcelable和Serializable</h3><ol>
<li><p>Serializalbe会使用反射，序列化和反序列化过程需要大量I/O操作，Parcelable自已实现封送和解封（marshalled &amp;unmarshalled）操作不需要用反射，数据也存放在Native内存中，效率要快很多。</p>
<p> Parcelable 接口定义在封送/解封送过程中混合和分解对象的契约。Parcelable接口的底层是Parcel容器对象。Parcel类是一种最快的序列化/反序列化机制，专为Android中的进程间通信而设计。该类提供了一些方法来将成员容纳到容器中，以及从容器展开成员。</p>
</li>
<li><p>在使用内存的时候，Parcelable比Serializable性能高，所以推荐使用Parcelable。</p>
</li>
<li><p>Serializable在序列化的时候会产生大量的临时变量，从而引起频繁的GC。</p>
</li>
<li><p>Parcelable不能使用在要将数据存储在磁盘上的情况，因为Parcelable不能很好的保证数据的持续性在外界有变化的情况下。尽管Serializable效率低点，但此时还是建议使用Serializable 。</p>
</li>
</ol>
<h3 id="Parcelable接口定义"><a href="#Parcelable接口定义" class="headerlink" title="Parcelable接口定义"></a>Parcelable接口定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public interface Parcelable &#123;</div><div class="line"></div><div class="line">    public int describeContents();</div><div class="line">    //写入接口函数，打包</div><div class="line">    public void writeToParcel(Parcel dest, int flags);</div><div class="line"></div><div class="line">    //读取接口，目的是要从Parcel中构造一个实现了Parcelable的类的实例处理。因为实现类在这里还是不可知的，所以需要用到模板的方式，继承类名通过模板参数传入</div><div class="line">    //为了能够实现模板参数的传入，这里定义Creator嵌入接口,内含两个接口函数分别返回单个和多个继承类实例</div><div class="line">    /**</div><div class="line">     * Interface that must be implemented and provided as a public CREATOR</div><div class="line">     * field that generates instances of your Parcelable class from a Parcel.</div><div class="line">     */</div><div class="line">    public interface Creator&lt;T&gt; &#123;</div><div class="line"></div><div class="line">        public T createFromParcel(Parcel source);</div><div class="line"></div><div class="line">        public T[] newArray(int size);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    public interface ClassLoaderCreator&lt;T&gt; extends Creator&lt;T&gt; &#123;</div><div class="line"></div><div class="line">        public T createFromParcel(Parcel source, ClassLoader loader);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="实现Parcelable步骤"><a href="#实现Parcelable步骤" class="headerlink" title="实现Parcelable步骤"></a>实现Parcelable步骤</h3><ol>
<li><p>implements Parcelable</p>
</li>
<li><p>重写writeToParcel方法，将你的对象序列化为一个Parcel对象，即：将类的数据写入外部提供的Parcel中，打包需要传递的数据到Parcel容器保存，以便从 Parcel容器获取数据</p>
</li>
<li><p>重写describeContents方法，内容接口描述，默认返回0就可以</p>
</li>
<li><p>实例化静态内部对象CREATOR实现接口Parcelable.Creator</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public static final Parcelable.Creator&lt;T&gt; CREATOR</div></pre></td></tr></table></figure>
</li>
</ol>
<p>注：其中public static final一个都不能少，内部对象CREATOR的名称也不能改变，必须全部大写。需重写本接口中的两个方法：createFromParcel(Parcel in) 实现从Parcel容器中读取传递数据值，封装成Parcelable对象返回逻辑层，newArray(int size) 创建一个类型为T，长度为size的数组，仅一句话即可（return new T[size]），供外部类反序列化本类数组使用。</p>
<h3 id="Parcelable示例"><a href="#Parcelable示例" class="headerlink" title="Parcelable示例"></a>Parcelable示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">public class MyParcelable implements Parcelable </div><div class="line">&#123;</div><div class="line">     private int mData;</div><div class="line"></div><div class="line">     public int describeContents() </div><div class="line">     &#123;</div><div class="line">         return 0;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     public void writeToParcel(Parcel out, int flags) </div><div class="line">     &#123;</div><div class="line">         out.writeInt(mData);</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     public static final Parcelable.Creator&lt;MyParcelable&gt; CREATOR = new Parcelable.Creator&lt;MyParcelable&gt;() </div><div class="line">     &#123;</div><div class="line">         public MyParcelable createFromParcel(Parcel in) </div><div class="line">         &#123;</div><div class="line">             return new MyParcelable(in);</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         public MyParcelable[] newArray(int size) </div><div class="line">         &#123;</div><div class="line">             return new MyParcelable[size];</div><div class="line">         &#125;</div><div class="line">     &#125;;</div><div class="line">     </div><div class="line">     private MyParcelable(Parcel in) </div><div class="line">     &#123;</div><div class="line">         mData = in.readInt();</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h3 id="Serializable实现与Parcelabel实现的区别"><a href="#Serializable实现与Parcelabel实现的区别" class="headerlink" title="Serializable实现与Parcelabel实现的区别"></a>Serializable实现与Parcelabel实现的区别</h3><ol>
<li><p>Serializable的实现，只需要implements  Serializable 即可。这只是给对象打了一个标记，系统会自动将其序列化。</p>
</li>
<li><p>Parcelabel的实现，不仅需要implements  Parcelabel，还需要在类中添加一个静态成员变量CREATOR，这个变量需要实现 Parcelable.Creator 接口。</p>
</li>
</ol>
<h3 id="代码比较"><a href="#代码比较" class="headerlink" title="代码比较"></a>代码比较</h3><h4 id="创建Person类，实现Serializable"><a href="#创建Person类，实现Serializable" class="headerlink" title="创建Person类，实现Serializable"></a>创建Person类，实现Serializable</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class Person implements Serializable</div><div class="line">&#123;</div><div class="line">    private static final long serialVersionUID = -7060210544600464481L;</div><div class="line">    private String name;</div><div class="line">    private int age;</div><div class="line">    </div><div class="line">    public String getName()</div><div class="line">    &#123;</div><div class="line">        return name;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void setName(String name)</div><div class="line">    &#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public int getAge()</div><div class="line">    &#123;</div><div class="line">        return age;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void setAge(int age)</div><div class="line">    &#123;</div><div class="line">        this.age = age;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="创建Book类，实现Parcelable"><a href="#创建Book类，实现Parcelable" class="headerlink" title="创建Book类，实现Parcelable"></a>创建Book类，实现Parcelable</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line">public class Book implements Parcelable</div><div class="line">&#123;</div><div class="line">    private String bookName;</div><div class="line">    private String author;</div><div class="line">    private int publishDate;</div><div class="line">    </div><div class="line">    public Book()</div><div class="line">    &#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public String getBookName()</div><div class="line">    &#123;</div><div class="line">        return bookName;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void setBookName(String bookName)</div><div class="line">    &#123;</div><div class="line">        this.bookName = bookName;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public String getAuthor()</div><div class="line">    &#123;</div><div class="line">        return author;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void setAuthor(String author)</div><div class="line">    &#123;</div><div class="line">        this.author = author;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public int getPublishDate()</div><div class="line">    &#123;</div><div class="line">        return publishDate;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void setPublishDate(int publishDate)</div><div class="line">    &#123;</div><div class="line">        this.publishDate = publishDate;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @Override</div><div class="line">    public int describeContents()</div><div class="line">    &#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @Override</div><div class="line">    public void writeToParcel(Parcel out, int flags)</div><div class="line">    &#123;</div><div class="line">        out.writeString(bookName);</div><div class="line">        out.writeString(author);</div><div class="line">        out.writeInt(publishDate);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public static final Parcelable.Creator&lt;Book&gt; CREATOR = new Creator&lt;Book&gt;()</div><div class="line">    &#123;</div><div class="line">        @Override</div><div class="line">        public Book[] newArray(int size)</div><div class="line">        &#123;</div><div class="line">            return new Book[size];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        @Override</div><div class="line">        public Book createFromParcel(Parcel in)</div><div class="line">        &#123;</div><div class="line">            return new Book(in);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    public Book(Parcel in)</div><div class="line">    &#123;</div><div class="line">        bookName = in.readString();</div><div class="line">        author = in.readString();</div><div class="line">        publishDate = in.readInt();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/27/android-parcelable/" data-id="cje6pjw0w0018weyxyqg9fgi8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android-everyday/">Android_everyday</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-oneday-handler" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/26/oneday-handler/" class="article-date">
  <time datetime="2016-09-26T13:13:00.000Z" itemprop="datePublished">2016-09-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>►<a class="article-category-link" href="/categories/Android/Android-everyday/">Android_everyday</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/26/oneday-handler/">android的Handler机制详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://www.jianshu.com/p/108db0240a34" target="_blank" rel="external">能讲讲Android的Handler机制吗？</a></p>
<h2 id="用来解决什么问题"><a href="#用来解决什么问题" class="headerlink" title="用来解决什么问题"></a>用来解决什么问题</h2><p>我们知道在android的主线程（UI线程）中，是不适合作耗时操作的。而界面的刷新，又必须在UI线程当中。也就是说，当我们需要做一个耗时的操作，并且在操作完成后更新界面时，一种比较常规的解决方法是使用Handler和Message。</p>
<p>开启一个子线程，将耗时的操作放在子线程中进行，并使用Message和主线程中的Handler进行通信。当子线程完成耗时操作后，使用sendMessage函数，向主线程发送message，这些message会放入主线程的message队列中，并由主线中的handlerMessage函数进行处理。</p>
<h2 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">public class MyHandlerActivity extends Activity &#123; </div><div class="line">    Button button; </div><div class="line">    MyHandler myHandler; </div><div class="line">    </div><div class="line">    int UPDATE_UI = 100;</div><div class="line">    </div><div class="line">    private Handler myThreadHandler = new Handler() &#123;</div><div class="line">        public void handleMessage(Message msg) &#123;</div><div class="line">        switch(msg.what) &#123;</div><div class="line">        	case UPDATE_UI</div><div class="line">		//更新UI</div><div class="line">		//。。。</div><div class="line">		//。。。</div><div class="line">		break;</div><div class="line">	default:</div><div class="line">		break;</div><div class="line">	&#125;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">    &#125;;</div><div class="line"> </div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123; </div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.handlertest); </div><div class="line"></div><div class="line">        MyThread m = new MyThread(); </div><div class="line">        new Thread(m).start(); </div><div class="line">    &#125;  </div><div class="line"> </div><div class="line">    class MyThread implements Runnable &#123; </div><div class="line">        public void run() &#123; </div><div class="line"> </div><div class="line">            try &#123; </div><div class="line">                Thread.sleep(10000); </div><div class="line">            &#125; catch (InterruptedException e) &#123; </div><div class="line">                // TODO Auto-generated catch block </div><div class="line">                e.printStackTrace(); </div><div class="line">            &#125; </div><div class="line"> </div><div class="line">            Log.d(&quot;thread.......&quot;， &quot;mThread........&quot;); </div><div class="line">            Message msg =  myThreadHandler.obtainMessage(UPDATE_UI);</div><div class="line">            myThreadHandler.sendMessage(msg); // 向Handler发送消息，更新UI </div><div class="line"> </div><div class="line">        &#125; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，UI线程在onCreate中初始化了MyThread，并start了MyThread。我们也可以调用其他类中的函数来实现耗时操作，只需将myThreadHandler传递过去就可以。</p>
<p>MyThread中休眠1秒来模拟耗时操作。之后使用Handler的sendMessage方法向UI线程发送消息，通知UI线程更新界面。这个消息是由myThreadHandler进行处理的。myThreadHandler是一个Handler类，并实现了handlerMessage方法。</p>
<h2 id="四個類-Looper-MessageQueue-Handler-Message"><a href="#四個類-Looper-MessageQueue-Handler-Message" class="headerlink" title="四個類 Looper MessageQueue Handler Message"></a>四個類 Looper MessageQueue Handler Message</h2><p>在主线程中，使用handler很简单，new一个Handler对象实现其handleMessage方法，在handleMessage中<br>提供收到消息后相应的处理方法即可。</p>
<p>那么，当子线程调用sendMessage(msg);发送一个message对象时，Handler是如何接收该message对象并处理的呢？这个过程主要涉及到四个类：</p>
<p>（未特別指出的源码，位置都在/frameworks/base/cre/java/android/os/目录下）</p>
<ol>
<li>Message：消息分为硬件产生的消息(如按钮、触摸)和软件生成的消息；</li>
<li>MessageQueue：消息队列的主要功能向消息池投递消息(MessageQueue.enqueueMessage)和取走消息池的消息(MessageQueue.next)；</li>
<li>Handler：消息辅助类，主要功能向消息池发送各种消息事件(Handler.sendMessage)和处理相应消息事件(Handler.handleMessage)；</li>
<li>Looper：不断循环执行(Looper.loop)，按分发机制将消息分发给目标处理者。</li>
</ol>
<h3 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h3><p>Looper是一个循环器，他不断循环执行Looper.loop来查看当前是否有消息，如果有，将消息分发出去。</p>
<p><strong>一个线程里面，只能有一个Looper，</strong>他负责管理此线程中的MessageQueue.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">private Looper(boolean quitAllowed) &#123;</div><div class="line">        mQueue = new MessageQueue(quitAllowed);</div><div class="line">        mThread = Thread.currentThread();</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>Looper的主要函数有两个：prepare和loop<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();</div><div class="line"></div><div class="line">final MessageQueue mQueue;</div><div class="line">final Thread mThread;</div><div class="line">    </div><div class="line">private static void prepare(boolean quitAllowed) &#123;</div><div class="line">    if (sThreadLocal.get() != null) &#123;</div><div class="line">        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</div><div class="line">    &#125;</div><div class="line">    sThreadLocal.set(new Looper(quitAllowed));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可见prepare的核心，就是sThreadLocal.set(new Looper(quitAllowed));并且可以看出，prepare只能执行一次，sThreadLocal.set也只能set一次，否则就会报错。<br>sThreadLocal.get()方法和set方法的源码已经深入到SDK当中，在/java/lang/ThreadLocal.java中，可以大致看一下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">   public T get() &#123;</div><div class="line">       // Optimized for the fast path.</div><div class="line">       Thread currentThread = Thread.currentThread();</div><div class="line">       Values values = values(currentThread);</div><div class="line">       if (values != null) &#123;</div><div class="line">           Object[] table = values.table;</div><div class="line">           int index = hash &amp; values.mask;</div><div class="line">           if (this.reference == table[index]) &#123;</div><div class="line">               return (T) table[index + 1];</div><div class="line">           &#125;</div><div class="line">       &#125; else &#123;</div><div class="line">           values = initializeValues(currentThread);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       return (T) values.getAfterMiss(this);</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">public void set(T value) &#123;</div><div class="line">       Thread currentThread = Thread.currentThread();</div><div class="line">       Values values = values(currentThread);</div><div class="line">       if (values == null) &#123;</div><div class="line">           values = initializeValues(currentThread);</div><div class="line">       &#125;</div><div class="line">       values.put(this, value);</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>这个方法其实是返回了当前线程存储的Looper实例。<br>（<a href="http://blog.csdn.net/qjyong/article/details/2158097" target="_blank" rel="external">关于ThreadLocal</a>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">public static void loop() &#123;</div><div class="line">        final Looper me = myLooper();</div><div class="line">        if (me == null) &#123;</div><div class="line">            throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);</div><div class="line">        &#125;</div><div class="line">        final MessageQueue queue = me.mQueue;</div><div class="line"></div><div class="line">        // Make sure the identity of this thread is that of the local process,</div><div class="line">        // and keep track of what that identity token actually is.</div><div class="line">        Binder.clearCallingIdentity();</div><div class="line">        final long ident = Binder.clearCallingIdentity();</div><div class="line"></div><div class="line">        for (;;) &#123;</div><div class="line">            Message msg = queue.next(); // might block</div><div class="line">            if (msg == null) &#123;</div><div class="line">                // No message indicates that the message queue is quitting.</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // This must be in a local variable, in case a UI event sets the logger</div><div class="line">            Printer logging = me.mLogging;</div><div class="line">            if (logging != null) &#123;</div><div class="line">                logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +</div><div class="line">                        msg.callback + &quot;: &quot; + msg.what);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            msg.target.dispatchMessage(msg);</div><div class="line"></div><div class="line">            if (logging != null) &#123;</div><div class="line">                logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // Make sure that during the course of dispatching the</div><div class="line">            // identity of the thread wasn&apos;t corrupted.</div><div class="line">            final long newIdent = Binder.clearCallingIdentity();</div><div class="line">            if (ident != newIdent) &#123;</div><div class="line">                Log.wtf(TAG, &quot;Thread identity changed from 0x&quot;</div><div class="line">                        + Long.toHexString(ident) + &quot; to 0x&quot;</div><div class="line">                        + Long.toHexString(newIdent) + &quot; while dispatching to &quot;</div><div class="line">                        + msg.target.getClass().getName() + &quot; &quot;</div><div class="line">                        + msg.callback + &quot; what=&quot; + msg.what);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            msg.recycleUnchecked();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>而loop则不断的调用queue.next来取出MessageQueue中的消息来处理。</p>
<h3 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h3><p>Handler负责往MessageQueue中添加消息（sendMessage）和处理消息（handleMessage）。这两个过程，是异步的。handler创建时会关联一个looper，默认的构造方法将关联当前线程的looper。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public Handler(Callback callback, boolean async) &#123;</div><div class="line">    .........</div><div class="line">    .........</div><div class="line"></div><div class="line">    mLooper = Looper.myLooper();</div><div class="line">    if (mLooper == null) &#123;</div><div class="line">        throw new RuntimeException(</div><div class="line">            &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;);</div><div class="line">    &#125;</div><div class="line">    mQueue = mLooper.mQueue;</div><div class="line">    mCallback = callback;</div><div class="line">    mAsynchronous = async;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>一个线程可以有多个Handler，但是只能有一个Looper！</strong></p>
<h4 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h4><p>在Handler的源码文件中，可以发现，无论使用哪一种发送消息的方式，最终都会调用到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123;</div><div class="line">        msg.target = this;</div><div class="line">        if (mAsynchronous) &#123;</div><div class="line">            msg.setAsynchronous(true);</div><div class="line">        &#125;</div><div class="line">        return queue.enqueueMessage(msg, uptimeMillis);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>再看MessageQueue的源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">boolean enqueueMessage(Message msg, long when) &#123;</div><div class="line">        if (msg.target == null) &#123;</div><div class="line">            throw new IllegalArgumentException(&quot;Message must have a target.&quot;);</div><div class="line">        &#125;</div><div class="line">        if (msg.isInUse()) &#123;</div><div class="line">            throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        synchronized (this) &#123;</div><div class="line">            if (mQuitting) &#123;</div><div class="line">                IllegalStateException e = new IllegalStateException(</div><div class="line">                        msg.target + &quot; sending message to a Handler on a dead thread&quot;);</div><div class="line">                Log.w(TAG, e.getMessage(), e);</div><div class="line">                msg.recycle();</div><div class="line">                return false;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            msg.markInUse();</div><div class="line">            msg.when = when;</div><div class="line">            Message p = mMessages;</div><div class="line">            boolean needWake;</div><div class="line">            if (p == null || when == 0 || when &lt; p.when) &#123;</div><div class="line">                // New head, wake up the event queue if blocked.</div><div class="line">                msg.next = p;</div><div class="line">                mMessages = msg;</div><div class="line">                needWake = mBlocked;</div><div class="line">            &#125; else &#123;</div><div class="line">                // Inserted within the middle of the queue.  Usually we don&apos;t have to wake</div><div class="line">                // up the event queue unless there is a barrier at the head of the queue</div><div class="line">                // and the message is the earliest asynchronous message in the queue.</div><div class="line">                needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();</div><div class="line">                Message prev;</div><div class="line">                for (;;) &#123;</div><div class="line">                    prev = p;</div><div class="line">                    p = p.next;</div><div class="line">                    if (p == null || when &lt; p.when) &#123;</div><div class="line">                        break;</div><div class="line">                    &#125;</div><div class="line">                    if (needWake &amp;&amp; p.isAsynchronous()) &#123;</div><div class="line">                        needWake = false;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                msg.next = p; // invariant: p == prev.next</div><div class="line">                prev.next = msg;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // We can assume mPtr != 0 because mQuitting is false.</div><div class="line">            if (needWake) &#123;</div><div class="line">                nativeWake(mPtr);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return true;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>这个函数的核心功能，是将该消息插入到MessageQueue中。</p>
<h4 id="处理消息"><a href="#处理消息" class="headerlink" title="处理消息"></a>处理消息</h4><p>处理消息的函数是dispatchMessage，首选handlerCallback(msg),当msg.callback为空时，使用handleMessage(msg)处理。也就是说，子类只需要实现handleMessage(msg)方法，就可以实现处理消息的功能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public void dispatchMessage(Message msg) &#123;</div><div class="line">        if (msg.callback != null) &#123;</div><div class="line">            handleCallback(msg);</div><div class="line">        &#125; else &#123;</div><div class="line">            if (mCallback != null) &#123;</div><div class="line">                if (mCallback.handleMessage(msg)) &#123;</div><div class="line">                    return;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            handleMessage(msg);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">private static void handleCallback(Message message) &#123;</div><div class="line">        message.callback.run();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">//由子类实现</div><div class="line">public void handleMessage(Message msg) &#123;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="Handler的特点"><a href="#Handler的特点" class="headerlink" title="Handler的特点"></a>Handler的特点</h3><ol>
<li><p>handler可以在任意线程中发送消息，这些消息会被放入该handler关联的looper的messageQueue当中。而每个线程只有一个looper和一个messageQueue，也就是说，当一个线程有多个handler时，所有handler发出的message都会被放到同一个messageQueue中，等着同一个looper来分发处理它们。</p>
</li>
<li><p>handler是在与其关联的looper中进行消息处理的。<br>Looper.loop不断取出messageQueue中的消息，并分发给对应的handler进行处理。</p>
</li>
</ol>
<p>这就达到了子线程进行耗时操作，主线程（UI线程）进行界面更新的需求。</p>
<p>总结一下：</p>
<ol>
<li>每一个线程都只有一个Looper，维护一个MessageQueue。Looper通过prepare()和loop()初始化并保证自己具有收到和分发message的功能，维护MessageQueue。</li>
<li>Handler会关联到一个Looper，默认关联当前线程的Looper。也可以说，通常Handler和Looper在同一个线程中，比如UI线程。Handler需要实现处理消息的方法，通常是handleMessage()</li>
<li>handler可以在任何线程中发送message给Looper，比如，UI线程可以将handler实例作为参数给子线程，并在子线程中通过handler发送message给UI线程。</li>
</ol>
<p>再看文章开始的那个简单的例子，很明显，它实现了handleMessage()方法；新开了子线程；在子线程中通过handler实例发送了message。那么，Looper在哪里？Looper的prepare()和loop()在哪里？</p>
<h2 id="例子中的整个过程"><a href="#例子中的整个过程" class="headerlink" title="例子中的整个过程"></a>例子中的整个过程</h2><h3 id="1-UI线程初始化Handler"><a href="#1-UI线程初始化Handler" class="headerlink" title="1.UI线程初始化Handler"></a>1.UI线程初始化Handler</h3><p>其实，android已经为ActivityThread实现了Looper，并运行了prepare()和loop()，同时还有一个sMainThreadHandler与这个looper关联。查看/framework/base/core/java/android/app/ActivityThread.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">final Looper mLooper = Looper.myLooper();</div><div class="line">...</div><div class="line">static Handler sMainThreadHandler;  // set once in main()</div><div class="line">.........</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">        ....</div><div class="line"></div><div class="line">        Looper.prepareMainLooper();</div><div class="line"></div><div class="line">        ActivityThread thread = new ActivityThread();</div><div class="line">        thread.attach(false);</div><div class="line"></div><div class="line">        if (sMainThreadHandler == null) &#123;</div><div class="line">            sMainThreadHandler = thread.getHandler();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">.....</div><div class="line"></div><div class="line">        Looper.loop();</div><div class="line"></div><div class="line">        throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>查看Looper中相关函数的实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public static void prepareMainLooper() &#123;</div><div class="line">        prepare(false);</div><div class="line">        synchronized (Looper.class) &#123;</div><div class="line">            if (sMainLooper != null) &#123;</div><div class="line">                throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;);</div><div class="line">            &#125;</div><div class="line">            sMainLooper = myLooper();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">private static void prepare(boolean quitAllowed) &#123;</div><div class="line">        if (sThreadLocal.get() != null) &#123;</div><div class="line">            throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</div><div class="line">        &#125;</div><div class="line">        sThreadLocal.set(new Looper(quitAllowed));</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">private Looper(boolean quitAllowed) &#123;</div><div class="line">        mQueue = new MessageQueue(quitAllowed);</div><div class="line">        mThread = Thread.currentThread();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">public static @Nullable Looper myLooper() &#123;</div><div class="line">        return sThreadLocal.get();</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>UI主线程初始化时会通过ThreadLocal创建一个Looper，该Looper与UI主线程一一对应<br>。使用ThreadLocal的目的是保证每一个线程只创建唯一一个Looper。</p>
<p>之后我们创建自己的Handler时，直接获取第一个Handler（即sMainThreadHandler）创建的Looper。并共同使用Looper初始化的时候创建的消息队列MessageQueue。至此，主线程、消息循环、消息队列之间的关系是1:1:1。<br>Handler、Looper、MessageQueue的初始化流程如图所示:</p>
<p><img src="/assets/img/android_handler/new_handler.png" alt="image"></p>
<p>Handler持有对UI主线程消息队列MessageQueue和消息循环Looper的引用，子线程可以通过Handler将消息发送到UI线程的消息队列MessageQueue中。</p>
<h3 id="2-Handler创建消息"><a href="#2-Handler创建消息" class="headerlink" title="2. Handler创建消息"></a>2. Handler创建消息</h3><p>每一个消息都需要被指定的Handler处理，通过Handler创建消息便可以完成此功能。Android消息机制中引入了消息池。Handler创建消息时首先查询消息池中是否有消息存在，如果有直接从消息池中取得，如果没有则重新初始化一个消息实例。使用消息池的好处是：消息不被使用时，并不作为垃圾回收，而是放入消息池，可供下次Handler创建消息时使用。消息池提高了消息对象的复用，减少系统垃圾回收的次数。消息的创建流程如图所示。<br><img src="/assets/img/android_handler/new_message.png" alt="image"></p>
<p>查看源代码<br>Handler.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public final Message obtainMessage(int what)</div><div class="line">    &#123;</div><div class="line">        return Message.obtain(this, what);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>Message.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public static Message obtain(Handler h, int what) &#123;</div><div class="line">        Message m = obtain();</div><div class="line">        m.target = h;</div><div class="line">        m.what = what;</div><div class="line"></div><div class="line">        return m;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">public static Message obtain() &#123;</div><div class="line">        synchronized (sPoolSync) &#123;</div><div class="line">            if (sPool != null) &#123;</div><div class="line">                Message m = sPool;</div><div class="line">                sPool = m.next;</div><div class="line">                m.next = null;</div><div class="line">                m.flags = 0; // clear in-use flag</div><div class="line">                sPoolSize--;</div><div class="line">                return m;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return new Message();</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="3-Handler发送消息"><a href="#3-Handler发送消息" class="headerlink" title="3. Handler发送消息"></a>3. Handler发送消息</h3><p>关于Handler发送消息的内容，上面已经提到过了。主要就是将一条消息放到Looper维护的MessageQueue中去。</p>
<h3 id="4-Handler处理消息"><a href="#4-Handler处理消息" class="headerlink" title="4. Handler处理消息"></a>4. Handler处理消息</h3><p>UI主线程通过Looper.loop查询消息队列MessageQueue，当发现有消息存在时会将消息从消息队列中取出。首先分析消息，通过消息的参数判断该消息对应的Handler，然后将消息分发到指定的Handler进行处理。<br>子线程通过Handler、Looper与UI主线程通信的流程如图所示。<br><img src="/assets/img/android_handler/handle_message.png" alt="image"></p>
<h2 id="既然一个线程只能有一个Looper，但可以有多个Handler，那么Looper是如何将消息发送给正确的Handler处理的呢？"><a href="#既然一个线程只能有一个Looper，但可以有多个Handler，那么Looper是如何将消息发送给正确的Handler处理的呢？" class="headerlink" title="既然一个线程只能有一个Looper，但可以有多个Handler，那么Looper是如何将消息发送给正确的Handler处理的呢？"></a>既然一个线程只能有一个Looper，但可以有多个Handler，那么Looper是如何将消息发送给正确的Handler处理的呢？</h2><p><strong> 依靠msg.target </strong><br>在例子当中可以看到，发送消息的过程主要是这两行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Message msg =  myThreadHandler.obtainMessage(UPDATE_UI);</div><div class="line">myThreadHandler.sendMessage(msg); // 向Handler发送消息，更新UI</div></pre></td></tr></table></figure></p>
<p>这两行代码其实都有设置msg.target的过程，先看obtainMessage()</p>
<h3 id="obtainMessage"><a href="#obtainMessage" class="headerlink" title="obtainMessage()"></a>obtainMessage()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public final Message obtainMessage(int what)</div><div class="line">&#123;</div><div class="line">    return Message.obtain(this, what);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Handler的obtainMessage方法，调用到了Message的obtain方法，并传入参数this，也就是当前的myThreadHandler。再看Message的obtain(Handler h, int what)方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public static Message obtain(Handler h, int what) &#123;</div><div class="line">    Message m = obtain();</div><div class="line">    m.target = h;</div><div class="line">    m.what = what;</div><div class="line"></div><div class="line">    return m;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到m.target = h;将当前msg的target设为myThreadHandler。</p>
<p>###sendMessage()<br>上面讲到，所有发送消息的函数，最终都会调用到Handler的enqueueMessage方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123;</div><div class="line">        msg.target = this;</div><div class="line">        if (mAsynchronous) &#123;</div><div class="line">            msg.setAsynchronous(true);</div><div class="line">        &#125;</div><div class="line">        return queue.enqueueMessage(msg, uptimeMillis);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>该方法的第一行msg.target = this;，就将msg的target设置为了当前的handler。</p>
<h3 id="loop-处理消息"><a href="#loop-处理消息" class="headerlink" title="loop() 处理消息"></a>loop() 处理消息</h3><p>上面讲到，消息的处理是依靠loop方法不断的取出消息，并发送给对应的handler进行处理，在loop()方法中，负责这一工作的是<code>msg.target.dispatchMessage(msg);</code>可以看到，loop方法，正是依靠msg.target来确定调用哪一个handler来处理消息的。</p>
<h2 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</h2><p>应用程序当中为了实现同时完成多个任务，所以我们会在应用程序当中创建多个线程。为了让多个线程之间能够方便的通信，我们可以使用HandlerThread实现线程间的通信。</p>
<p>HandlerThread继承于Thread，所以它本质就是个Thread。与普通Thread的差别就在于，主要的作用是建立了一个线程，并且创立了消息队列，有来自己的looper,可以让我们在自己的线程中分发和处理消息。</p>
<p>HandlerThread类可以很方便地创建一个带有looper的新线程。该looper可以被用来创建hanlder对象。需要注意的是start方法必须要调用。</p>
<p>源码位置：/framework/base/core/java/android/os/HandlerThread.java<br>HandlerThread的代码非常简洁，核心函数包括：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">    mTid = Process.myTid();</div><div class="line">    Looper.prepare();</div><div class="line">    synchronized (this) &#123;</div><div class="line">        mLooper = Looper.myLooper();</div><div class="line">        notifyAll();</div><div class="line">    &#125;</div><div class="line">    Process.setThreadPriority(mPriority);</div><div class="line">    onLooperPrepared();</div><div class="line">    Looper.loop();</div><div class="line">    mTid = -1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，在该run方法中也是先调用了Looper.prepare()方法，然后通过Looper.myLooper()方法得到该线程所关联的looper对象，最后会调用Looper.loop()方法让消息队列循环起来。由此可以看出，HandlerThread的run方法主要就是将我们上面给出的正常情况下在新线程中创建Handler的代码做了一些封装而已。 在创建HandlerThread对象并调用其start方法之后，该HandlerThread线程就已经关联了looper对象（通过Looper.prepare()方法关联），并且该线程内部的消息队列循环了起来（通过Looper.loop()方法）。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public Looper getLooper() &#123;</div><div class="line">    if (!isAlive()) &#123;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // If the thread has been started, wait until the looper has been created.</div><div class="line">    synchronized (this) &#123;</div><div class="line">        while (isAlive() &amp;&amp; mLooper == null) &#123;</div><div class="line">            try &#123;</div><div class="line">                wait();</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return mLooper;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过handlerThread.getLooper()可以得到handlerThread线程所关联的looper对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public boolean quit() &#123;</div><div class="line">    Looper looper = getLooper();</div><div class="line">    if (looper != null) &#123;</div><div class="line">        looper.quit();</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">    return false;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用来退出looper。</p>
<h3 id="HandlerThread的例子"><a href="#HandlerThread的例子" class="headerlink" title="HandlerThread的例子"></a>HandlerThread的例子</h3><ol>
<li>创建一个HandlerThread，即创建了一个包含Looper的线程。</li>
</ol>
<p>HandlerThread handlerThread = new HandlerThread(“leochin.com”);<br>handlerThread.start(); //创建HandlerThread后一定要记得start()</p>
<ol>
<li>获取HandlerThread的Looper</li>
</ol>
<p>Looper looper = handlerThread.getLooper();</p>
<ol>
<li>创建Handler，通过Looper初始化</li>
</ol>
<p>Handler handler = new Handler(looper);</p>
<p>通过以上三步我们就成功创建HandlerThread。通过handler发送消息，就会在子线程中执行。</p>
<p>如果想让HandlerThread退出，则需要调用handlerThread.quit();。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/26/oneday-handler/" data-id="cje6pjw23004aweyxxnu2c7f0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android-everyday/">Android_everyday</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-oneday-activity-lifecycle" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/22/oneday-activity-lifecycle/" class="article-date">
  <time datetime="2016-09-22T12:24:09.000Z" itemprop="datePublished">2016-09-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>►<a class="article-category-link" href="/categories/Android/Android-everyday/">Android_everyday</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/22/oneday-activity-lifecycle/">Activity生命周期</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://www.jianshu.com/p/ae6e1d93cc8e" target="_blank" rel="external">怎么理解Activity的生命周期？</a></p>
<p><a href="http://www.jianshu.com/p/f8a0c43b3dfe" target="_blank" rel="external">如何判断Activity是否在运行？</a></p>
<p><a href="http://www.jianshu.com/p/1071b9c48f1e" target="_blank" rel="external">自定义View的状态是如何保存的？</a></p>
<p>这个题目主要针对view的onSaveInstanceState方法</p>
<p><a href="http://www.jianshu.com/p/4f482548de59" target="_blank" rel="external">通过new创建的View实例它的onSaveStateInstance会被调用吗?</a></p>
<p>这个题目是view的onSaveInstanceState方法的一个延伸</p>
<h2 id="Activity生命周期"><a href="#Activity生命周期" class="headerlink" title="Activity生命周期"></a>Activity生命周期</h2><p>Activity是由Activity栈进管理，当来到一个新的Activity后，此Activity将被加入到Activity栈顶，之前的Activity位于此Activity底部。Acitivity一般意义上有四种状态：</p>
<p>1.当Activity位于栈顶时，此时正好处于屏幕最前方，此时处于运行状态；</p>
<p>2.当Activity失去了焦点但仍然对用于可见（如栈顶的Activity是透明的或者栈顶Activity并不是铺满整个手机屏幕），此时处于暂停状态；</p>
<p>3.当Activity被其他Activity完全遮挡，此时此Activity对用户不可见，此时处于停止状态；</p>
<p>4.当Activity由于人为或系统原因（如低内存等）被销毁，此时处于销毁状态；</p>
<p>在每个不同的状态阶段，Android系统对Activity内相应的方法进行了回调。因此，我们在程序中写Activity时，一般都是继承Activity类并重写相应的回调方法。</p>
<p><img src="/assets/img/android_activity/activity_life_cycle.png" alt="image"></p>
<ol>
<li>Activity实例是由系统自动创建，并在不同的状态期间回调相应的方法。一个最简单的完整的Activity生命周期会按照如下顺序回调：onCreate -&gt; onStart -&gt; onResume -&gt; onPause -&gt; onStop -&gt; onDestroy。称之为entire lifetime</li>
<li>当执行onStart回调方法时，Activity开始被用户所见（也就是说，onCreate时用户是看不到此Activity的，那用户看到的是哪个？当然是此Activity之前的那个Activity），一直到onStop之前，此阶段Activity都是被用户可见，称之为visible lifetime</li>
<li>当执行到onResume回调方法时，Activity可以响应用户交互，一直到onPause方法之前，此阶段Activity称之为foreground lifetime</li>
</ol>
<h2 id="一些例子"><a href="#一些例子" class="headerlink" title="一些例子"></a>一些例子</h2><p>在实际应用场景中，假设A Activity位于栈顶，此时用户操作，从A Activity跳转到B Activity。那么对AB来说，具体会回调哪些生命周期中的方法呢？回调方法的具体回调顺序又是怎么样的呢？</p>
<p>开始时，A被实例化，执行的回调有A:onCreate -&gt; A:onStart -&gt; A:onResume。</p>
<p>当用户点击A中按钮来到B时，假设B全部遮挡住了A，将依次执行A:onPause -&gt; B:onCreate -&gt; B:onStart -&gt; B:onResume -&gt; A:onStop。</p>
<p>此时如果点击Back键，将依次执行B:onPause -&gt; A:onRestart -&gt; A:onStart -&gt; A:onResume -&gt; B:onStop -&gt; B:onDestroy。</p>
<p>至此，Activity栈中只有A。在Android中，有两个按键在影响Activity生命周期这块需要格外区分下，即Back键和Home键。我们先直接看下实验结果：</p>
<p>此时如果按下Back键，系统返回到桌面，并依次执行A:onPause -&gt; A:onStop -&gt; A:onDestroy。</p>
<p>此时如果按下Home键（非长按），系统返回到桌面，并依次执行A:onPause -&gt; A:onStop。由此可见，Back键和Home键主要区别在于是否会执行onDestroy。</p>
<ul>
<li>此外，需要注意，不能在onPause()中执行耗时的操作。从上面的流程可以看出，就得Activity必须先onPause，新的Activity才会开始执行onCreate等一些列的操作，所以，如果在旧的Activity的onPause中执行耗时的操作，就会影响界面切换的速度。</li>
</ul>
<h2 id="何时会调用onRestart"><a href="#何时会调用onRestart" class="headerlink" title="何时会调用onRestart()"></a>何时会调用onRestart()</h2><ul>
<li>当用户按下Home键然后又回到当前程序，就会执行这个方法</li>
<li>当用户从当前甲Activity打开一个新的Activity，然后又back键返回到甲Activity</li>
<li>用户按下任务列表，然后选择了刚刚打开过的那个程序，那么这个方法也会执行。</li>
</ul>
<h2 id="一个别人踩过的坑"><a href="#一个别人踩过的坑" class="headerlink" title="一个别人踩过的坑"></a>一个别人踩过的坑</h2><p><strong>重点是：只要没有人为的调用A的finish()方法，虽然A执行了onDestroy，但Activity栈中依然保留有A</strong></p>
<p>由于Android本身的特性，使得现在不少应用都没有直接退出应用程序的功能，按照一般的逻辑，当Activity栈中有且只有一个Activity时，当按下Back键此Activity会执行onDestroy，那么下次点击此应用程图标将从重新启动，因此，当前不少应用程序都是采取如Home键的效果，当点击了Back键，系统返回到桌面，然后点击应用程序图标，直接回到之前的Activity界面，这种效果是怎么实现的呢？</p>
<p>通过重写按下Back键的回调函数，转成Home键的效果即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void onBackPressed() &#123;</div><div class="line">    Intent home = new Intent(Intent.ACTION_MAIN);</div><div class="line">    home.addCategory(Intent.CATEGORY_HOME);</div><div class="line">    startActivity(home);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当然，此种方式通过Home键效果强行影响到Back键对Activity生命周期的影响。注意，此方法只是针对按Back键需要退回到桌面时的Activity且达到Home效果才重写。</p>
<p>或者，为达到此类效果，Activity实际上提供了直接的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">activity.moveTaskToBack(true);</div></pre></td></tr></table></figure></p>
<p>moveTaskToBack()此方法直接将当前Activity所在的Task移到后台，同时保留activity顺序和状态。</p>
<p>在之前的项目开发过程中，当时遇到一个很奇怪的问题：手机上的“开发者选项”中有一个“不保留活动”的设置，当开启此设置，手机上的设置提示是“用户离开后即销毁每个活动”，开启后，对于其他的应用程序是从A Acticity到B Activity，然后Back键回到A，此时，其他应用程序只是先白屏（有可能黑屏等，取决于主题设置）一下，然后A开始可见，但是我的应用程序中出现的一个结果却是直接返回到了桌面。一开始百思不得其解。最后终于定位出问题。首先，我们需要明确开启此设置项后对Activity生命周期的影响。开启此设置项后，当A到B时，假设B全部遮挡住了A，将依次执行A:onPause -&gt; B:onCreate -&gt; B:onStart -&gt; B:onResume -&gt; A:onStop -&gt; A:onDestroy。是的，A在系统原本的生命周期回调中增加了onDestroy。此即“用户离开后即销毁每个活动”的含义。但此时需要注意的是，只要没有认为的调用A的finish()方法，虽然A执行了onDestroy，但Activity栈中依然保留有A，此时B处于栈顶。那么在B中按Back键回到A时，将依次执行：B:onPause -&gt; A:onCreate -&gt; A:onStart -&gt; A:onResume -&gt; B:onStop -&gt; B:onDestroy。没错，A从onCreate开始执行了。此处也就解释了为什么A可能会出现白屏（或黑屏等）一下的原因了。</p>
<p>那么为什么我的应用程序会跟其他应用程序出现不一样呢?最后定为出问题在于当时我的应用程序中为了做到完全退出应用程序效果，专门使用了一个Activity栈去维护Activity（当时是借鉴了网上的此类实现方案，现在想想，实在没必要，且不说Android本身特性决定了没必要通过如此方法去达到退出效果，仅仅是此方法本身也存在很大的问题，现在在网上依然能见到有不少文章说到应用程序退出可以使用此方法，哎。。），在onCreate中入栈，onDestroy出栈，调用了如下方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 结束Activity&amp;从堆栈中移除</div><div class="line">AppManager.getAppManager().finishActivity(this);</div></pre></td></tr></table></figure></p>
<p>其中，AppManager中finishActivity函数具体定义是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 结束指定的Activity</div><div class="line"> */</div><div class="line">public void finishActivity(Activity activity) &#123;</div><div class="line">    if (activity != null) &#123;</div><div class="line">        activityStack.remove(activity);</div><div class="line">        activity.finish();</div><div class="line">        activity = null;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>至此，相信大家应该看出问题的所在了吧。</p>
<p>没错，问题在于执行了activity的finish()方法！！ activity的finish()方法至少有两个层面含义，1.将此Activity从Activity栈中移除，2.调用了此Activity的onDestroy方法。对于不开启“不保留活动”的设置项，实际上也没什么影响，但是一旦开启此设置，问题显露无疑。开启此此设置后，正常情况下离开A，即使执行了A的onDestroy，Activity栈中还是有A的，但是我这样写后，finish()方法一执行，Activity栈中就没有A了，因此，当点击Back键时，Activity栈中已经没有此应用的任何Activity了，直接来到了手机桌面。</p>
<p>可能，有些人会说，我就是要通过此种方法想去完全退出应用程序，同时希望自己的Activity栈和系统中Activity栈保持一致，怎么办呢？</p>
<p>在此，可以通过如下改写去实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">* 结束指定的Activity</div><div class="line"> */</div><div class="line">public void finishActivity(Activity activity) &#123;</div><div class="line">    if (activity != null) &#123;</div><div class="line">    // 为与系统Activity栈保持一致，且考虑到手机设置项里的&quot;不保留活动&quot;选项引起的Activity生命周期调用onDestroy()方法所带来的问题,此处需要作出如下修正</div><div class="line">    if(activity.isFinishing())&#123;</div><div class="line">        activityStack.remove(activity);</div><div class="line">        //activity.finish();</div><div class="line">        activity = null;</div><div class="line">    &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="横屏竖屏切换"><a href="#横屏竖屏切换" class="headerlink" title="横屏竖屏切换"></a>横屏竖屏切换</h2><p>1、新建一个Activity，并把各个生命周期打印出来</p>
<p>2、运行Activity，得到如下信息</p>
<p>onCreate–&gt;<br>onStart–&gt;<br>onResume–&gt;</p>
<p>3、按crtl+f12切换成横屏时</p>
<p>onSaveInstanceState–&gt;<br>onPause–&gt;<br>onStop–&gt;<br>onDestroy–&gt;<br>onCreate–&gt;<br>onStart–&gt;<br>onRestoreInstanceState–&gt;<br>onResume–&gt;</p>
<p>4、再按crtl+f12切换成竖屏时，发现打印了两次相同的log</p>
<p>onSaveInstanceState–&gt;<br>onPause–&gt;<br>onStop–&gt;<br>onDestroy–&gt;<br>onCreate–&gt;<br>onStart–&gt;<br>onRestoreInstanceState–&gt;<br>onResume–&gt;<br>onSaveInstanceState–&gt;<br>onPause–&gt;<br>onStop–&gt;<br>onDestroy–&gt;<br>onCreate–&gt;<br>onStart–&gt;<br>onRestoreInstanceState–&gt;<br>onResume–&gt;</p>
<p>5、修改AndroidManifest.xml，把该Activity添加 android:configChanges=”orientation”，执行步骤3</p>
<p>onSaveInstanceState–&gt;<br>onPause–&gt;<br>onStop–&gt;<br>onDestroy–&gt;<br>onCreate–&gt;<br>onStart–&gt;<br>onRestoreInstanceState–&gt;<br>onResume–&gt;</p>
<p>6、再执行步骤4，发现不会再打印相同信息，但多打印了一行onConfigChanged</p>
<p>onSaveInstanceState–&gt;<br>onPause–&gt;<br>onStop–&gt;<br>onDestroy–&gt;<br>onCreate–&gt;<br>onStart–&gt;<br>onRestoreInstanceState–&gt;<br>onResume–&gt;<br>onConfigurationChanged–&gt;</p>
<p>7、把步骤5的android:configChanges=”orientation” 改成 android:configChanges=”orientation|keyboardHidden”，执行步骤3，就只打印onConfigChanged</p>
<p>onConfigurationChanged–&gt;</p>
<p>8、执行步骤4</p>
<p>onConfigurationChanged–&gt;<br>onConfigurationChanged–&gt;</p>
<p> 总结：</p>
<p>1、不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次</p>
<p>2、设置Activity的android:configChanges=”orientation”时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次</p>
<p>3、设置Activity的android:configChanges=”orientation|keyboardHidden”时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法</p>
<h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><ol>
<li><p>当前Activity产生事件弹出Toast和AlertDialog的时候Activity的生命周期不会有改变</p>
</li>
<li><p>Activity运行时按下HOME键(跟被完全覆盖是一样的)：onSaveInstanceState –&gt; onPause –&gt; onStop       onRestart –&gt;onStart—&gt;onResume</p>
</li>
<li><p>Activity未被完全覆盖只是失去焦点：onPause—&gt;onResume</p>
</li>
<li><p>在一些特殊的情况中，你可能希望当一种或者多种配置改变时避免重新启动你的activity。你可以通过在manifest中设置android:configChanges属性来实现这点。</p>
<p> 你可以在这里声明activity可以处理的任何配置改变，当这些配置改变时不会重新启动activity，而会调用activity的<br>onConfigurationChanged(Resources.Configuration)方法。如果改变的配置中包含了你所无法处理的配置（在android:configChanges并未声明），<br>你的activity仍然要被重新启动，而onConfigurationChanged(Resources.Configuration)将不会被调用。</p>
</li>
</ol>
<h2 id="Activity-View的状态保存机制"><a href="#Activity-View的状态保存机制" class="headerlink" title="Activity/View的状态保存机制"></a>Activity/View的状态保存机制</h2><p>Android中为Actvity的实例状态保存和恢复提供了相应的机制，通过提供相应的实例状态保存和恢复回调，将状态数据存储到系统中的Bundle中。相应的回调函数分别为：onSaveInstanceState(Bundle)和onRestoreInstanceState(Bundle)。当然，对于实例状态的恢复，也可以直接通过onCreate(Bundle)中的Bundle参数进行。onCreate(Bundle)和onRestoreInstanceState(Bundle)都能恢复实例状态，且一般情况下，两种方式恢复实例状态功能相同，唯一比较有差别的地方，在于恢复实例状态的时机，onRestoreInstanceState(Bundle)回调时机更加靠后。</p>
<p><img src="/assets/img/android_activity/saveInstanceState.png" alt="image"></p>
<p>当某个activity变得“容易”被系统销毁时，该activity的onSaveInstanceState就会被执行，除非该activity是被用户主动销毁的，例如当用户按BACK键的时候。何为“容易”？言下之意就是该activity还没有被销毁，而仅仅是一种可能性。这种可能性有这么几种情况： </p>
<ol>
<li>当用户按下HOME键时。<br>这是显而易见的，系统不知道你按下HOME后要运行多少其他的程序，自然也不知道activity A是否会被销毁，故系统会调用onSaveInstanceState，让用户有机会保存某些非永久性的数据。以下几种情况的分析都遵循该原则 </li>
<li>长按HOME键，选择运行其他的程序时。 </li>
<li>按下电源按键（关闭屏幕显示）时。 </li>
<li>从activity A中启动一个新的activity时。 </li>
<li>屏幕方向切换时，例如从竖屏切换到横屏时。<br>在屏幕切换之前，系统会销毁activity A，在屏幕切换之后系统又会自动地创建activity A，所以onSaveInstanceState一定会被执行。 </li>
</ol>
<p>总而言之，onSaveInstanceState的调用遵循一个重要原则，即当系统“未经你许可”时销毁了你的activity，则onSaveInstanceState会被系统调用，这是系统的责任，因为它必须要提供一个机会让你保存你的数据.它会在调用 onStop之前，但是是不是在onPuase之前就不能确认了，要看情况，官方文档在说明这个执行顺序时用了“可能”这个词。</p>
<p>Activity类的onSaveInstanceState默认实现会恢复Activity的状态，默认实现会为布局中的每个View调用相应的 onSaveInstanceState方法，让每个View都能保存自身的信息。</p>
<p>这里需要注意一个细节：想要保存View的状态，需要在XML布局文件中提供一个唯一的ID（android:id），如果没有设置这个ID的话，View控件的onSaveInstanceState是不会被调用的。</p>
<p>至于onRestoreInstanceState方法，需要注意的是，</p>
<p><strong>onSaveInstanceState方法和onRestoreInstanceState方法“不一定”是成对的被调用的。</strong></p>
<p>onRestoreInstanceState被调用的前提是，activity A“确实”被系统销毁了，而如果仅仅是停留在有这种可能性的情况下，则该方法不会被调用，例如，当正在显示activity A的时候，用户按下HOME键回到主界面，然后用户紧接着又返回到activity A，这种情况下activity A一般不会因为内存的原因被系统销毁，故activity A的onRestoreInstanceState方法不会被执行。</p>
<p>另外，onRestoreInstanceState的bundle参数也会传递到onCreate方法中，你也可以选择在onCreate方法中做数据还原。 </p>
<h2 id="通过new创建的View实例它的onSaveStateInstance会被调用吗"><a href="#通过new创建的View实例它的onSaveStateInstance会被调用吗" class="headerlink" title="通过new创建的View实例它的onSaveStateInstance会被调用吗"></a>通过new创建的View实例它的onSaveStateInstance会被调用吗</h2><p>自定义View控件的状态被保存需要满足两个条件：</p>
<ol>
<li>View有唯一的ID；</li>
<li>View的初始化时要调用setSaveEnabled(true) </li>
</ol>
<p>View的状态保存和读取的调用过程：<br><img src="/assets/img/android_activity/savestate.png" alt="image"></p>
<p>里面的SparseArray(完整的参数是：SparseArray<parcelable> )是一个KEY-VALUE的Map，KEY当然就是View的ID了。</parcelable></p>
<p>所以，只要设置了ID就会。其实我们在XML文件中配置的布局和属性最终都是通过LayoutInflater中的inflate方法去加载，由它去创建各个View的实例（还是用new），并根据XML文件中的属性设置相关的值。</p>
<h2 id="如何判断Activity是否在运行？"><a href="#如何判断Activity是否在运行？" class="headerlink" title="如何判断Activity是否在运行？"></a>如何判断Activity是否在运行？</h2><p>这个问题直接对应着各种弹dialog的时候，没有activity的情况。</p>
<p>比如，Activity开启了一个线程，去执行一个耗时操作，并在操作完成后，使用handler来通知Activity弹出通知dailog。但如果在线程执行的过程中，按了back键，activity就被销毁了，当线程执行结束，需要弹出dialog时，就会报错，进而引起崩溃。</p>
<ul>
<li><p>为什么activity销毁了，仍然能执行到弹出dialog的代码？</p>
<p>  Activity销毁只是不再受系统的AMS控制，但Activity这个对象的实例还是存在于内存中的，具体什么时候真正把这个对象实例也销毁（回收）了，就要看内存回收机制了，哪怕是这个实例没有可达的引用了也不一定会马上回收。</p>
</li>
</ul>
<h3 id="错误的解决方法"><a href="#错误的解决方法" class="headerlink" title="错误的解决方法"></a>错误的解决方法</h3><p>isFinishing()</p>
<p>源码中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public boolean isFinishing() &#123;</div><div class="line">     return mFinished;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>而mFinished是在finish()中被赋值的，也就是说只有通过调用finish()结束的Activity，mFinished的值才会被置为true。所以有时候Activity的生命周期没有按我们预想的来走时（如内存紧张时），会出现判断出错的情况。</p>
<h3 id="正确的解决方法"><a href="#正确的解决方法" class="headerlink" title="正确的解决方法"></a>正确的解决方法</h3><p>该方法来自官方应用Dialer</p>
<p>packages/apps/Dialer/src/com/android/dialer/calllog/ClearCallLogDialog.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">if (activity == null || activity.isDestroyed() || activity.isFinishing()) &#123;</div><div class="line">                            return;</div><div class="line">&#125;</div><div class="line"></div><div class="line">if (progressDialog != null &amp;&amp; progressDialog.isShowing()) &#123;</div><div class="line">                            progressDialog.dismiss();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，判断条件有三个：activity == null || activity.isDestroyed() || activity.isFinishing()</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/22/oneday-activity-lifecycle/" data-id="cje6pjw1r003gweyxeg56daob" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android-everyday/">Android_everyday</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-pass-by-value-or-reference" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/22/pass-by-value-or-reference/" class="article-date">
  <time datetime="2016-09-22T11:16:06.000Z" itemprop="datePublished">2016-09-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>►<a class="article-category-link" href="/categories/Android/Android-everyday/">Android_everyday</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/22/pass-by-value-or-reference/">Java中的值传递和引用传递</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://www.jianshu.com/p/c0c5e0540928" target="_blank" rel="external">Java的值传递和引用传递问题</a></p>
<p>值传递，传递的是值的拷贝，也就是说传递后就互不相关了。</p>
<p>引用传递，指的是在方法调用时，传递的参数是按引用进行传递，其实传递的引用的地址，也就是变量所对应的内存空间的地址。</p>
<p>简单的说，基本类型是按值传递的，方法的实参是一个原值的复本。类对象是按对象的引用地址（内存地址）传递地址的值，那么在方法内对这个对象进行修改是会直接反应在原对象上的（或者说这两个引用指向同一内存地址）。</p>
<p>三句话总结一下：</p>
<ol>
<li>对象就是传引用</li>
<li>原始类型（byte,char,short,int,long,float,double，boolean<br>）就是传值</li>
<li>String，Integer, Double等immutable类型因为没有提供自身修改的函数，每次操作都是新生成一个对象，所以要特殊对待。可以认为是传值。<br>Integer 和 String 一样。保存value的类变量是Final属性，无法被修改，只能被重新赋值／生成新的对象。 当Integer 做为方法参数传递进方法内时，对其的赋值都会导致 原Integer 的引用被 指向了方法内的栈地址，失去了对原类变量地址的指向。对赋值后的Integer对象做得任何操作，都不会影响原来对象。</li>
</ol>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><ol>
<li>按值传递<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class TempTest &#123;  </div><div class="line">    private void test1(int a)&#123;  </div><div class="line">        a = 5;  </div><div class="line">        System.out.println(&quot;test1方法中的a=&quot;+a);  </div><div class="line">&#125;  </div><div class="line">public static void main(String[] args) &#123;  </div><div class="line">    TempTest t = new TempTest();  </div><div class="line">    int a = 3;  </div><div class="line">    t.test1(a);//传递后，test1方法对变量值的改变不影响这里的a  </div><div class="line">    System.out.println(”main方法中的a=”+a);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">test1方法中的a=5  </div><div class="line">main方法中的a=3</div></pre></td></tr></table></figure></p>
<ol>
<li>按引用传递<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class TempTest &#123;  </div><div class="line">    private void test1(A a)&#123;  </div><div class="line">    a.age = 20;  </div><div class="line">    System.out.println(&quot;test1方法中的age=&quot;+a.age);  </div><div class="line">&#125;  </div><div class="line">public static void main(String[] args) &#123;  </div><div class="line">    TempTest t = new TempTest();  </div><div class="line">    A a = new A();  </div><div class="line">    a.age = 10;  </div><div class="line">    t.test1(a);  </div><div class="line">    System.out.println(”main方法中的age=”+a.age);  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">class A&#123;  </div><div class="line">    public int age = 0;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>运行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">test1方法中的age=20  </div><div class="line">main方法中的age=20</div></pre></td></tr></table></figure></p>
<ol>
<li>String的测试<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class test&#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">    	String x = new String(&quot;xxxx&quot;);</div><div class="line">		String y = &quot;yyyy&quot;;    </div><div class="line">		change(x,y);</div><div class="line">    	System.out.println(&quot;main: &quot;+ x);</div><div class="line">		System.out.println(&quot;main: &quot; + y);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static void change(String x,String y) &#123;</div><div class="line">    	x = &quot;x&quot;;</div><div class="line">		y = &quot;y&quot;;</div><div class="line">    	System.out.println(&quot;change: &quot; + x);</div><div class="line">		System.out.println(&quot;change: &quot; + y);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>运行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">change: x</div><div class="line">change: y</div><div class="line">main: xxxx</div><div class="line">main: yyyy</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/22/pass-by-value-or-reference/" data-id="cje6pjw210042weyxot3y7vmx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android-everyday/">Android_everyday</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/3/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/5/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/Android-everyday/">Android_everyday</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android/Android开发工程师/">Android开发工程师</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/AndroidRom/">AndroidRom</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Anrom/">Anrom</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Anrom/rom7-0/">rom7.0</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/Android开发工程师/">Android开发工程师</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SEAndroid/">SEAndroid</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/cjdns/">cjdns</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/cjdns/cjdns源码分析/">cjdns源码分析</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/cjdns-cjdns源码分析/">cjdns - cjdns源码分析</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/hexo/">hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/music/">music</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/net/">net</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/net/iptables/">iptables</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/树莓派/">树莓派</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/树莓派/配置/">配置</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/算法/Java/">Java</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/Java/">Java</a></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android-everyday/">Android_everyday</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android开发工程师/">Android开发工程师</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Anrom/">Anrom</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-C/">C/C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SEAndroid/">SEAndroid</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SELinux/">SELinux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cjdns/">cjdns</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cjdns源码分析/">cjdns源码分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iptables/">iptables</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/music/">music</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/raspberry配置/">raspberry配置</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rom/">rom</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shadowsocks-vps/">shadowsocks/vps</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tool/">tool</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/填坑/">填坑</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/排序算法/">排序算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/查找算法/">查找算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/树莓派raspberry/">树莓派raspberry</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/Android-everyday/" style="font-size: 16.67px;">Android_everyday</a> <a href="/tags/Android开发工程师/" style="font-size: 15.56px;">Android开发工程师</a> <a href="/tags/Anrom/" style="font-size: 14.44px;">Anrom</a> <a href="/tags/C-C/" style="font-size: 14.44px;">C/C++</a> <a href="/tags/Java/" style="font-size: 18.89px;">Java</a> <a href="/tags/Linux/" style="font-size: 13.33px;">Linux</a> <a href="/tags/SEAndroid/" style="font-size: 10px;">SEAndroid</a> <a href="/tags/SELinux/" style="font-size: 10px;">SELinux</a> <a href="/tags/cjdns/" style="font-size: 14.44px;">cjdns</a> <a href="/tags/cjdns源码分析/" style="font-size: 14.44px;">cjdns源码分析</a> <a href="/tags/git/" style="font-size: 11.11px;">git</a> <a href="/tags/hexo/" style="font-size: 13.33px;">hexo</a> <a href="/tags/iptables/" style="font-size: 10px;">iptables</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/music/" style="font-size: 10px;">music</a> <a href="/tags/raspberry配置/" style="font-size: 10px;">raspberry配置</a> <a href="/tags/rom/" style="font-size: 10px;">rom</a> <a href="/tags/shadowsocks-vps/" style="font-size: 10px;">shadowsocks/vps</a> <a href="/tags/tool/" style="font-size: 11.11px;">tool</a> <a href="/tags/填坑/" style="font-size: 13.33px;">填坑</a> <a href="/tags/排序算法/" style="font-size: 11.11px;">排序算法</a> <a href="/tags/数据结构/" style="font-size: 10px;">数据结构</a> <a href="/tags/查找算法/" style="font-size: 11.11px;">查找算法</a> <a href="/tags/树莓派raspberry/" style="font-size: 11.11px;">树莓派raspberry</a> <a href="/tags/算法/" style="font-size: 12.22px;">算法</a> <a href="/tags/设计模式/" style="font-size: 17.78px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">June 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">April 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02/">February 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">January 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/03/">March 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/02/">February 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/06/">June 2013</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/01/29/cjnds-asymmetric-cryptography/">握手过程中，非对称密钥的应用</a>
          </li>
        
          <li>
            <a href="/2017/12/04/how-to-fix-rebase-still-in-progress/">如何解决报错“prior sync failed; rebase still in progress”</a>
          </li>
        
          <li>
            <a href="/2017/11/22/cjdns-3steps-lladdrsession/">使用SocketAddress来维护的EndpointsBySockaddr map机制中EndpointsBySockaddr session的建立过程</a>
          </li>
        
          <li>
            <a href="/2017/09/05/cjdns-cryptoauth/">cjdns源码分析--CryptoAuth</a>
          </li>
        
          <li>
            <a href="/2017/09/04/how-to-read-staff/">如何看懂五线谱</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Chris King<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>