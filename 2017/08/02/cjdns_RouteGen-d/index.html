<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-Hant-TW">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="RouteGen主要是跟路由相关的代码。">
<meta name="keywords" content="C&#x2F;C++,cjdns,cjdns源码分析">
<meta property="og:type" content="article">
<meta property="og:title" content="cjdns源码分析--RouteGen">
<meta property="og:url" content="http://yoursite.com/2017/08/02/cjdns_RouteGen-d/index.html">
<meta property="og:site_name" content="IChrisKing">
<meta property="og:description" content="RouteGen主要是跟路由相关的代码。">
<meta property="og:locale" content="zh-Hant-TW">
<meta property="og:updated_time" content="2018-02-28T05:58:55.153Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="cjdns源码分析--RouteGen">
<meta name="twitter:description" content="RouteGen主要是跟路由相关的代码。">






  <link rel="canonical" href="http://yoursite.com/2017/08/02/cjdns_RouteGen-d/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>cjdns源码分析--RouteGen | IChrisKing</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hant-TW">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">IChrisKing</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">#IMNOTCHRISLEE</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/02/cjdns_RouteGen-d/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chris King">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IChrisKing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">cjdns源码分析--RouteGen

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2017-08-02 11:42:23" itemprop="dateCreated datePublished" datetime="2017-08-02T11:42:23+08:00">2017-08-02</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-02-28 13:58:55" itemprop="dateModified" datetime="2018-02-28T13:58:55+08:00">2018-02-28</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/cjdns/" itemprop="url" rel="index"><span itemprop="name">cjdns</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/cjdns/cjdns源码分析/" itemprop="url" rel="index"><span itemprop="name">cjdns源码分析</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          
            <div class="post-description">RouteGen主要是跟路由相关的代码。</div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct RouteGen</span><br><span class="line">&#123;</span><br><span class="line">    bool hasUncommittedChanges;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct RouteGen_pvt</span><br><span class="line">&#123;</span><br><span class="line">    struct RouteGen pub;</span><br><span class="line">    struct ArrayList_OfPrefix6* prefixes6;</span><br><span class="line">    struct ArrayList_OfPrefix6* localPrefixes6;</span><br><span class="line">    struct ArrayList_OfPrefix6* exceptions6;</span><br><span class="line"></span><br><span class="line">    struct ArrayList_OfPrefix4* prefixes4;</span><br><span class="line">    struct ArrayList_OfPrefix4* localPrefixes4;</span><br><span class="line">    struct ArrayList_OfPrefix4* exceptions4;</span><br><span class="line"></span><br><span class="line">    struct Allocator* alloc;</span><br><span class="line">    struct Log* log;</span><br><span class="line"></span><br><span class="line">    Identity</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到，ipv4和ipv6各有三个ArrayList。这里面放着一些网段信息。</p>
<h2 id="RouteGen-new"><a href="#RouteGen-new" class="headerlink" title="RouteGen_new"></a>RouteGen_new</h2><p>这个方法在Core.c的Core_init中调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct RouteGen* RouteGen_new(struct Allocator* allocator, struct Log* log)</span><br><span class="line">&#123;</span><br><span class="line">    struct Allocator* alloc = Allocator_child(allocator);</span><br><span class="line">    struct RouteGen_pvt* rp = Allocator_calloc(alloc, sizeof(struct RouteGen_pvt), 1);</span><br><span class="line">    rp-&gt;prefixes6 = ArrayList_OfPrefix6_new(alloc);</span><br><span class="line">    rp-&gt;localPrefixes6 = ArrayList_OfPrefix6_new(alloc);</span><br><span class="line">    rp-&gt;exceptions6 = ArrayList_OfPrefix6_new(alloc);</span><br><span class="line">    rp-&gt;prefixes4 = ArrayList_OfPrefix4_new(alloc);</span><br><span class="line">    rp-&gt;localPrefixes4 = ArrayList_OfPrefix4_new(alloc);</span><br><span class="line">    rp-&gt;exceptions4 = ArrayList_OfPrefix4_new(alloc);</span><br><span class="line">    rp-&gt;log = log;</span><br><span class="line">    rp-&gt;alloc = alloc;</span><br><span class="line">    Identity_set(rp);</span><br><span class="line">    setupDefaultLocalPrefixes(rp);</span><br><span class="line">    return &amp;rp-&gt;pub;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>除了简单的赋值之外，主要做了两件事：</p>
<ol>
<li>new各种ArrayList</li>
<li>setupDefaultLocalPrefixes<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static void setupDefaultLocalPrefixes(struct RouteGen_pvt* rp)</span><br><span class="line">&#123;</span><br><span class="line">    struct Sockaddr_storage ss;</span><br><span class="line">    #define ADD_PREFIX(str) \</span><br><span class="line">        Assert_true(!Sockaddr_parse(str, &amp;ss));       \</span><br><span class="line">        RouteGen_addLocalPrefix(&amp;rp-&gt;pub, &amp;ss.addr)</span><br><span class="line"></span><br><span class="line">    ADD_PREFIX(&quot;fe80::/10&quot;);</span><br><span class="line">    ADD_PREFIX(&quot;fd00::/8&quot;);</span><br><span class="line"></span><br><span class="line">    ADD_PREFIX(&quot;10.0.0.0/8&quot;);</span><br><span class="line">    ADD_PREFIX(&quot;172.16.0.0/12&quot;);</span><br><span class="line">    ADD_PREFIX(&quot;192.168.0.0/16&quot;);</span><br><span class="line">    ADD_PREFIX(&quot;127.0.0.0/8&quot;);</span><br><span class="line"></span><br><span class="line">    #undef ADD_PREFIX</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这个函数add了一些网段信息到LocalPrefix表。<br>这个过程调用到了两个函数:<br>1.Sockaddr_parse<br>将一个字符串类型的ip地址转成Sockaddr_storage类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">struct Sockaddr</span><br><span class="line">&#123;</span><br><span class="line">    /** the length of this sockaddr, this field is included in the length. */</span><br><span class="line">    uint16_t addrLen;</span><br><span class="line"></span><br><span class="line">    #define Sockaddr_flags_BCAST  1</span><br><span class="line">    #define Sockaddr_flags_PREFIX (1&lt;&lt;1)</span><br><span class="line">    uint16_t flags;</span><br><span class="line"></span><br><span class="line">    /** Only applies if flags &amp; Sockaddr_flags_PREFIX is true. */</span><br><span class="line">    uint8_t prefix;</span><br><span class="line"></span><br><span class="line">    uint8_t pad1;</span><br><span class="line">    uint16_t pad2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Sockaddr_storage</span><br><span class="line">&#123;</span><br><span class="line">    struct Sockaddr addr;</span><br><span class="line">    uint64_t nativeAddr[Sockaddr_MAXSIZE / 8];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int Sockaddr_parse(const char* input, struct Sockaddr_storage* out)</span><br><span class="line">&#123;</span><br><span class="line">    struct Sockaddr_storage unusedOut;</span><br><span class="line">    if (!out) &#123;</span><br><span class="line">        out = &amp;unusedOut;</span><br><span class="line">    &#125;</span><br><span class="line">    uint8_t buff[64] = &#123;0&#125;;</span><br><span class="line">    if (CString_strlen(input) &gt; 63) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    CString_strncpy(buff, input, 63);</span><br><span class="line"></span><br><span class="line">    int64_t port = 0;</span><br><span class="line">    char* lastColon = CString_strrchr(buff, &apos;:&apos;);</span><br><span class="line">    char* firstColon = CString_strchr(buff, &apos;:&apos;);</span><br><span class="line">    char* bracket = CString_strchr(buff, &apos;]&apos;);</span><br><span class="line">    if (!lastColon) &#123;</span><br><span class="line">        // ipv4, no port</span><br><span class="line">    &#125; else if (lastColon != firstColon &amp;&amp; (!bracket || lastColon &lt; bracket)) &#123;</span><br><span class="line">        // ipv6, no port</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (bracket &amp;&amp; lastColon != &amp;bracket[1]) &#123; return -1; &#125;</span><br><span class="line">        if (Base10_fromString(&amp;lastColon[1], &amp;port)) &#123; return -1; &#125;</span><br><span class="line">        if (port &gt; 65535) &#123; return -1; &#125;</span><br><span class="line">        *lastColon = &apos;\0&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    if (bracket) &#123;</span><br><span class="line">        *bracket = &apos;\0&apos;;</span><br><span class="line">        if (buff[0] != &apos;[&apos;) &#123; return -1; &#125;</span><br><span class="line">    &#125; else if (buff[0] == &apos;[&apos;) &#123; return -1; &#125;</span><br><span class="line"></span><br><span class="line">    int64_t prefix = -1;</span><br><span class="line">    char* slash = CString_strchr(buff, &apos;/&apos;);</span><br><span class="line">    if (slash) &#123;</span><br><span class="line">        *slash = &apos;\0&apos;;</span><br><span class="line">        if (!slash[1]) &#123; return -1; &#125;</span><br><span class="line">        if (Base10_fromString(&amp;slash[1], &amp;prefix)) &#123; return -1; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Bits_memset(out, 0, sizeof(struct Sockaddr_storage));</span><br><span class="line">    if (lastColon != firstColon) &#123;</span><br><span class="line">        // ipv6</span><br><span class="line">        struct sockaddr_in6* in6 = (struct sockaddr_in6*) Sockaddr_asNative(&amp;out-&gt;addr);</span><br><span class="line">        if (uv_inet_pton(AF_INET6, (char*) ((buff[0] == &apos;[&apos;) ? &amp;buff[1] : buff), &amp;in6-&gt;sin6_addr)) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        out-&gt;addr.addrLen = sizeof(struct sockaddr_in6) + Sockaddr_OVERHEAD;</span><br><span class="line">        in6-&gt;sin6_port = Endian_hostToBigEndian16(port);</span><br><span class="line">        in6-&gt;sin6_family = AF_INET6;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        struct sockaddr_in* in = ((struct sockaddr_in*) Sockaddr_asNative(&amp;out-&gt;addr));</span><br><span class="line">        if (uv_inet_pton(AF_INET, (char*) buff, &amp;in-&gt;sin_addr)) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        out-&gt;addr.addrLen = sizeof(struct sockaddr_in) + Sockaddr_OVERHEAD;</span><br><span class="line">        in-&gt;sin_port = Endian_hostToBigEndian16(port);</span><br><span class="line">        in-&gt;sin_family = AF_INET;</span><br><span class="line">    &#125;</span><br><span class="line">    if (prefix != -1) &#123;</span><br><span class="line">        if (prefix &lt; 0 || prefix &gt; 128) &#123; return -1; &#125;</span><br><span class="line">        if (Sockaddr_getFamily(&amp;out-&gt;addr) == Sockaddr_AF_INET &amp;&amp; prefix &gt; 32) &#123; return -1; &#125;</span><br><span class="line">        out-&gt;addr.prefix = prefix;</span><br><span class="line">        out-&gt;addr.flags |= Sockaddr_flags_PREFIX;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看一下跟prefix相关的代码，基本上可以将prefix理解为掩码的长度。这个变量可以用来判断两个ip地址是否在同一网段，或某个网段是否是另一个网段的子集。</p>
<p>2.RouteGen_addLocalPrefix<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void RouteGen_addLocalPrefix(struct RouteGen* rg, struct Sockaddr* destination)</span><br><span class="line">&#123;</span><br><span class="line">    struct RouteGen_pvt* rp = Identity_check((struct RouteGen_pvt*) rg);</span><br><span class="line">    addSomething(rp, destination, rp-&gt;localPrefixes6, rp-&gt;localPrefixes4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void addSomething(struct RouteGen_pvt* rp,</span><br><span class="line">                         struct Sockaddr* exempt,</span><br><span class="line">                         struct ArrayList_OfPrefix6* list6,</span><br><span class="line">                         struct ArrayList_OfPrefix4* list4)</span><br><span class="line">&#123;</span><br><span class="line">    if (Sockaddr_getFamily(exempt) == Sockaddr_AF_INET) &#123;</span><br><span class="line">        struct Prefix4* p4 = sockaddrToPrefix4(exempt, rp-&gt;alloc);</span><br><span class="line">        ArrayList_OfPrefix4_add(list4, p4);</span><br><span class="line">    &#125; else if (Sockaddr_getFamily(exempt) == Sockaddr_AF_INET6) &#123;</span><br><span class="line">        struct Prefix6* p6 = sockaddrToPrefix6(exempt, rp-&gt;alloc);</span><br><span class="line">        ArrayList_OfPrefix6_add(list6, p6);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Assert_failure(&quot;unexpected addr type&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    rp-&gt;pub.hasUncommittedChanges = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将一些路由信息加入到localPrefixes表中。</p>
<h2 id="RouteGen-commit"><a href="#RouteGen-commit" class="headerlink" title="RouteGen_commit"></a>RouteGen_commit</h2><p>这个函数有两个地方调用：</p>
<ol>
<li>在RouteGen_admin中注册，作为一个外部可直接调用的API，需要传入tunName。目前代码自己运行的逻辑中并未使用这种调用。</li>
<li>在IpTunnel.c的incomingAddresses方法中调用。也就是在普通点收到离岸点分配的ip之后，会调用到该方法。</li>
</ol>
<p>分析一下这个函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void RouteGen_commit(struct RouteGen* rg,</span><br><span class="line">                     const char* tunName,</span><br><span class="line">                     struct Allocator* tempAlloc,</span><br><span class="line">                     struct Except* eh)</span><br><span class="line">&#123;</span><br><span class="line">    struct RouteGen_pvt* rp = Identity_check((struct RouteGen_pvt*) rg);</span><br><span class="line">    struct Prefix46* p46 = getGeneratedRoutes(rp, tempAlloc);</span><br><span class="line">    struct Sockaddr** prefixSet =</span><br><span class="line">        Allocator_calloc(tempAlloc, sizeof(char*), p46-&gt;prefix4-&gt;length + p46-&gt;prefix6-&gt;length);</span><br><span class="line">    int prefixNum = 0;</span><br><span class="line">    for (int i = 0; i &lt; p46-&gt;prefix4-&gt;length; i++) &#123;</span><br><span class="line">        struct Prefix4* pfx4 = ArrayList_OfPrefix4_get(p46-&gt;prefix4, i);</span><br><span class="line">        prefixSet[prefixNum++] = sockaddrForPrefix4(tempAlloc, pfx4);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; p46-&gt;prefix6-&gt;length; i++) &#123;</span><br><span class="line">        struct Prefix6* pfx6 = ArrayList_OfPrefix6_get(p46-&gt;prefix6, i);</span><br><span class="line">        prefixSet[prefixNum++] = sockaddrForPrefix6(tempAlloc, pfx6);</span><br><span class="line">    &#125;</span><br><span class="line">    Assert_true(prefixNum == p46-&gt;prefix4-&gt;length + p46-&gt;prefix6-&gt;length);</span><br><span class="line">    NetDev_setRoutes(tunName, prefixSet, prefixNum, rp-&gt;log, tempAlloc, eh);</span><br><span class="line">    rp-&gt;pub.hasUncommittedChanges = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>依次做了一下操作：</p>
<h3 id="1-getGeneratedRoutes"><a href="#1-getGeneratedRoutes" class="headerlink" title="1. getGeneratedRoutes"></a>1. getGeneratedRoutes</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static struct Prefix46* getGeneratedRoutes(struct RouteGen_pvt* rp, struct Allocator* alloc)</span><br><span class="line">&#123;</span><br><span class="line">    struct Prefix46* out = Allocator_calloc(alloc, sizeof(struct Prefix46), 1);</span><br><span class="line">    if (rp-&gt;prefixes4-&gt;length &gt; 0) &#123;</span><br><span class="line">        out-&gt;prefix4 = genPrefixes4(rp-&gt;prefixes4, rp-&gt;exceptions4, rp-&gt;localPrefixes4, alloc);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        out-&gt;prefix4 = ArrayList_OfPrefix4_new(alloc);</span><br><span class="line">    &#125;</span><br><span class="line">    if (rp-&gt;prefixes6-&gt;length &gt; 0) &#123;</span><br><span class="line">        out-&gt;prefix6 = genPrefixes6(rp-&gt;prefixes6, rp-&gt;exceptions6, rp-&gt;localPrefixes6, alloc);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        out-&gt;prefix6 = ArrayList_OfPrefix6_new(alloc);</span><br><span class="line">    &#125;</span><br><span class="line">    return out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数，针对ipv4和ipv6做了一样的操作：如果prefixes的length&gt;0，调用genPrefixes方法，否则new一个对应的ArrayList。<br>查看一下genPrefixes方法，以genPrefixes4为例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">static struct ArrayList_OfPrefix4* genPrefixes4(struct ArrayList_OfPrefix4* prefixes,</span><br><span class="line">                                                struct ArrayList_OfPrefix4* exceptions,</span><br><span class="line">                                                struct ArrayList_OfPrefix4* localPrefixes,</span><br><span class="line">                                                struct Allocator* alloc)</span><br><span class="line">&#123;</span><br><span class="line">    struct Allocator* tempAlloc = Allocator_child(alloc);</span><br><span class="line"></span><br><span class="line">    struct ArrayList_OfPrefix4* effectiveLocalPrefixes = ArrayList_OfPrefix4_new(tempAlloc);</span><br><span class="line">    for (int i = 0; i &lt; localPrefixes-&gt;length; i++) &#123;</span><br><span class="line">        bool add = true;</span><br><span class="line">        struct Prefix4* localPfx = ArrayList_OfPrefix4_get(localPrefixes, i);</span><br><span class="line">        for (int j = 0; j &lt; prefixes-&gt;length; j++) &#123;</span><br><span class="line">            struct Prefix4* pfx = ArrayList_OfPrefix4_get(prefixes, j);</span><br><span class="line">            if (isSubsetOf4(pfx, localPfx)) &#123;</span><br><span class="line">                add = false;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (add) &#123;</span><br><span class="line">            ArrayList_OfPrefix4_add(effectiveLocalPrefixes, localPfx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct ArrayList_OfPrefix4* allPrefixes = ArrayList_OfPrefix4_new(tempAlloc);</span><br><span class="line">    for (int i = 0; i &lt; exceptions-&gt;length; i++) &#123;</span><br><span class="line">        struct Prefix4* pfxToInvert = ArrayList_OfPrefix4_get(exceptions, i);</span><br><span class="line">        bool add = true;</span><br><span class="line">        for (int j = 0; j &lt; effectiveLocalPrefixes-&gt;length; j++) &#123;</span><br><span class="line">            struct Prefix4* localPfx = ArrayList_OfPrefix4_get(effectiveLocalPrefixes, j);</span><br><span class="line">            if (isSubsetOf4(pfxToInvert, localPfx)) &#123;</span><br><span class="line">                add = false;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (add) &#123;</span><br><span class="line">            struct ArrayList_OfPrefix4* prefixes4 = invertPrefix4(pfxToInvert, tempAlloc);</span><br><span class="line">            mergePrefixSets4(allPrefixes, prefixes4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = allPrefixes-&gt;length - 2; i &gt;= 0; i--) &#123;</span><br><span class="line">        struct Prefix4* pfx = ArrayList_OfPrefix4_get(allPrefixes, i);</span><br><span class="line">        struct Prefix4* pfx2 = ArrayList_OfPrefix4_get(allPrefixes, i+1);</span><br><span class="line">        if (isSubsetOf4(pfx2, pfx)) &#123;</span><br><span class="line">            ArrayList_OfPrefix4_remove(allPrefixes, i+1);</span><br><span class="line">            if (i &lt; (allPrefixes-&gt;length - 2)) &#123; i++; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; prefixes-&gt;length; i++) &#123;</span><br><span class="line">        struct Prefix4* pfx = ArrayList_OfPrefix4_get(prefixes, i);</span><br><span class="line">        int addPrefix = true;</span><br><span class="line">        for (int j = allPrefixes-&gt;length - 1; j &gt;= 0; j--) &#123;</span><br><span class="line">            struct Prefix4* pfx2 = ArrayList_OfPrefix4_get(allPrefixes, j);</span><br><span class="line">            if (isSubsetOf4(pfx2, pfx)) &#123;</span><br><span class="line">                addPrefix = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (addPrefix) &#123;</span><br><span class="line">            ArrayList_OfPrefix4_add(allPrefixes, pfx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ArrayList_OfPrefix4_sort(allPrefixes);</span><br><span class="line"></span><br><span class="line">    struct ArrayList_OfPrefix4* out = ArrayList_OfPrefix4_new(alloc);</span><br><span class="line">    for (int i = 0; i &lt; allPrefixes-&gt;length; i++) &#123;</span><br><span class="line">        struct Prefix4* pfx = ArrayList_OfPrefix4_get(allPrefixes, i);</span><br><span class="line">        for (int j = 0; j &lt; prefixes-&gt;length; j++) &#123;</span><br><span class="line">            struct Prefix4* pfx2 = ArrayList_OfPrefix4_get(prefixes, j);</span><br><span class="line">            if (isSubsetOf4(pfx, pfx2)) &#123;</span><br><span class="line">                ArrayList_OfPrefix4_add(out, clonePrefix4(pfx, alloc));</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Allocator_free(tempAlloc);</span><br><span class="line">    return out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是一个重要的函数，它将prefixes,exceptions,localPrefixes三个ArrayList中的内容进行merge，共同形成一个新的ArrayList.</p>
<h4 id="0-各prefixes的内容"><a href="#0-各prefixes的内容" class="headerlink" title="0. 各prefixes的内容"></a>0. 各prefixes的内容</h4><p>按照程序目前的运行流程，当收到离岸点分配的ipv4地址后，首次调用RouteGen_commit，进而调用到genPrefixes4，此时，三个prefixes中的内容如下：</p>
<ol>
<li><p>rp-&gt;prefixes4 这是自己的ipv4地址，由离岸点分配得到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1467638405 DEBUG RouteGen.c:137 getGeneratedRoutes rp prefixes4</span><br><span class="line">1467638405 DEBUG Prefix.c:112 printprefix 192.168.254.2/0</span><br></pre></td></tr></table></figure>
</li>
<li><p>rp-&gt;localPrefixes4 这是一些local地址，在RouteGen.c中的RouteGen_new函数中，通过调用setupDefaultLocalPrefixes方法来设置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1467638405 DEBUG RouteGen.c:139 getGeneratedRoutes rp localPrefixes4</span><br><span class="line">1467638405 DEBUG Prefix.c:112 printprefix 10.0.0.0/8</span><br><span class="line">1467638405 DEBUG Prefix.c:112 printprefix 172.16.0.0/12</span><br><span class="line">1467638405 DEBUG Prefix.c:112 printprefix 192.168.0.0/16</span><br><span class="line">1467638405 DEBUG Prefix.c:112 printprefix 127.0.0.0/8</span><br></pre></td></tr></table></figure>
</li>
<li><p>rp-&gt;exceptions4 这是接入点的ipv4地址，在Configurator.c文件中，通过调用接口设置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1467638405 DEBUG RouteGen.c:141 getGeneratedRoutes rp exceptions4</span><br><span class="line">1467638405 DEBUG Prefix.c:112 printprefix 106.75.59.53/32</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="1-prefixes和localPrefixes-进行merge"><a href="#1-prefixes和localPrefixes-进行merge" class="headerlink" title="1. prefixes和localPrefixes 进行merge"></a>1. prefixes和localPrefixes 进行merge</h4><p> 先看第一块代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; localPrefixes-&gt;length; i++) &#123;</span><br><span class="line">    bool add = true;</span><br><span class="line">    struct Prefix4* localPfx = ArrayList_OfPrefix4_get(localPrefixes, i);</span><br><span class="line">    for (int j = 0; j &lt; prefixes-&gt;length; j++) &#123;</span><br><span class="line">        struct Prefix4* pfx = ArrayList_OfPrefix4_get(prefixes, j);</span><br><span class="line">        if (isSubsetOf4(pfx, localPfx)) &#123;</span><br><span class="line">            add = false;</span><br><span class="line">            break;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    if (add) &#123;</span><br><span class="line">        ArrayList_OfPrefix4_add(effectiveLocalPrefixes, localPfx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这一块代码，将localPrefixes和prefixes中网段依次取出，放入isSubsetOf4函数中进行检测，如果prefixes中的网段不是localPrefixes中的网段的子集，就将这条从localPrefixes中取出的网段放入effectiveLocalPrefixes中。<br>也就是说，一条localPrefixes中的网段想要被加入effectiveLocalPrefixes中，必须满足条件：在prefixes中没有比它更加精准的网段匹配项，或者说，没有比它范围更小的匹配项。看一下isSubsetOf4的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Prefix4</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t bits;   //addr</span><br><span class="line">    int prefix;</span><br><span class="line">    struct Allocator* alloc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static bool isSubsetOf4(struct Prefix4* isSubset, struct Prefix4* isSuperset)</span><br><span class="line">&#123;</span><br><span class="line">    if (isSuperset-&gt;prefix &gt; isSubset-&gt;prefix) &#123; return false; &#125;</span><br><span class="line">    if (isSuperset-&gt;prefix &gt;= 32) &#123;</span><br><span class="line">        return isSuperset-&gt;bits == isSubset-&gt;bits;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!isSuperset-&gt;prefix) &#123; return true; &#125;</span><br><span class="line">    uint32_t shift = 32 - isSuperset-&gt;prefix;</span><br><span class="line">    return (isSuperset-&gt;bits &gt;&gt; shift) == (isSubset-&gt;bits &gt;&gt; shift);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，主要依靠prefix来判断。</p>
<h4 id="2-与exceptions进行merge"><a href="#2-与exceptions进行merge" class="headerlink" title="2. 与exceptions进行merge"></a>2. 与exceptions进行merge</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> struct ArrayList_OfPrefix4* allPrefixes = ArrayList_OfPrefix4_new(tempAlloc);</span><br><span class="line"> for (int i = 0; i &lt; exceptions-&gt;length; i++) &#123;</span><br><span class="line">     struct Prefix4* pfxToInvert = ArrayList_OfPrefix4_get(exceptions, i);</span><br><span class="line">     bool add = true;</span><br><span class="line">     for (int j = 0; j &lt; effectiveLocalPrefixes-&gt;length; j++) &#123;</span><br><span class="line">         struct Prefix4* localPfx = ArrayList_OfPrefix4_get(effectiveLocalPrefixes, j);</span><br><span class="line">         if (isSubsetOf4(pfxToInvert, localPfx)) &#123;</span><br><span class="line">             add = false;</span><br><span class="line">             break;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     if (add) &#123;</span><br><span class="line">         struct ArrayList_OfPrefix4* prefixes4 = invertPrefix4(pfxToInvert, tempAlloc);</span><br><span class="line">         mergePrefixSets4(allPrefixes, prefixes4);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">for (int i = allPrefixes-&gt;length - 2; i &gt;= 0; i--) &#123;</span><br><span class="line">     struct Prefix4* pfx = ArrayList_OfPrefix4_get(allPrefixes, i);</span><br><span class="line">     struct Prefix4* pfx2 = ArrayList_OfPrefix4_get(allPrefixes, i+1);</span><br><span class="line">     if (isSubsetOf4(pfx2, pfx)) &#123;</span><br><span class="line">         ArrayList_OfPrefix4_remove(allPrefixes, i+1);</span><br><span class="line">         if (i &lt; (allPrefixes-&gt;length - 2)) &#123; i++; &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>首先将exceptions和effectiveLocalPrefixes中的路由记录依次取出，放入isSubsetOf4函数中进行检测，查看exceptions中的项是否是effectiveLocalPrefixes中项的子集。<br>之后，不再是简单的add操作，而是invertPrefix4和mergePrefixSets4。<br>exception操作，是一个排除型操作，当我们往exception列表中加入一个地址时，其实是往路由表中加入掩码长度小于等于这个exception地址掩码长度的所有非此网段的地址。举个栗子：<br>当我们使用RouteGen_addException(‘193.199.1.1/16’)时，其实是向路由表中加入了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">193.198.0.0/16</span><br><span class="line">193.196.0.0/15</span><br><span class="line">193.192.0.0/14</span><br><span class="line">193.200.0.0/13 </span><br><span class="line">193.208.0.0/12 </span><br><span class="line">193.224.0.0/11 </span><br><span class="line">193.128.0.0/10 </span><br><span class="line">193.0.0.0/9 </span><br><span class="line">192.0.0.0/8</span><br><span class="line">194.0.0.0/7 </span><br><span class="line">196.0.0.0/6</span><br><span class="line">200.0.0.0/5 </span><br><span class="line">208.0.0.0/4 </span><br><span class="line">224.0.0.0/3 </span><br><span class="line">128.0.0.0/2</span><br><span class="line">0.0.0.0/1</span><br></pre></td></tr></table></figure></p>
<p>现在来查看执行这个排除操作的函数invertPrefix4<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static struct ArrayList_OfPrefix4* invertPrefix4(struct Prefix4* toInvert, struct Allocator* alloc)</span><br><span class="line">&#123;</span><br><span class="line">    struct ArrayList_OfPrefix4* result = ArrayList_OfPrefix4_new(alloc);</span><br><span class="line">    for (int i = 32 - toInvert-&gt;prefix; i &lt; 32; i++) &#123;</span><br><span class="line">        struct Prefix4* pfx = Allocator_calloc(alloc, sizeof(struct Prefix4), 1);</span><br><span class="line">        pfx-&gt;bits = ( toInvert-&gt;bits &amp; ((uint32_t)~0 &lt;&lt; i) ) ^ (1 &lt;&lt; i);</span><br><span class="line">        pfx-&gt;prefix = 32 - i;</span><br><span class="line">        ArrayList_OfPrefix4_add(result, pfx);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，这个函数是将exceptions之外的网段加result中，result是一个ArrayList。</p>
<p>接下来，将这个result和之前的allPrefixes进行merge。(其实此时，allPrefixes还是空的）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">static void mergePrefixSets4(struct ArrayList_OfPrefix4* mergeInto,</span><br><span class="line">                             struct ArrayList_OfPrefix4* prefixes)</span><br><span class="line">&#123;</span><br><span class="line">    struct Prefix4* highestPrefix = NULL;</span><br><span class="line">    for (int j = 0; j &lt; prefixes-&gt;length; j++) &#123;</span><br><span class="line">        struct Prefix4* result = ArrayList_OfPrefix4_get(prefixes, j);</span><br><span class="line">        Assert_true(result);</span><br><span class="line">        if (!highestPrefix || highestPrefix-&gt;prefix &lt; result-&gt;prefix) &#123;</span><br><span class="line">            highestPrefix = result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct Prefix4 target;</span><br><span class="line">    Bits_memcpy(&amp;target, highestPrefix, sizeof(struct Prefix4));</span><br><span class="line">    target.bits ^= (target.prefix) ? (1 &lt;&lt; (32 - target.prefix)) : 0;</span><br><span class="line">    for (int i = mergeInto-&gt;length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">        struct Prefix4* result = ArrayList_OfPrefix4_get(mergeInto, i);</span><br><span class="line">        Assert_true(result);</span><br><span class="line">        if (isSubsetOf4(&amp;target, result)) &#123;</span><br><span class="line">            ArrayList_OfPrefix4_remove(mergeInto, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; prefixes-&gt;length; i++) &#123;</span><br><span class="line">        bool include = true;</span><br><span class="line">        struct Prefix4* toInclude = ArrayList_OfPrefix4_get(prefixes, i);</span><br><span class="line">        for (int j = 0; j &lt; mergeInto-&gt;length; j++) &#123;</span><br><span class="line">            struct Prefix4* test = ArrayList_OfPrefix4_get(mergeInto, j);</span><br><span class="line">            if (isSubsetOf4(test, toInclude)) &#123;</span><br><span class="line">                include = false;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (include) &#123;</span><br><span class="line">            ArrayList_OfPrefix4_add(mergeInto, toInclude);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至此，localPrefixes和exception进行merge之后的网段都加入到了allPrefixes之中。<br>然后在进行一次排除subset的操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">for (int i = allPrefixes-&gt;length - 2; i &gt;= 0; i--) &#123;</span><br><span class="line">    struct Prefix4* pfx = ArrayList_OfPrefix4_get(allPrefixes, i);</span><br><span class="line">    struct Prefix4* pfx2 = ArrayList_OfPrefix4_get(allPrefixes, i+1);</span><br><span class="line">    if (isSubsetOf4(pfx2, pfx)) &#123;</span><br><span class="line">        ArrayList_OfPrefix4_remove(allPrefixes, i+1);</span><br><span class="line">        if (i &lt; (allPrefixes-&gt;length - 2)) &#123; i++; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-prefixes与allPrefixes进行merge"><a href="#3-prefixes与allPrefixes进行merge" class="headerlink" title="3. prefixes与allPrefixes进行merge"></a>3. prefixes与allPrefixes进行merge</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; prefixes-&gt;length; i++) &#123;</span><br><span class="line">    struct Prefix4* pfx = ArrayList_OfPrefix4_get(prefixes, i);</span><br><span class="line">    int addPrefix = true;</span><br><span class="line">    for (int j = allPrefixes-&gt;length - 1; j &gt;= 0; j--) &#123;</span><br><span class="line">        struct Prefix4* pfx2 = ArrayList_OfPrefix4_get(allPrefixes, j);</span><br><span class="line">        if (isSubsetOf4(pfx2, pfx)) &#123;</span><br><span class="line">            addPrefix = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (addPrefix) &#123;</span><br><span class="line">        ArrayList_OfPrefix4_add(allPrefixes, pfx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ArrayList_OfPrefix4_sort(allPrefixes);</span><br></pre></td></tr></table></figure>
<p>将prefixes加入到allPrefixes，之后还进行了排序。此时，allPrefixes中是localPrefixes,prefixes,exception共同merge后的结果。</p>
<h4 id="4-prefixes和allPrefixes共同生成out"><a href="#4-prefixes和allPrefixes共同生成out" class="headerlink" title="4. prefixes和allPrefixes共同生成out"></a>4. prefixes和allPrefixes共同生成out</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct ArrayList_OfPrefix4* out = ArrayList_OfPrefix4_new(alloc);</span><br><span class="line">for (int i = 0; i &lt; allPrefixes-&gt;length; i++) &#123;</span><br><span class="line">    struct Prefix4* pfx = ArrayList_OfPrefix4_get(allPrefixes, i);</span><br><span class="line">    for (int j = 0; j &lt; prefixes-&gt;length; j++) &#123;</span><br><span class="line">        struct Prefix4* pfx2 = ArrayList_OfPrefix4_get(prefixes, j);</span><br><span class="line">        if (isSubsetOf4(pfx, pfx2)) &#123;</span><br><span class="line">            ArrayList_OfPrefix4_add(out, clonePrefix4(pfx, alloc));</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里不太一样的地方在于，是比较两者，然后取子集加入到out当中。也就是说，out最后回得到一个条目更加精细的集合，该集合综合了prefixes,localPrefixes,exception的记录。</p>
<h3 id="2-把prefixes加入到prefixSet之中"><a href="#2-把prefixes加入到prefixSet之中" class="headerlink" title="2. 把prefixes加入到prefixSet之中"></a>2. 把prefixes加入到prefixSet之中</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct Sockaddr** prefixSet =</span><br><span class="line">        Allocator_calloc(tempAlloc, sizeof(char*), p46-&gt;prefix4-&gt;length + p46-&gt;prefix6-&gt;length);</span><br><span class="line">    int prefixNum = 0;</span><br><span class="line">    for (int i = 0; i &lt; p46-&gt;prefix4-&gt;length; i++) &#123;</span><br><span class="line">        struct Prefix4* pfx4 = ArrayList_OfPrefix4_get(p46-&gt;prefix4, i);</span><br><span class="line">        prefixSet[prefixNum++] = sockaddrForPrefix4(tempAlloc, pfx4);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>将上一步得到的路由信息转成Sockaddr，然后加入到prefixSet当中。</p>
<h3 id="3-NetDev-setRoutes"><a href="#3-NetDev-setRoutes" class="headerlink" title="3. NetDev_setRoutes"></a>3. NetDev_setRoutes</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void NetDev_setRoutes(const char* ifName,</span><br><span class="line">                      struct Sockaddr** prefixSet,</span><br><span class="line">                      int prefixCount,</span><br><span class="line">                      struct Log* logger,</span><br><span class="line">                      struct Allocator* tempAlloc,</span><br><span class="line">                      struct Except* eh)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; prefixCount; i++) &#123;</span><br><span class="line">        struct Allocator* alloc = Allocator_child(tempAlloc);</span><br><span class="line">        int addrFam;</span><br><span class="line">        char* printedAddr;</span><br><span class="line">        void* addr;</span><br><span class="line">        checkAddressAndPrefix(prefixSet[i], &amp;addrFam, &amp;printedAddr, &amp;addr, alloc, eh);</span><br><span class="line">        Allocator_free(alloc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NetPlatform_setRoutes(ifName, prefixSet, prefixCount, logger, tempAlloc, eh);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void NetPlatform_setRoutes(const char* ifName,</span><br><span class="line">                           struct Sockaddr** prefixSet,</span><br><span class="line">                           int prefixCount,</span><br><span class="line">                           struct Log* logger,</span><br><span class="line">                           struct Allocator* tempAlloc,</span><br><span class="line">                           struct Except* eh)</span><br><span class="line">&#123;</span><br><span class="line">    int ifIndex = ifIndexForName(ifName, eh);</span><br><span class="line">    struct RouteInfo* newRi = riForSockaddrs(prefixSet, prefixCount, ifIndex, tempAlloc);</span><br><span class="line">    int sock = mkSocket(tempAlloc, eh);</span><br><span class="line">    struct RouteInfo* oldRi = getRoutes(sock, ifIndex, tempAlloc, eh);</span><br><span class="line">    logRis(oldRi, logger, &quot;DELETE ROUTE&quot;);</span><br><span class="line">    addDeleteRoutes(sock, true, oldRi, tempAlloc, eh);</span><br><span class="line">    logRis(newRi, logger, &quot;ADD ROUTE&quot;);</span><br><span class="line">    addDeleteRoutes(sock, false, newRi, tempAlloc, eh);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际设置路由的过程，在/util/platform/netdev/文件夹下，不做详细分析。</p>
<h2 id="RouteGen-admin"><a href="#RouteGen-admin" class="headerlink" title="RouteGen_admin"></a>RouteGen_admin</h2><p>这个admin文件，写的还是跟别的不太一样的，用到了很多的宏来简化重复代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void RouteGen_admin_register(struct RouteGen* rg, struct Admin* admin, struct Allocator* alloc)</span><br><span class="line">&#123;</span><br><span class="line">    struct RouteGen_admin_Ctx* ctx = Allocator_calloc(alloc, sizeof(struct RouteGen_admin_Ctx), 1);</span><br><span class="line">    ctx-&gt;rg = rg;</span><br><span class="line">    ctx-&gt;admin = admin;</span><br><span class="line">    Identity_set(ctx);</span><br><span class="line"></span><br><span class="line">    REGISTER_GET_SOMETHING(getPrefixes, ctx, admin);</span><br><span class="line">    REGISTER_GET_SOMETHING(getLocalPrefixes, ctx, admin);</span><br><span class="line">    REGISTER_GET_SOMETHING(getExceptions, ctx, admin);</span><br><span class="line">    REGISTER_GET_SOMETHING(getGeneratedRoutes, ctx, admin);</span><br><span class="line"></span><br><span class="line">    REGISTER_ADD_REMOVE_SOMETHING(addException, ctx, admin);</span><br><span class="line">    REGISTER_ADD_REMOVE_SOMETHING(addPrefix, ctx, admin);</span><br><span class="line">    REGISTER_ADD_REMOVE_SOMETHING(addLocalPrefix, ctx, admin);</span><br><span class="line">    REGISTER_ADD_REMOVE_SOMETHING(removePrefix, ctx, admin);</span><br><span class="line">    REGISTER_ADD_REMOVE_SOMETHING(removeLocalPrefix, ctx, admin);</span><br><span class="line">    REGISTER_ADD_REMOVE_SOMETHING(removeException, ctx, admin);</span><br><span class="line"></span><br><span class="line">    Admin_registerFunction(&quot;RouteGen_commit&quot;, commit, ctx, true,</span><br><span class="line">        ((struct Admin_FunctionArg[]) &#123;</span><br><span class="line">            &#123; .name = &quot;tunName&quot;, .required = 1, .type = &quot;String&quot; &#125;,</span><br><span class="line">        &#125;), admin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>除了RouteGen_commit直接写了registerfunction方法，其他都使用了宏定义函数。</p>
<h3 id="REGISTER-GET-SOMETHING"><a href="#REGISTER-GET-SOMETHING" class="headerlink" title="REGISTER_GET_SOMETHING"></a>REGISTER_GET_SOMETHING</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define REGISTER_GET_SOMETHING(_name, ctx, admin) \</span><br><span class="line">    Admin_registerFunction(&quot;RouteGen_&quot; #_name, _name, ctx, true,                                \</span><br><span class="line">        ((struct Admin_FunctionArg[]) &#123;                                                         \</span><br><span class="line">            &#123; .name = &quot;page&quot;, .required = 0, .type = &quot;Int&quot; &#125;,                                   \</span><br><span class="line">            &#123; .name = &quot;ip6&quot;, .required = 0, .type = &quot;Int&quot; &#125;                                     \</span><br><span class="line">        &#125;), admin)</span><br></pre></td></tr></table></figure>
<p>单井号就是将后面的 宏参数 进行字符串操作，就是将后面的参数用双引号引起来。<br>假设name为getGeneratedRoutes，则等同于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Admin_registerFunction(&quot;RouteGen_&quot; &quot;getGeneratedRoutes&quot;, getGeneratedRoutes, ctx, true,                                \</span><br><span class="line">    ((struct Admin_FunctionArg[]) &#123;                                                         \</span><br><span class="line">        &#123; .name = &quot;page&quot;, .required = 0, .type = &quot;Int&quot; &#125;,                                   \</span><br><span class="line">        &#123; .name = &quot;ip6&quot;, .required = 0, .type = &quot;Int&quot; &#125;                                     \</span><br><span class="line">    &#125;), admin)</span><br></pre></td></tr></table></figure></p>
<p>这样，RouteGen_getGeneratedRoutes就被register到getGeneratedRoutes函数上。这一类getxxxx的函数，也使用了宏定义函数，看下这类函数的定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#define GET_SOMETHING(name) \</span><br><span class="line">    static void name(Dict* args, void* vcontext, String* txid, struct Allocator* requestAlloc)  \</span><br><span class="line">    &#123;                                                                                           \</span><br><span class="line">        struct RouteGen_admin_Ctx* ctx = Identity_check((struct RouteGen_admin_Ctx*) vcontext); \</span><br><span class="line">        Dict* genRoutes = RouteGen_ ## name (ctx-&gt;rg, requestAlloc);                            \</span><br><span class="line">        getSomething(args, ctx, txid, requestAlloc, genRoutes);                                 \</span><br><span class="line">    &#125;</span><br><span class="line">GET_SOMETHING(getPrefixes)</span><br><span class="line">GET_SOMETHING(getLocalPrefixes)</span><br><span class="line">GET_SOMETHING(getExceptions)</span><br><span class="line">GET_SOMETHING(getGeneratedRoutes)</span><br></pre></td></tr></table></figure></p>
<p>依然以getGeneratedRoutes为例，得到一个getGeneratedRoutes函数(宏定义函数中的双井号就是用于连接)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static void getGeneratedRoutes(Dict* args, void* vcontext, String* txid, struct Allocator* requestAlloc) </span><br><span class="line">&#123;</span><br><span class="line">    struct RouteGen_admin_Ctx* ctx = Identity_check((struct RouteGen_admin_Ctx*) vcontext); </span><br><span class="line">    Dict* genRoutes = RouteGen_getGeneratedRoutes (ctx-&gt;rg, requestAlloc);                            </span><br><span class="line">    getSomething(args, ctx, txid, requestAlloc, genRoutes);                                 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里用到了两个函数：</p>
<h4 id="RouteGen-getGeneratedRoutes"><a href="#RouteGen-getGeneratedRoutes" class="headerlink" title="RouteGen_getGeneratedRoutes"></a>RouteGen_getGeneratedRoutes</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Dict* RouteGen_getGeneratedRoutes(struct RouteGen* rg, struct Allocator* alloc)</span><br><span class="line">&#123;</span><br><span class="line">    struct RouteGen_pvt* rp = Identity_check((struct RouteGen_pvt*) rg);</span><br><span class="line">    struct Prefix46* p46 = getGeneratedRoutes(rp, alloc);</span><br><span class="line">    return getSomething(rp, alloc, p46-&gt;prefix6, p46-&gt;prefix4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>getGeneratedRoutes(rp, alloc)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static struct Prefix46* getGeneratedRoutes(struct RouteGen_pvt* rp, struct Allocator* alloc)</span><br><span class="line">&#123;</span><br><span class="line">    struct Prefix46* out = Allocator_calloc(alloc, sizeof(struct Prefix46), 1);</span><br><span class="line">    if (rp-&gt;prefixes4-&gt;length &gt; 0) &#123;</span><br><span class="line">        out-&gt;prefix4 = genPrefixes4(rp-&gt;prefixes4, rp-&gt;exceptions4, rp-&gt;localPrefixes4, alloc);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        out-&gt;prefix4 = ArrayList_OfPrefix4_new(alloc);</span><br><span class="line">    &#125;</span><br><span class="line">    if (rp-&gt;prefixes6-&gt;length &gt; 0) &#123;</span><br><span class="line">        out-&gt;prefix6 = genPrefixes6(rp-&gt;prefixes6, rp-&gt;exceptions6, rp-&gt;localPrefixes6, alloc);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        out-&gt;prefix6 = ArrayList_OfPrefix6_new(alloc);</span><br><span class="line">    &#125;</span><br><span class="line">    return out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>上面已经做过分析。</p>
<ol start="2">
<li>getSomething(rp, alloc, p46-&gt;prefix6, p46-&gt;prefix4）<br>注意，这个getSomething是RouteGen.c中的私有方法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static Dict* getSomething(struct RouteGen_pvt* rp,</span><br><span class="line">                          struct Allocator* alloc,</span><br><span class="line">                          struct ArrayList_OfPrefix6* list6,</span><br><span class="line">                          struct ArrayList_OfPrefix4* list4)</span><br><span class="line">&#123;</span><br><span class="line">    ArrayList_OfPrefix6_sort(list6);</span><br><span class="line">    ArrayList_OfPrefix4_sort(list4);</span><br><span class="line">    List* prefixes4 = List_new(alloc);</span><br><span class="line">    for (int i = 0; i &lt; list4-&gt;length; i++) &#123;</span><br><span class="line">        struct Prefix4* pfx4 = ArrayList_OfPrefix4_get(list4, i);</span><br><span class="line">        List_addString(prefixes4, printPrefix4(alloc, pfx4), alloc);</span><br><span class="line">    &#125;</span><br><span class="line">    List* prefixes6 = List_new(alloc);</span><br><span class="line">    for (int i = 0; i &lt; list6-&gt;length; i++) &#123;</span><br><span class="line">        struct Prefix6* pfx6 = ArrayList_OfPrefix6_get(list6, i);</span><br><span class="line">        List_addString(prefixes6, printPrefix6(alloc, pfx6), alloc);</span><br><span class="line">    &#125;</span><br><span class="line">    Dict* out = Dict_new(alloc);</span><br><span class="line">    Dict_putList(out, String_new(&quot;ipv4&quot;, alloc), prefixes4, alloc);</span><br><span class="line">    Dict_putList(out, String_new(&quot;ipv6&quot;, alloc), prefixes6, alloc);</span><br><span class="line">    return out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>out中包括两个Dict，一个记录ipv4，一个记录ipv6</p>
<h4 id="getSomething"><a href="#getSomething" class="headerlink" title="getSomething"></a>getSomething</h4><p>注意，这个getSomething是RouteGen_admin.c中的私有方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">static void getSomething(Dict* args,</span><br><span class="line">                         struct RouteGen_admin_Ctx* ctx,</span><br><span class="line">                         String* txid,</span><br><span class="line">                         struct Allocator* requestAlloc,</span><br><span class="line">                         Dict* genRoutes)</span><br><span class="line">&#123;</span><br><span class="line">    int page = getIntVal(args, String_CONST(&quot;page&quot;));</span><br><span class="line">    List* routes;</span><br><span class="line">    if (getIntVal(args, String_CONST(&quot;ip6&quot;))) &#123;</span><br><span class="line">        routes = Dict_getListC(genRoutes, &quot;ipv6&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        routes = Dict_getListC(genRoutes, &quot;ipv4&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    Assert_true(routes);</span><br><span class="line">    List* outList = List_new(requestAlloc);</span><br><span class="line">    bool more = false;</span><br><span class="line">    for (int i = page * ROUTES_PER_PAGE, j = 0; i &lt; List_size(routes) &amp;&amp; j &lt; ROUTES_PER_PAGE; j++) &#123;</span><br><span class="line">        String* route = List_getString(routes, i);</span><br><span class="line">        Assert_true(route);</span><br><span class="line">        List_addString(outList, route, requestAlloc);</span><br><span class="line">        if (++i &gt;= List_size(routes)) &#123;</span><br><span class="line">            more = false;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        more = true;</span><br><span class="line">    &#125;</span><br><span class="line">    Dict* out = Dict_new(requestAlloc);</span><br><span class="line">    if (more) &#123;</span><br><span class="line">        Dict_putInt(out, String_new(&quot;more&quot;, requestAlloc), 1, requestAlloc);</span><br><span class="line">    &#125;</span><br><span class="line">    Dict_putList(out, String_new(&quot;routes&quot;, requestAlloc), outList, requestAlloc);</span><br><span class="line">    Admin_sendMessage(out, txid, ctx-&gt;admin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里主要是根据请求中带的是ip6还是ip4来区分需要返回哪一组数据。</p>
<h3 id="REGISTER-ADD-REMOVE-SOMETHING"><a href="#REGISTER-ADD-REMOVE-SOMETHING" class="headerlink" title="REGISTER_ADD_REMOVE_SOMETHING"></a>REGISTER_ADD_REMOVE_SOMETHING</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">enum addRemoveSomething_What &#123;</span><br><span class="line">    addRemoveSomething_What_ADD_EXCEPTION,</span><br><span class="line">    addRemoveSomething_What_RM_EXCEPTION,</span><br><span class="line">    addRemoveSomething_What_ADD_PREFIX,</span><br><span class="line">    addRemoveSomething_What_RM_PREFIX,</span><br><span class="line">    addRemoveSomething_What_ADD_LOCALPREFIX,</span><br><span class="line">    addRemoveSomething_What_RM_LOCALPREFIX,</span><br><span class="line">&#125;;</span><br><span class="line">static void addRemoveSomething(Dict* args,</span><br><span class="line">                               void* vcontext,</span><br><span class="line">                               String* txid,</span><br><span class="line">                               struct Allocator* requestAlloc,</span><br><span class="line">                               enum addRemoveSomething_What what)</span><br><span class="line">&#123;</span><br><span class="line">    struct RouteGen_admin_Ctx* ctx = Identity_check((struct RouteGen_admin_Ctx*) vcontext);</span><br><span class="line">    String* route = Dict_getStringC(args, &quot;route&quot;);</span><br><span class="line">    char* error = NULL;</span><br><span class="line"></span><br><span class="line">    struct Sockaddr_storage ss;</span><br><span class="line">    if (route-&gt;len &gt; 63) &#123;</span><br><span class="line">        error = &quot;parse_failed&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!error) &#123;</span><br><span class="line">        if (Sockaddr_parse(route-&gt;bytes, &amp;ss)) &#123;</span><br><span class="line">            error = &quot;parse_failed&quot;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            int family = Sockaddr_getFamily(&amp;ss.addr);</span><br><span class="line">            if (family != Sockaddr_AF_INET &amp;&amp; family != Sockaddr_AF_INET6) &#123;</span><br><span class="line">                error = &quot;unexpected_af&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int retVal = -1;</span><br><span class="line">    Dict* out = Dict_new(requestAlloc);</span><br><span class="line">    if (!error) &#123;</span><br><span class="line">        switch (what) &#123;</span><br><span class="line">            case addRemoveSomething_What_ADD_EXCEPTION:</span><br><span class="line">                RouteGen_addException(ctx-&gt;rg, &amp;ss.addr); break;</span><br><span class="line">            case addRemoveSomething_What_ADD_PREFIX:</span><br><span class="line">                RouteGen_addPrefix(ctx-&gt;rg, &amp;ss.addr); break;</span><br><span class="line">            case addRemoveSomething_What_ADD_LOCALPREFIX:</span><br><span class="line">                RouteGen_addLocalPrefix(ctx-&gt;rg, &amp;ss.addr); break;</span><br><span class="line">            case addRemoveSomething_What_RM_EXCEPTION:</span><br><span class="line">                retVal = RouteGen_removeException(ctx-&gt;rg, &amp;ss.addr); break;</span><br><span class="line">            case addRemoveSomething_What_RM_PREFIX:</span><br><span class="line">                retVal = RouteGen_removePrefix(ctx-&gt;rg, &amp;ss.addr); break;</span><br><span class="line">            case addRemoveSomething_What_RM_LOCALPREFIX:</span><br><span class="line">                retVal = RouteGen_removeLocalPrefix(ctx-&gt;rg, &amp;ss.addr); break;</span><br><span class="line">            default: Assert_failure(&quot;invalid op&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (!retVal) &#123;</span><br><span class="line">            error = &quot;no_such_route&quot;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            error = &quot;none&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Dict_putString(out,</span><br><span class="line">                   String_new(&quot;error&quot;, requestAlloc),</span><br><span class="line">                   String_new(error, requestAlloc),</span><br><span class="line">                   requestAlloc);</span><br><span class="line">    Admin_sendMessage(out, txid, ctx-&gt;admin);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#define ADD_REMOVE_SOMETHING(name, op) \</span><br><span class="line">    static void name(Dict* args, void* vcontext, String* txid, struct Allocator* requestAlloc)  \</span><br><span class="line">    &#123;                                                                                           \</span><br><span class="line">        addRemoveSomething(args, vcontext, txid, requestAlloc, op);                             \</span><br><span class="line">    &#125;</span><br><span class="line">ADD_REMOVE_SOMETHING(addException, addRemoveSomething_What_ADD_EXCEPTION)</span><br><span class="line">ADD_REMOVE_SOMETHING(addPrefix, addRemoveSomething_What_ADD_PREFIX)</span><br><span class="line">ADD_REMOVE_SOMETHING(addLocalPrefix, addRemoveSomething_What_ADD_LOCALPREFIX)</span><br><span class="line">ADD_REMOVE_SOMETHING(removePrefix, addRemoveSomething_What_RM_PREFIX)</span><br><span class="line">ADD_REMOVE_SOMETHING(removeLocalPrefix, addRemoveSomething_What_RM_LOCALPREFIX)</span><br><span class="line">ADD_REMOVE_SOMETHING(removeException, addRemoveSomething_What_RM_EXCEPTION)</span><br><span class="line">#define REGISTER_ADD_REMOVE_SOMETHING(_name, ctx, admin) \</span><br><span class="line">    Admin_registerFunction(&quot;RouteGen_&quot; #_name, _name, ctx, true,                                \</span><br><span class="line">        ((struct Admin_FunctionArg[]) &#123;                                                         \</span><br><span class="line">            &#123; .name = &quot;route&quot;, .required = 1, .type = &quot;String&quot; &#125;,                               \</span><br><span class="line">        &#125;), admin)</span><br></pre></td></tr></table></figure>
<p>相比GET系列，ADD_REMOVE系列简单很多。以RouteGen_addException为例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static void addSomething(struct RouteGen_pvt* rp,</span><br><span class="line">                         struct Sockaddr* exempt,</span><br><span class="line">                         struct ArrayList_OfPrefix6* list6,</span><br><span class="line">                         struct ArrayList_OfPrefix4* list4)</span><br><span class="line">&#123;</span><br><span class="line">    if (Sockaddr_getFamily(exempt) == Sockaddr_AF_INET) &#123;</span><br><span class="line">        struct Prefix4* p4 = sockaddrToPrefix4(exempt, rp-&gt;alloc);</span><br><span class="line">        ArrayList_OfPrefix4_add(list4, p4);</span><br><span class="line">    &#125; else if (Sockaddr_getFamily(exempt) == Sockaddr_AF_INET6) &#123;</span><br><span class="line">        struct Prefix6* p6 = sockaddrToPrefix6(exempt, rp-&gt;alloc);</span><br><span class="line">        ArrayList_OfPrefix6_add(list6, p6);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Assert_failure(&quot;unexpected addr type&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    rp-&gt;pub.hasUncommittedChanges = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void RouteGen_addException(struct RouteGen* rg, struct Sockaddr* destination)</span><br><span class="line">&#123;</span><br><span class="line">    struct RouteGen_pvt* rp = Identity_check((struct RouteGen_pvt*) rg);</span><br><span class="line">    addSomething(rp, destination, rp-&gt;exceptions6, rp-&gt;exceptions4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>几乎不需要分析。</p>
<h2 id="源码中对这几个ArrayList的操作"><a href="#源码中对这几个ArrayList的操作" class="headerlink" title="源码中对这几个ArrayList的操作"></a>源码中对这几个ArrayList的操作</h2><ol>
<li><p>IpTunnel.c的addAddress中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bool installRoute = false;</span><br><span class="line">if (Sockaddr_getFamily(&amp;ss.addr) == Sockaddr_AF_INET) &#123;</span><br><span class="line">    installRoute = (prefixLen &lt; 32);</span><br><span class="line">&#125; else if (Sockaddr_getFamily(&amp;ss.addr) == Sockaddr_AF_INET6) &#123;</span><br><span class="line">    installRoute = (prefixLen &lt; 128);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    Assert_failure(&quot;bad address family&quot;);</span><br><span class="line">&#125;</span><br><span class="line">if (installRoute) &#123;</span><br><span class="line">    RouteGen_addPrefix(ctx-&gt;rg, &amp;ss.addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>RouteGen_new中调用setupDefaultLocalPrefixes</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static void setupDefaultLocalPrefixes(struct RouteGen_pvt* rp)</span><br><span class="line">&#123;</span><br><span class="line">    struct Sockaddr_storage ss;</span><br><span class="line">    #define ADD_PREFIX(str) \</span><br><span class="line">        Assert_true(!Sockaddr_parse(str, &amp;ss));       \</span><br><span class="line">        RouteGen_addLocalPrefix(&amp;rp-&gt;pub, &amp;ss.addr)</span><br><span class="line"></span><br><span class="line">    ADD_PREFIX(&quot;fe80::/10&quot;);</span><br><span class="line">    ADD_PREFIX(&quot;fd00::/8&quot;);</span><br><span class="line"></span><br><span class="line">    ADD_PREFIX(&quot;10.0.0.0/8&quot;);</span><br><span class="line">    ADD_PREFIX(&quot;172.16.0.0/12&quot;);</span><br><span class="line">    ADD_PREFIX(&quot;192.168.0.0/16&quot;);</span><br><span class="line">    ADD_PREFIX(&quot;127.0.0.0/8&quot;);</span><br><span class="line"></span><br><span class="line">    #undef ADD_PREFIX</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Configurator.c中设置exception<br>解析conf文件中关于设置inbound的配置。配置中包括inbound的ipv4地址，调用’RouteGen_addException’，将这个地址添加到exception当中。<br>conf文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;connectTo&quot;:&#123;</span><br><span class="line">	&quot;106.75.59.53:50001&quot;:&#123;</span><br><span class="line">    	&quot;password&quot;:&quot;XRuMWpgvNienefc7ZT8gXTuTCvSWWSA&quot;,</span><br><span class="line">    	&quot;publicKey&quot;:&quot;nsn1nz93lztkg6zbw4yqnr6zlzxhchppzdkduwh9wh79p88fwx60.k&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>Configurator.c中对conf的解析操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">Dict* connectTo = Dict_getDictC(udp, &quot;connectTo&quot;);</span><br><span class="line">if (connectTo) &#123;</span><br><span class="line">    struct Dict_Entry* entry = *connectTo;</span><br><span class="line">    struct Allocator* perCallAlloc = Allocator_child(ctx-&gt;alloc);</span><br><span class="line">    while (entry != NULL) &#123;</span><br><span class="line">        String* key = (String*) entry-&gt;key;</span><br><span class="line">        if (entry-&gt;val-&gt;type != Object_DICT) &#123;</span><br><span class="line">            Log_critical(ctx-&gt;logger, &quot;interfaces.UDPInterface.connectTo: entry [%s] &quot;</span><br><span class="line">                                       &quot;is not a dictionary type.&quot;, key-&gt;bytes);</span><br><span class="line">            exit(-1);</span><br><span class="line">        &#125;</span><br><span class="line">        Dict* value = entry-&gt;val-&gt;as.dictionary;</span><br><span class="line">        Log_keys(ctx-&gt;logger, &quot;Attempting to connect to node [%s].&quot;, key-&gt;bytes);</span><br><span class="line">        key = String_clone(key, perCallAlloc);</span><br><span class="line">        char* lastColon = CString_strrchr(key-&gt;bytes, &apos;:&apos;);</span><br><span class="line"></span><br><span class="line">        if (lastColon) &#123;</span><br><span class="line">            if (!Sockaddr_parse(key-&gt;bytes, NULL)) &#123;</span><br><span class="line">                // it&apos;s a sockaddr, fall through</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // try it as a hostname.</span><br><span class="line">                Log_critical(ctx-&gt;logger, &quot;Couldn&apos;t add connection [%s], &quot;</span><br><span class="line">                                            &quot;hostnames aren&apos;t supported.&quot;, key-&gt;bytes);</span><br><span class="line">                exit(-1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // it doesn&apos;t have a port</span><br><span class="line">            Log_critical(ctx-&gt;logger, &quot;Connection [%s] must be $IP:$PORT, or &quot;</span><br><span class="line">                                        &quot;[$IP]:$PORT for IPv6.&quot;, key-&gt;bytes);</span><br><span class="line">            exit(-1);</span><br><span class="line">        &#125;</span><br><span class="line">        Dict_putIntC(value, &quot;interfaceNumber&quot;, ifNum, perCallAlloc);</span><br><span class="line">        Dict_putStringC(value, &quot;address&quot;, key, perCallAlloc);</span><br><span class="line">        rpcCall(String_CONST(&quot;UDPInterface_beginConnection&quot;), value, ctx, perCallAlloc);</span><br><span class="line"></span><br><span class="line">        // Make a IPTunnel exception for this node</span><br><span class="line">        Dict* aed = Dict_new(perCallAlloc);</span><br><span class="line">        *lastColon = &apos;\0&apos;;</span><br><span class="line">        Dict_putStringC(aed, &quot;route&quot;, String_new(key-&gt;bytes, perCallAlloc),</span><br><span class="line">            perCallAlloc);</span><br><span class="line">        *lastColon = &apos;:&apos;;</span><br><span class="line">        rpcCall(String_CONST(&quot;RouteGen_addException&quot;), aed, ctx, perCallAlloc);</span><br><span class="line"></span><br><span class="line">        entry = entry-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    Allocator_free(perCallAlloc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C-C/" rel="tag"># C/C++</a>
          
            <a href="/tags/cjdns/" rel="tag"># cjdns</a>
          
            <a href="/tags/cjdns源码分析/" rel="tag"># cjdns源码分析</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/07/25/cjdns_IpTunnel/" rel="next" title="cjdns源码分析--IpTunnel">
                <i class="fa fa-chevron-left"></i> cjdns源码分析--IpTunnel
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/08/25/rom7.0-build/" rel="prev" title="Android7.0Rom编译相关">
                Android7.0Rom编译相关 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Chris King</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">73</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">23</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">27</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#源码分析"><span class="nav-number">1.</span> <span class="nav-text">源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#结构体"><span class="nav-number">1.1.</span> <span class="nav-text">结构体</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RouteGen-new"><span class="nav-number">1.2.</span> <span class="nav-text">RouteGen_new</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RouteGen-commit"><span class="nav-number">1.3.</span> <span class="nav-text">RouteGen_commit</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-getGeneratedRoutes"><span class="nav-number">1.3.1.</span> <span class="nav-text">1. getGeneratedRoutes</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#0-各prefixes的内容"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">0. 各prefixes的内容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-prefixes和localPrefixes-进行merge"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">1. prefixes和localPrefixes 进行merge</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-与exceptions进行merge"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">2. 与exceptions进行merge</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-prefixes与allPrefixes进行merge"><span class="nav-number">1.3.1.4.</span> <span class="nav-text">3. prefixes与allPrefixes进行merge</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-prefixes和allPrefixes共同生成out"><span class="nav-number">1.3.1.5.</span> <span class="nav-text">4. prefixes和allPrefixes共同生成out</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-把prefixes加入到prefixSet之中"><span class="nav-number">1.3.2.</span> <span class="nav-text">2. 把prefixes加入到prefixSet之中</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-NetDev-setRoutes"><span class="nav-number">1.3.3.</span> <span class="nav-text">3. NetDev_setRoutes</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RouteGen-admin"><span class="nav-number">1.4.</span> <span class="nav-text">RouteGen_admin</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#REGISTER-GET-SOMETHING"><span class="nav-number">1.4.1.</span> <span class="nav-text">REGISTER_GET_SOMETHING</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RouteGen-getGeneratedRoutes"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">RouteGen_getGeneratedRoutes</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#getSomething"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">getSomething</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#REGISTER-ADD-REMOVE-SOMETHING"><span class="nav-number">1.4.2.</span> <span class="nav-text">REGISTER_ADD_REMOVE_SOMETHING</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#源码中对这几个ArrayList的操作"><span class="nav-number">1.5.</span> <span class="nav-text">源码中对这几个ArrayList的操作</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chris King</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.0.1</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/schemes/muse.js?v=7.0.1"></script>



  
  <script src="/js/src/scrollspy.js?v=7.0.1"></script>
<script src="/js/src/post-details.js?v=7.0.1"></script>



  


  <script src="/js/src/next-boot.js?v=7.0.1"></script>


  

  

  

  


  


  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
