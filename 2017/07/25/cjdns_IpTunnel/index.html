<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>cjdns源码分析--IpTunnel | IChrisKing</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="“IpTunnel中主要是和离岸点相关的代码。结合最近的需求，分析一下源码，设计一下需求的实现方案”">
<meta name="keywords" content="cjdns,cjdns源码分析,C&#x2F;C++">
<meta property="og:type" content="article">
<meta property="og:title" content="cjdns源码分析--IpTunnel">
<meta property="og:url" content="http://yoursite.com/2017/07/25/cjdns_IpTunnel/index.html">
<meta property="og:site_name" content="IChrisKing">
<meta property="og:description" content="“IpTunnel中主要是和离岸点相关的代码。结合最近的需求，分析一下源码，设计一下需求的实现方案”">
<meta property="og:locale" content="zh-Hant-TW">
<meta property="og:updated_time" content="2018-02-28T05:58:55.153Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="cjdns源码分析--IpTunnel">
<meta name="twitter:description" content="“IpTunnel中主要是和离岸点相关的代码。结合最近的需求，分析一下源码，设计一下需求的实现方案”">
  
    <link rel="alternate" href="/atom.xml" title="IChrisKing" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">IChrisKing</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">#IMNOTCHRISLEE</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-cjdns_IpTunnel" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/25/cjdns_IpTunnel/" class="article-date">
  <time datetime="2017-07-25T01:48:00.000Z" itemprop="datePublished">2017-07-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/cjdns-cjdns源码分析/">cjdns - cjdns源码分析</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      cjdns源码分析--IpTunnel
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>首先看一下IpTunnel的结构体定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">struct IpTunnel</div><div class="line">&#123;</div><div class="line">    /** The interface used to send and receive messages to the TUN device. */</div><div class="line">    struct Iface tunInterface;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * The interface used to send and receive messages to other nodes.</div><div class="line">     * All messages sent on this interface shall be preceeded with the RouterHeader and DataHeader.</div><div class="line">     */</div><div class="line">    struct Iface nodeInterface;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * The list of registered connections, do not modify manually.</div><div class="line">     * Will be reorganized from time to time so pointers are ephemeral.</div><div class="line">     */</div><div class="line">    struct &#123;</div><div class="line">        uint32_t count;</div><div class="line">        struct IpTunnel_Connection* connections;</div><div class="line">    &#125; connectionList;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>两个Iface，一个负责跟tun设备沟通，一个负责跟其他node沟通<br>一个connectionList，保存现有的所有connection。</p>
<p>然后看一下IpTunnel_Connection的结构体定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">struct IpTunnel_Connection</div><div class="line">&#123;</div><div class="line">    /** The header for routing to this node. */</div><div class="line">    struct RouteHeader routeHeader;</div><div class="line"></div><div class="line">    /** The IPv6 address used for this connection or all zeros if none was assigned. */</div><div class="line">    uint8_t connectionIp6[16];</div><div class="line"></div><div class="line">    /** The IPv4 address used for this connection or all zeros if none was assigned. */</div><div class="line">    uint8_t connectionIp4[4];</div><div class="line"></div><div class="line">    /** The IPv6 netmask/prefix length, in bits. Defaults to 128 if none was assigned. */</div><div class="line">    uint8_t connectionIp6Prefix;</div><div class="line"></div><div class="line">    /** The IPv6 prefix length in, in bits, defining netmask. 0xff if not used. */</div><div class="line">    uint8_t connectionIp6Alloc;</div><div class="line"></div><div class="line">    /** The IPv4 address prefix length, in bits. Defaults to 32 if none was assigned. */</div><div class="line">    uint8_t connectionIp4Prefix;</div><div class="line"></div><div class="line">    /** The IPv6 prefix length in, in bits, defining netmask. 0xff if not used. */</div><div class="line">    uint8_t connectionIp4Alloc;</div><div class="line"></div><div class="line">    /** non-zero if the connection was made using IpTunnel_connectTo(). */</div><div class="line">    int isOutgoing : 1;</div><div class="line"></div><div class="line">    /** The number of the connection so it can be identified when removing. */</div><div class="line">    int number : 31;</div><div class="line"></div><div class="line">    bool reachable;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p> 这个结构体记录的是当前点与其他node的连接信息。对于普通的点来说，这里保存着与离岸点的连接信息。每个在conf中定义的离岸点（outgoingConnections），对应着这里的一个IpTunnel_Connection对象，且该对象的isOutgoing字段为1，表明这是一个与离岸点的连接。对于离岸点来说，这里保存着所有连接到该离岸点的连接信息。每个在conf中定义的允许连接的点（allowedConnections），对应着这里的一个IpTunnel_Connection对象，且该对向的isOutgoing字段为0，表明这不是一个向离岸点的连接。</p>
<p>结构体中还有六个与ip相关的字段，3个ip4，3个ipv6，根据需要，使用其中3个。这些ip字段，记录着该连接中，非离岸点的ip信息。</p>
<p>结构体中的routeHeader字段，记录着去往对方的路由信息。</p>
<h3 id="conf文件起到的作用"><a href="#conf文件起到的作用" class="headerlink" title="conf文件起到的作用"></a>conf文件起到的作用</h3><p>有两种途径来新建一个IpTunnel_Connection。</p>
<ol>
<li><p>作为普通点，建立一个与离岸点的IpTunnel_Connection<br>对应着conf文件中的outgoingConnections配置，调用到IpTunnel_admin中的connectTo方法，继而调用到IpTunnel中的IpTunnel_connectTo方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&quot;outgoingConnections&quot;:[</div><div class="line">	&quot;wfzyzrc0q4g83y0dgzxx1l862u0lscucj75yw9q1ymbltzwh2fq0.k&quot;</div><div class="line">]</div></pre></td></tr></table></figure>
</li>
<li><p>作为离岸点，为每个允许连接过来的普通点建立一个IpTunnel_Connection，对应着conf文件中的allowedConnections配置，调用到IpTunnel_admin中的allowConnection方法，继而调用到IpTunnel中的IpTunnel_allowConnection方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&quot;allowedConnections&quot;: [</div><div class="line">        &#123;</div><div class="line">            &quot;ip4Address&quot;: &quot;192.168.254.2&quot;,</div><div class="line">            &quot;ip4Prefix&quot;: 0,</div><div class="line">            &quot;ip4Alloc&quot;: 32,</div><div class="line">            &quot;publicKey&quot;: &quot;uhmhts49tdm1ryb3q0pw95291uwt4xgvyk5s84vt2z2mnv3zp230.k&quot;</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            &quot;ip4Address&quot;: &quot;192.168.254.3&quot;,</div><div class="line">            &quot;ip4Prefix&quot;: 0,</div><div class="line">            &quot;ip4Alloc&quot;: 32,</div><div class="line">            &quot;publicKey&quot;: &quot;9c3x7hp181dv91tfkbngyhhu2uc3xhxuuh539l3g0gdjgjg1bs10.k&quot;</div><div class="line">        &#125;</div><div class="line">]</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="普通点建立一个离岸点的IpTunnel-Connection"><a href="#普通点建立一个离岸点的IpTunnel-Connection" class="headerlink" title="普通点建立一个离岸点的IpTunnel_Connection"></a>普通点建立一个离岸点的IpTunnel_Connection</h3><h4 id="conf文件配置"><a href="#conf文件配置" class="headerlink" title="conf文件配置"></a>conf文件配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&quot;outgoingConnections&quot;:[</div><div class="line">	&quot;wfzyzrc0q4g83y0dgzxx1l862u0lscucj75yw9q1ymbltzwh2fq0.k&quot;</div><div class="line">]</div></pre></td></tr></table></figure>
<h4 id="读取配置文件"><a href="#读取配置文件" class="headerlink" title="读取配置文件"></a>读取配置文件</h4><p>Configurator.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">List* outgoing = Dict_getListC(ifaceConf, &quot;outgoingConnections&quot;);</div><div class="line">if (outgoing) &#123;</div><div class="line">    String* s;</div><div class="line">    for (int i = 0; (s = List_getString(outgoing, i)) != NULL; i++) &#123;</div><div class="line">        Log_debug(ctx-&gt;logger, &quot;Initiating IpTunnel connection to [%s]&quot;, s-&gt;bytes);</div><div class="line">        Dict requestDict =</div><div class="line">            Dict_CONST(String_CONST(&quot;publicKeyOfNodeToConnectTo&quot;), String_OBJ(s), NULL);</div><div class="line">        Dict* resp = NULL;</div><div class="line">        rpcCall0(String_CONST(&quot;IpTunnel_connectTo&quot;), &amp;requestDict, ctx, tempAlloc, &amp;resp, true);</div><div class="line">        int64_t* num = Dict_getIntC(resp, &quot;connection&quot;);</div><div class="line">        Log_debug(ctx-&gt;logger,&quot;noti outgoing callback %d&quot;,(int)*num);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>读取配置文件中outgoingConnections中的离岸点pubkey信息，rpcall调用IpTunnel_connectTo方法。</p>
<h4 id="IpTunnel-connectTo方法"><a href="#IpTunnel-connectTo方法" class="headerlink" title="IpTunnel_connectTo方法"></a>IpTunnel_connectTo方法</h4><p>IpTunnel_admin.c<br>该方法在文件中注册为connectTo函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">static void connectTo(Dict* args, void* vcontext, String* txid, struct Allocator* requestAlloc)</div><div class="line">&#123;</div><div class="line">    struct Context* context = vcontext;</div><div class="line">    String* publicKeyOfNodeToConnectTo =</div><div class="line">        Dict_getStringC(args, &quot;publicKeyOfNodeToConnectTo&quot;);</div><div class="line"></div><div class="line">    uint8_t pubKey[32];</div><div class="line">    uint8_t ip6[16];</div><div class="line">    int ret;</div><div class="line">    if ((ret = Key_parse(publicKeyOfNodeToConnectTo, pubKey, ip6)) != 0) &#123;</div><div class="line">        sendError(Key_parse_strerror(ret), txid, context-&gt;admin);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    int conn = IpTunnel_connectTo(pubKey, context-&gt;ipTun);</div><div class="line">    sendResponse(conn, txid, context-&gt;admin);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>解析离岸点的pubkey，验证其合法性，调用IpTunnel_connectTo方法，建立IpTunnel_Connection。</p>
<h4 id="IpTunnel-connectTo方法-1"><a href="#IpTunnel-connectTo方法-1" class="headerlink" title="IpTunnel_connectTo方法"></a>IpTunnel_connectTo方法</h4><p>IpTunnel.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">int IpTunnel_connectTo(uint8_t publicKeyOfNodeToConnectTo[32], struct IpTunnel* tunnel)</div><div class="line">&#123;</div><div class="line">    struct IpTunnel_pvt* context = Identity_check((struct IpTunnel_pvt*)tunnel);</div><div class="line">    Log_debug(context-&gt;logger, &quot;noti outgoing call by IpTunnel_connectTo&quot;);</div><div class="line">    struct IpTunnel_Connection* conn = newConnection(true, context);</div><div class="line">    Bits_memcpy(conn-&gt;routeHeader.publicKey, publicKeyOfNodeToConnectTo, 32);</div><div class="line">    AddressCalc_addressForPublicKey(conn-&gt;routeHeader.ip6, publicKeyOfNodeToConnectTo);</div><div class="line"></div><div class="line">    if (Defined(Log_DEBUG)) &#123;</div><div class="line">        uint8_t addr[40];</div><div class="line">        AddrTools_printIp(addr, conn-&gt;routeHeader.ip6);</div><div class="line">        Log_debug(context-&gt;logger, &quot;Trying to connect to [%s]&quot;, addr);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    requestAddresses(conn, context);</div><div class="line">    return conn-&gt;number;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里主要有两个操作：</p>
<ol>
<li>调用newConnection(true, context)创建一个IpTunnel_Connection类型的conn，并将conf配置中的离岸点pubkey赋值给conn-&gt;routeHeader.publicKey。</li>
<li>调用requestAddresses方法，向离岸点申请ipv4地址。</li>
</ol>
<h4 id="创建一个IpTunnel-Connection类型的conn"><a href="#创建一个IpTunnel-Connection类型的conn" class="headerlink" title="创建一个IpTunnel_Connection类型的conn"></a>创建一个IpTunnel_Connection类型的conn</h4><p>调用newConnection方法。<br>IpTunnel.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">static struct IpTunnel_Connection* newConnection(bool isOutgoing, struct IpTunnel_pvt* context)</div><div class="line">&#123;</div><div class="line">    if (context-&gt;pub.connectionList.count == context-&gt;connectionCapacity) &#123;</div><div class="line">        uint32_t newSize = (context-&gt;connectionCapacity + 4) * sizeof(struct IpTunnel_Connection);</div><div class="line">        context-&gt;pub.connectionList.connections =</div><div class="line">            Allocator_realloc(context-&gt;allocator, context-&gt;pub.connectionList.connections, newSize);</div><div class="line">        context-&gt;connectionCapacity += 4;</div><div class="line">    &#125;</div><div class="line">    struct IpTunnel_Connection* conn =</div><div class="line">        &amp;context-&gt;pub.connectionList.connections[context-&gt;pub.connectionList.count];</div><div class="line"></div><div class="line">    // If it&apos;s an incoming connection, it must be lower on the list than any outgoing connections.</div><div class="line">    if (!isOutgoing) &#123;</div><div class="line">        for (int i = (int)context-&gt;pub.connectionList.count - 1; i &gt;= 0; i--) &#123;</div><div class="line">            if (!context-&gt;pub.connectionList.connections[i].isOutgoing</div><div class="line">                &amp;&amp; conn != &amp;context-&gt;pub.connectionList.connections[i + 1])</div><div class="line">            &#123;</div><div class="line">                Bits_memcpy(conn,</div><div class="line">                                 &amp;context-&gt;pub.connectionList.connections[i + 1],</div><div class="line">                                 sizeof(struct IpTunnel_Connection));</div><div class="line">                conn = &amp;context-&gt;pub.connectionList.connections[i + 1];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    context-&gt;pub.connectionList.count++;</div><div class="line"></div><div class="line">    Bits_memset(conn, 0, sizeof(struct IpTunnel_Connection));</div><div class="line">    conn-&gt;number = context-&gt;nextConnectionNumber++;</div><div class="line">    conn-&gt;isOutgoing = isOutgoing;</div><div class="line">    conn-&gt;reachable = false;</div><div class="line"></div><div class="line">    // if there are 2 billion calls, die.</div><div class="line">    Assert_true(context-&gt;nextConnectionNumber &lt; (UINT32_MAX &gt;&gt; 1));</div><div class="line"></div><div class="line">    return conn;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第一个参数指定了是否为离岸点，其他部分没什么特别，普通的赋值操作。</p>
<h4 id="向离岸点申请ipv4地址"><a href="#向离岸点申请ipv4地址" class="headerlink" title="向离岸点申请ipv4地址"></a>向离岸点申请ipv4地址</h4><p>调用requestAddresses方法<br>IpTunnel.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">static void requestAddresses(struct IpTunnel_Connection* conn, struct IpTunnel_pvt* context)</div><div class="line">&#123;</div><div class="line">    if (Defined(Log_DEBUG)) &#123;</div><div class="line">        uint8_t addr[40];</div><div class="line">        AddrTools_printIp(addr, conn-&gt;routeHeader.ip6);</div><div class="line">        Log_debug(context-&gt;logger, &quot;Requesting addresses from [%s] for connection [%d]&quot;,</div><div class="line">                  addr, conn-&gt;number);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    int number = conn-&gt;number;</div><div class="line">    Dict d = Dict_CONST(</div><div class="line">        String_CONST(&quot;q&quot;), String_OBJ(String_CONST(&quot;IpTunnel_getAddresses&quot;)), Dict_CONST(</div><div class="line">        String_CONST(&quot;txid&quot;), String_OBJ((&amp;(String)&#123; .len = 4, .bytes = (char*)&amp;number &#125;)),</div><div class="line">        NULL</div><div class="line">    ));</div><div class="line">    struct Allocator* msgAlloc = Allocator_child(context-&gt;allocator);</div><div class="line">    sendControlMessage(&amp;d, conn, msgAlloc, context);</div><div class="line">    Allocator_free(msgAlloc);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Dict中放入key为q，value为IpTunnel_getAddresses的键值对，调用sendControlMessage方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">static void sendControlMessage(Dict* dict,</div><div class="line">                               struct IpTunnel_Connection* connection,</div><div class="line">                               struct Allocator* requestAlloc,</div><div class="line">                               struct IpTunnel_pvt* context)</div><div class="line">&#123;</div><div class="line">    struct Message* msg = Message_new(0, 1024, requestAlloc);</div><div class="line">    BencMessageWriter_write(dict, msg, NULL);</div><div class="line"></div><div class="line">    int length = msg-&gt;length;</div><div class="line"></div><div class="line">    // do UDP header.</div><div class="line">    Message_shift(msg, Headers_UDPHeader_SIZE, NULL);</div><div class="line">    struct Headers_UDPHeader* uh = (struct Headers_UDPHeader*) msg-&gt;bytes;</div><div class="line">    uh-&gt;srcPort_be = 0;</div><div class="line">    uh-&gt;destPort_be = 0;</div><div class="line">    uh-&gt;length_be = Endian_hostToBigEndian16(length);</div><div class="line">    uh-&gt;checksum_be = 0;</div><div class="line"></div><div class="line">    uint16_t payloadLength = msg-&gt;length;</div><div class="line"></div><div class="line">    Message_shift(msg, Headers_IP6Header_SIZE, NULL);</div><div class="line">    struct Headers_IP6Header* header = (struct Headers_IP6Header*) msg-&gt;bytes;</div><div class="line">    header-&gt;versionClassAndFlowLabel = 0;</div><div class="line">    header-&gt;flowLabelLow_be = 0;</div><div class="line">    header-&gt;nextHeader = 17;</div><div class="line">    header-&gt;hopLimit = 0;</div><div class="line">    header-&gt;payloadLength_be = Endian_hostToBigEndian16(payloadLength);</div><div class="line">    Headers_setIpVersion(header);</div><div class="line"></div><div class="line">    // zero the source and dest addresses.</div><div class="line">    Bits_memset(header-&gt;sourceAddr, 0, 32);</div><div class="line"></div><div class="line">    uh-&gt;checksum_be = Checksum_udpIp6(header-&gt;sourceAddr,</div><div class="line">                                      (uint8_t*) uh,</div><div class="line">                                      msg-&gt;length - Headers_IP6Header_SIZE);</div><div class="line"></div><div class="line">    Iface_CALL(sendToNode, msg, connection, context);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一些初始化操作，然后Iface_CALL调用sendToNode方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">static Iface_DEFUN sendToNode(struct Message* message,</div><div class="line">                              struct IpTunnel_Connection* connection,</div><div class="line">                              struct IpTunnel_pvt* context)</div><div class="line">&#123;</div><div class="line">    Message_push(message, NULL, DataHeader_SIZE, NULL);</div><div class="line">    struct DataHeader* dh = (struct DataHeader*) message-&gt;bytes;</div><div class="line">    DataHeader_setContentType(dh, ContentType_IPTUN);</div><div class="line">    DataHeader_setVersion(dh, DataHeader_CURRENT_VERSION);</div><div class="line">    Message_push(message, &amp;connection-&gt;routeHeader, RouteHeader_SIZE, NULL);</div><div class="line">    return Iface_next(&amp;context-&gt;pub.nodeInterface, message);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>设置了ContentType和Version，调用Message_push方法调整消息内容。最后调用 Iface_next(&amp;context-&gt;pub.nodeInterface, message)方法，将消息发出去。<br>此处的context-&gt;pub.nodeInterface是一个Iface，它的回调函数在IpTunnel_new方法中，被设为incomingFromNode。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">      .pub = &#123;</div><div class="line">..........</div><div class="line">          .nodeInterface = &#123; .send = incomingFromNode &#125;</div><div class="line">      &#125;,</div></pre></td></tr></table></figure></p>
<p>它的connectedIf在Core.c的Core_init方法中通过Iface_plumb方法与nc-&gt;upper-&gt;ipTunnelIf绑定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Iface_plumb(&amp;nc-&gt;upper-&gt;ipTunnelIf, &amp;ipTunnel-&gt;nodeInterface);</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">static inline void Iface_plumb(struct Iface* a, struct Iface* b)</div><div class="line">&#123;</div><div class="line">    Assert_true(!a-&gt;connectedIf);</div><div class="line">    Assert_true(!b-&gt;connectedIf);</div><div class="line">    a-&gt;connectedIf = b;</div><div class="line">    b-&gt;connectedIf = a;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="收到离岸点分配的ipv4地址"><a href="#收到离岸点分配的ipv4地址" class="headerlink" title="收到离岸点分配的ipv4地址"></a>收到离岸点分配的ipv4地址</h4><p>上面讲到，回调函数被设为incomingFromNode，所以，所有从其他点发送过来，进入IpTunnel的数据，都先到incomingFromNode方法中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">static Iface_DEFUN incomingFromNode(struct Message* message, struct Iface* nodeIf)</div><div class="line">&#123;</div><div class="line">    struct IpTunnel_pvt* context =</div><div class="line">        Identity_containerOf(nodeIf, struct IpTunnel_pvt, pub.nodeInterface);</div><div class="line"></div><div class="line">    //Log_debug(context-&gt;logger, &quot;Got incoming message&quot;);</div><div class="line"></div><div class="line">    Assert_true(message-&gt;length &gt;= RouteHeader_SIZE + DataHeader_SIZE);</div><div class="line">    struct RouteHeader* rh = (struct RouteHeader*) message-&gt;bytes;</div><div class="line">    struct DataHeader* dh = (struct DataHeader*) &amp;rh[1];</div><div class="line">    Assert_true(DataHeader_getContentType(dh) == ContentType_IPTUN);</div><div class="line">    struct IpTunnel_Connection* conn = connectionByPubKey(rh-&gt;publicKey, context);</div><div class="line">    if (!conn) &#123;</div><div class="line">        if (Defined(Log_DEBUG)) &#123;</div><div class="line">            uint8_t addr[40];</div><div class="line">            AddrTools_printIp(addr, rh-&gt;ip6);</div><div class="line">            Log_debug(context-&gt;logger, &quot;Got message from unrecognized node [%s]&quot;, addr);</div><div class="line">        &#125;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Message_shift(message, -(RouteHeader_SIZE + DataHeader_SIZE), NULL);</div><div class="line"></div><div class="line">    if (message-&gt;length &gt; 40 &amp;&amp; Headers_getIpVersion(message-&gt;bytes) == 6) &#123;</div><div class="line">        return ip6FromNode(message, conn, context);</div><div class="line">    &#125;</div><div class="line">    if (message-&gt;length &gt; 20 &amp;&amp; Headers_getIpVersion(message-&gt;bytes) == 4) &#123;</div><div class="line">        return ip4FromNode(message, conn, context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (Defined(Log_DEBUG)) &#123;</div><div class="line">        uint8_t addr[40];</div><div class="line">        AddrTools_printIp(addr, rh-&gt;ip6);</div><div class="line">        Log_debug(context-&gt;logger,</div><div class="line">                  &quot;Got message of unknown type, length: [%d], IP version [%d] from [%s]&quot;,</div><div class="line">                  message-&gt;length,</div><div class="line">                  (message-&gt;length &gt; 1) ? Headers_getIpVersion(message-&gt;bytes) : 0,</div><div class="line">                  addr);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li><p>通过publicKey找到对应的conn，也就是离岸点的conn。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">struct IpTunnel_Connection* conn = connectionByPubKey(rh-&gt;publicKey, context);</div></pre></td></tr></table></figure>
</li>
<li><p>调用ip6FromNode</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (message-&gt;length &gt; 40 &amp;&amp; Headers_getIpVersion(message-&gt;bytes) == 6) &#123;</div><div class="line">    return ip6FromNode(message, conn, context);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">static Iface_DEFUN ip6FromNode(struct Message* message,</div><div class="line">                               struct IpTunnel_Connection* conn,</div><div class="line">                               struct IpTunnel_pvt* context)</div><div class="line">&#123;</div><div class="line">    struct Headers_IP6Header* header = (struct Headers_IP6Header*) message-&gt;bytes;</div><div class="line">    if (Bits_isZero(header-&gt;sourceAddr, 16) || Bits_isZero(header-&gt;destinationAddr, 16)) &#123;</div><div class="line">        if (Bits_isZero(header-&gt;sourceAddr, 32)) &#123;</div><div class="line">            return incomingControlMessage(message, conn, context);</div><div class="line">        &#125;</div><div class="line">        ......</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    if (!isValidAddress6(header-&gt;sourceAddr, false, conn)) &#123;</div><div class="line">        ......</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">    return Iface_next(&amp;context-&gt;pub.tunInterface, message);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此时header-&gt;sourceAddr为全0，会调用到incomingControlMessage方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">static Iface_DEFUN incomingControlMessage(struct Message* message,</div><div class="line">                                          struct IpTunnel_Connection* conn,</div><div class="line">                                          struct IpTunnel_pvt* context)</div><div class="line">&#123;</div><div class="line">    ......</div><div class="line"></div><div class="line">    struct Allocator* alloc = Allocator_child(message-&gt;alloc);</div><div class="line"></div><div class="line">    Dict* d = NULL;</div><div class="line"></div><div class="line">    if (Dict_getDictC(d, &quot;addresses&quot;)) &#123;</div><div class="line">        return incomingAddresses(d, conn, alloc, context);</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用到incomingAddresses</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">static Iface_DEFUN incomingAddresses(Dict* d,</div><div class="line">                                     struct IpTunnel_Connection* conn,</div><div class="line">                                     struct Allocator* alloc,</div><div class="line">                                     struct IpTunnel_pvt* context)</div><div class="line">&#123;</div><div class="line">      //一些数据合法性判断</div><div class="line"></div><div class="line">    Dict* addresses = Dict_getDictC(d, &quot;addresses&quot;);</div><div class="line"></div><div class="line">    String* ip4 = Dict_getStringC(addresses, &quot;ip4&quot;);</div><div class="line">    int64_t* ip4Prefix = Dict_getIntC(addresses, &quot;ip4Prefix&quot;);</div><div class="line">    int64_t* ip4Alloc = Dict_getIntC(addresses, &quot;ip4Alloc&quot;);</div><div class="line"></div><div class="line">    if (ip4 &amp;&amp; ip4-&gt;len == 4) &#123;</div><div class="line">        Bits_memcpy(conn-&gt;connectionIp4, ip4-&gt;bytes, 4);</div><div class="line"></div><div class="line">        if (ip4Prefix &amp;&amp; *ip4Prefix &gt;= 0 &amp;&amp; *ip4Prefix &lt;= 32) &#123;</div><div class="line">            conn-&gt;connectionIp4Prefix = (uint8_t) *ip4Prefix;</div><div class="line">        &#125; else &#123;</div><div class="line">            conn-&gt;connectionIp4Prefix = 32;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (ip4Alloc &amp;&amp; *ip4Alloc &gt;= 0 &amp;&amp; *ip4Alloc &lt;= 32) &#123;</div><div class="line">            conn-&gt;connectionIp4Alloc = (uint8_t) *ip4Alloc;</div><div class="line">        &#125; else &#123;</div><div class="line">            conn-&gt;connectionIp4Alloc = 32;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        struct Sockaddr* sa = Sockaddr_clone(Sockaddr_LOOPBACK, alloc);</div><div class="line">        uint8_t* addrBytes = NULL;</div><div class="line">        Sockaddr_getAddress(sa, &amp;addrBytes);</div><div class="line">        Bits_memcpy(addrBytes, ip4-&gt;bytes, 4);</div><div class="line">        char* printedAddr = Sockaddr_print(sa, alloc);</div><div class="line"></div><div class="line">        Log_info(context-&gt;logger, &quot;Got issued address [%s/%d:%d] for connection [%d]&quot;,</div><div class="line">                 printedAddr, conn-&gt;connectionIp4Alloc, conn-&gt;connectionIp4Prefix, conn-&gt;number);</div><div class="line"></div><div class="line">        addAddress(printedAddr, conn-&gt;connectionIp4Prefix, conn-&gt;connectionIp4Alloc, context);</div><div class="line">        Notification_doNotify_af(context-&gt;notification,</div><div class="line">                OUTGOING_REACHABLE,REACHABLE,Ethernet_TYPE_IP4);</div><div class="line">        conn-&gt;reachable = true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //与ipv4类似的，ipv6的处理。不做具体分析。</div><div class="line">    </div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从消息中取出ipv4相关的三个字段，这是离岸点分配给当前点的ipv4地址相关信息。设置conn中相关字段的内容。然后调用addAddress方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">static void addAddress(char* printedAddr, uint8_t prefixLen,</div><div class="line">                       uint8_t allocSize, struct IpTunnel_pvt* ctx)</div><div class="line">&#123;</div><div class="line">    struct Sockaddr_storage ss;</div><div class="line">    if (Sockaddr_parse(printedAddr, &amp;ss)) &#123;</div><div class="line">        Log_error(ctx-&gt;logger, &quot;Invalid ip, setting ip address on TUN&quot;);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    ss.addr.flags |= Sockaddr_flags_PREFIX;</div><div class="line">    ss.addr.prefix = prefixLen;</div><div class="line"></div><div class="line">    bool installRoute = false;</div><div class="line">    if (Sockaddr_getFamily(&amp;ss.addr) == Sockaddr_AF_INET) &#123;</div><div class="line">        installRoute = (prefixLen &lt; 32);</div><div class="line">    &#125; else if (Sockaddr_getFamily(&amp;ss.addr) == Sockaddr_AF_INET6) &#123;</div><div class="line">        installRoute = (prefixLen &lt; 128);</div><div class="line">    &#125; else &#123;</div><div class="line">        Assert_failure(&quot;bad address family&quot;);</div><div class="line">    &#125;</div><div class="line">    if (installRoute) &#123;</div><div class="line">        RouteGen_addPrefix(ctx-&gt;rg, &amp;ss.addr);</div><div class="line">    &#125;</div><div class="line">    if (!ctx-&gt;ifName) &#123;</div><div class="line">        Log_error(ctx-&gt;logger, &quot;Failed to set IP address because TUN interface is not setup&quot;);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ss.addr.prefix = allocSize;</div><div class="line">    struct Jmp j;</div><div class="line">    Jmp_try(j) &#123;</div><div class="line">        NetDev_addAddress(ctx-&gt;ifName-&gt;bytes, &amp;ss.addr, ctx-&gt;logger, &amp;j.handler);</div><div class="line">    &#125; Jmp_catch &#123;</div><div class="line">        Log_error(ctx-&gt;logger, &quot;Error setting ip address on TUN [%s]&quot;, j.message);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里主要调用了两个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">RouteGen_addPrefix(ctx-&gt;rg, &amp;ss.addr);</div><div class="line">NetDev_addAddress(ctx-&gt;ifName-&gt;bytes, &amp;ss.addr, ctx-&gt;logger, &amp;j.handler);</div></pre></td></tr></table></figure></p>
<p>已经不是IpTunnel范围内的代码了，具体内容不分析了。<br>至此，向离岸点申请ipv4，收到回复后设置ipv4的过程就结束了。</p>
<h3 id="离岸点为每个允许连接过来的普通点建立一个IpTunnel-Connection"><a href="#离岸点为每个允许连接过来的普通点建立一个IpTunnel-Connection" class="headerlink" title="离岸点为每个允许连接过来的普通点建立一个IpTunnel_Connection"></a>离岸点为每个允许连接过来的普通点建立一个IpTunnel_Connection</h3><h4 id="conf文件配置-1"><a href="#conf文件配置-1" class="headerlink" title="conf文件配置"></a>conf文件配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&quot;allowedConnections&quot;: [</div><div class="line">        &#123;</div><div class="line">            &quot;ip4Address&quot;: &quot;192.168.254.2&quot;,</div><div class="line">            &quot;ip4Prefix&quot;: 0,</div><div class="line">            &quot;ip4Alloc&quot;: 32,</div><div class="line">            &quot;publicKey&quot;: &quot;uhmhts49tdm1ryb3q0pw95291uwt4xgvyk5s84vt2z2mnv3zp230.k&quot;</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            &quot;ip4Address&quot;: &quot;192.168.254.3&quot;,</div><div class="line">            &quot;ip4Prefix&quot;: 0,</div><div class="line">            &quot;ip4Alloc&quot;: 32,</div><div class="line">            &quot;publicKey&quot;: &quot;9c3x7hp181dv91tfkbngyhhu2uc3xhxuuh539l3g0gdjgjg1bs10.k&quot;</div><div class="line">        &#125;</div><div class="line">]</div></pre></td></tr></table></figure>
<h4 id="读取配置文件-1"><a href="#读取配置文件-1" class="headerlink" title="读取配置文件"></a>读取配置文件</h4><p>Configurator.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">List* incoming = Dict_getListC(ifaceConf, &quot;allowedConnections&quot;);</div><div class="line">if (incoming) &#123;</div><div class="line">    Dict* d;</div><div class="line">    for (int i = 0; (d = List_getDict(incoming, i)) != NULL; i++) &#123;</div><div class="line">        String* key = Dict_getStringC(d, &quot;publicKey&quot;);</div><div class="line">        String* ip4 = Dict_getStringC(d, &quot;ip4Address&quot;);</div><div class="line">        // Note that the prefix length has to be a proper int in the config</div><div class="line">        // (not quoted!)</div><div class="line">        int64_t* ip4Prefix = Dict_getIntC(d, &quot;ip4Prefix&quot;);</div><div class="line">        String* ip6 = Dict_getStringC(d, &quot;ip6Address&quot;);</div><div class="line">        int64_t* ip6Prefix = Dict_getIntC(d, &quot;ip6Prefix&quot;);</div><div class="line">        if (!key) &#123;</div><div class="line">            Log_critical(ctx-&gt;logger, &quot;In router.ipTunnel.allowedConnections[%d]&quot;</div><div class="line">                                      &quot;&apos;publicKey&apos; required.&quot;, i);</div><div class="line">            exit(1);</div><div class="line">        &#125;</div><div class="line">        if (!ip4 &amp;&amp; !ip6) &#123;</div><div class="line">            Log_critical(ctx-&gt;logger, &quot;In router.ipTunnel.allowedConnections[%d]&quot;</div><div class="line">                                      &quot;either &apos;ip4Address&apos; or &apos;ip6Address&apos; required.&quot;, i);</div><div class="line">            exit(1);</div><div class="line">        &#125; else if (ip4Prefix &amp;&amp; !ip4) &#123;</div><div class="line">            Log_critical(ctx-&gt;logger, &quot;In router.ipTunnel.allowedConnections[%d]&quot;</div><div class="line">                                      &quot;&apos;ip4Address&apos; required with &apos;ip4Prefix&apos;.&quot;, i);</div><div class="line">            exit(1);</div><div class="line">        &#125; else if (ip6Prefix &amp;&amp; !ip6) &#123;</div><div class="line">            Log_critical(ctx-&gt;logger, &quot;In router.ipTunnel.allowedConnections[%d]&quot;</div><div class="line">                                      &quot;&apos;ip6Address&apos; required with &apos;ip6Prefix&apos;.&quot;, i);</div><div class="line">            exit(1);</div><div class="line">        &#125;</div><div class="line">        Log_debug(ctx-&gt;logger, &quot;Allowing IpTunnel connections from [%s]&quot;, key-&gt;bytes);</div><div class="line"></div><div class="line">        if (ip4) &#123;</div><div class="line">            Log_debug(ctx-&gt;logger, &quot;Issue IPv4 address %s&quot;, ip4-&gt;bytes);</div><div class="line">            if (ip4Prefix) &#123;</div><div class="line">                Log_debug(ctx-&gt;logger, &quot;Issue IPv4 netmask/prefix length /%d&quot;,</div><div class="line">                    (int) *ip4Prefix);</div><div class="line">            &#125; else &#123;</div><div class="line">                Log_debug(ctx-&gt;logger, &quot;Use default netmask/prefix length /0&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (ip6) &#123;</div><div class="line">            Log_debug(ctx-&gt;logger, &quot;Issue IPv6 address [%s]&quot;, ip6-&gt;bytes);</div><div class="line">            if (ip6Prefix) &#123;</div><div class="line">                Log_debug(ctx-&gt;logger, &quot;Issue IPv6 netmask/prefix length /%d&quot;,</div><div class="line">                    (int) *ip6Prefix);</div><div class="line">            &#125; else &#123;</div><div class="line">                Log_debug(ctx-&gt;logger, &quot;Use default netmask/prefix length /0&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Dict_putStringC(d, &quot;publicKeyOfAuthorizedNode&quot;, key, tempAlloc);</div><div class="line">        rpcCall0(String_CONST(&quot;IpTunnel_allowConnection&quot;), d, ctx, tempAlloc, NULL, true);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>读取配置文件中allowedConnections中各个点的相关信息，rpcall调用IpTunnel_allowConnection方法。</p>
<h4 id="IpTunnel-allowConnection方法"><a href="#IpTunnel-allowConnection方法" class="headerlink" title="IpTunnel_allowConnection方法"></a>IpTunnel_allowConnection方法</h4><p>IpTunnel_admin.c<br>该方法在文件中注册为allowConnection函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">static void allowConnection(Dict* args,</div><div class="line">                            void* vcontext,</div><div class="line">                            String* txid,</div><div class="line">                            struct Allocator* requestAlloc)</div><div class="line">&#123;</div><div class="line">    struct Context* context = (struct Context*) vcontext;</div><div class="line">    String* publicKeyOfAuthorizedNode =</div><div class="line">        Dict_getStringC(args, &quot;publicKeyOfAuthorizedNode&quot;);</div><div class="line">    String* ip6Address = Dict_getStringC(args, &quot;ip6Address&quot;);</div><div class="line">    int64_t* ip6Prefix = Dict_getIntC(args, &quot;ip6Prefix&quot;);</div><div class="line">    int64_t* ip6Alloc = Dict_getIntC(args, &quot;ip6Alloc&quot;);</div><div class="line">    String* ip4Address = Dict_getStringC(args, &quot;ip4Address&quot;);</div><div class="line">    int64_t* ip4Prefix = Dict_getIntC(args, &quot;ip4Prefix&quot;);</div><div class="line">    int64_t* ip4Alloc = Dict_getIntC(args, &quot;ip4Alloc&quot;);</div><div class="line"></div><div class="line">    uint8_t pubKey[32];</div><div class="line">    uint8_t ip6Addr[16];</div><div class="line"></div><div class="line">    struct Sockaddr_storage ip6ToGive;</div><div class="line">    struct Sockaddr_storage ip4ToGive;</div><div class="line"></div><div class="line">    char* error;</div><div class="line">    int ret;</div><div class="line">    if (!ip6Address &amp;&amp; !ip4Address) &#123;</div><div class="line">        error = &quot;Must specify ip6Address or ip4Address&quot;;</div><div class="line">    &#125; else if ((ret = Key_parse(publicKeyOfAuthorizedNode, pubKey, ip6Addr)) != 0) &#123;</div><div class="line">        error = Key_parse_strerror(ret);</div><div class="line"></div><div class="line">    &#125; else if (ip6Prefix &amp;&amp; !ip6Address) &#123;</div><div class="line">        error = &quot;Must specify ip6Address with ip6Prefix&quot;;</div><div class="line">    &#125; else if (ip6Alloc &amp;&amp; !ip6Address) &#123;</div><div class="line">        error = &quot;Must specify ip6Address with ip6Alloc&quot;;</div><div class="line">    &#125; else if (ip6Prefix &amp;&amp; (*ip6Prefix &gt; 128 || *ip6Prefix &lt; 0)) &#123;</div><div class="line">        error = &quot;ip6Prefix out of range: must be 0 to 128&quot;;</div><div class="line">    &#125; else if (ip6Alloc &amp;&amp; (*ip6Alloc &gt; 128 || *ip6Alloc &lt; 1)) &#123;</div><div class="line">        error = &quot;ip6Alloc out of range: must be 1 to 128&quot;;</div><div class="line"></div><div class="line">    &#125; else if (ip4Prefix &amp;&amp; !ip4Address) &#123;</div><div class="line">        error = &quot;Must specify ip4Address with ip4Prefix&quot;;</div><div class="line">    &#125; else if (ip4Alloc &amp;&amp; !ip4Address) &#123;</div><div class="line">        error = &quot;Must specify ip4Address with ip4Alloc&quot;;</div><div class="line">    &#125; else if (ip4Prefix &amp;&amp; (*ip4Prefix &gt; 32 || *ip4Prefix &lt; 0)) &#123;</div><div class="line">        error = &quot;ip4Prefix out of range: must be 0 to 32&quot;;</div><div class="line">    &#125; else if (ip4Alloc &amp;&amp; (*ip4Alloc &gt; 32 || *ip4Alloc &lt; 1)) &#123;</div><div class="line">        error = &quot;ip4Alloc out of range: must be 1 to 32&quot;;</div><div class="line"></div><div class="line">    &#125; else if (ip6Address</div><div class="line">        &amp;&amp; (Sockaddr_parse(ip6Address-&gt;bytes, &amp;ip6ToGive)</div><div class="line">            || Sockaddr_getFamily(&amp;ip6ToGive.addr) != Sockaddr_AF_INET6))</div><div class="line">    &#123;</div><div class="line">        error = &quot;malformed ip6Address&quot;;</div><div class="line">    &#125; else if (ip4Address</div><div class="line">        &amp;&amp; (Sockaddr_parse(ip4Address-&gt;bytes, &amp;ip4ToGive)</div><div class="line">            || Sockaddr_getFamily(&amp;ip4ToGive.addr) != Sockaddr_AF_INET))</div><div class="line">    &#123;</div><div class="line">        error = &quot;malformed ip4Address&quot;;</div><div class="line">    &#125; else &#123;</div><div class="line">        int conn = IpTunnel_allowConnection(pubKey,</div><div class="line">                                            (ip6Address) ? &amp;ip6ToGive.addr : NULL,</div><div class="line">                                            (ip6Prefix) ? (uint8_t) (*ip6Prefix) : 128,</div><div class="line">                                            (ip6Alloc) ? (uint8_t) (*ip6Alloc) : 128,</div><div class="line">                                            (ip4Address) ? &amp;ip4ToGive.addr : NULL,</div><div class="line">                                            (ip4Prefix) ? (uint8_t) (*ip4Prefix) : 32,</div><div class="line">                                            (ip4Alloc) ? (uint8_t) (*ip4Alloc) : 32,</div><div class="line">                                            context-&gt;ipTun);</div><div class="line">        sendResponse(conn, txid, context-&gt;admin);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    sendError(error, txid, context-&gt;admin);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>获取conf中该连接的相关信息，验证其合法性，调用IpTunnel_allowConnection方法，建立IpTunnel_Connection。</p>
<h4 id="IpTunnel-allowConnection方法-1"><a href="#IpTunnel-allowConnection方法-1" class="headerlink" title="IpTunnel_allowConnection方法"></a>IpTunnel_allowConnection方法</h4><p>IpTunnel.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">int IpTunnel_allowConnection(uint8_t publicKeyOfAuthorizedNode[32],</div><div class="line">                             struct Sockaddr* ip6Addr,</div><div class="line">                             uint8_t ip6Prefix,</div><div class="line">                             uint8_t ip6Alloc,</div><div class="line">                             struct Sockaddr* ip4Addr,</div><div class="line">                             uint8_t ip4Prefix,</div><div class="line">                             uint8_t ip4Alloc,</div><div class="line">                             struct IpTunnel* tunnel)</div><div class="line">&#123;</div><div class="line">    struct IpTunnel_pvt* context = Identity_check((struct IpTunnel_pvt*)tunnel);</div><div class="line"></div><div class="line">    Log_debug(context-&gt;logger, &quot;IPv4 Prefix to allow: %d&quot;, ip4Prefix);</div><div class="line"></div><div class="line">    uint8_t* ip6Address = NULL;</div><div class="line">    uint8_t* ip4Address = NULL;</div><div class="line">    if (ip6Addr) &#123;</div><div class="line">        Sockaddr_getAddress(ip6Addr, &amp;ip6Address);</div><div class="line">    &#125;</div><div class="line">    if (ip4Addr) &#123;</div><div class="line">        Sockaddr_getAddress(ip4Addr, &amp;ip4Address);</div><div class="line">    &#125;</div><div class="line">    Log_debug(context-&gt;logger, &quot;noti outgoing call by IpTunnel_allowConnection&quot;);</div><div class="line">    struct IpTunnel_Connection* conn = newConnection(false, context);</div><div class="line">    Bits_memcpy(conn-&gt;routeHeader.publicKey, publicKeyOfAuthorizedNode, 32);</div><div class="line">    AddressCalc_addressForPublicKey(conn-&gt;routeHeader.ip6, publicKeyOfAuthorizedNode);</div><div class="line">    if (ip4Address) &#123;</div><div class="line">        Bits_memcpy(conn-&gt;connectionIp4, ip4Address, 4);</div><div class="line">        conn-&gt;connectionIp4Prefix = ip4Prefix;</div><div class="line">        conn-&gt;connectionIp4Alloc = ip4Alloc;</div><div class="line">        Assert_true(ip4Alloc);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (ip6Address) &#123;</div><div class="line">        Bits_memcpy(conn-&gt;connectionIp6, ip6Address, 16);</div><div class="line">        conn-&gt;connectionIp6Prefix = ip6Prefix;</div><div class="line">        conn-&gt;connectionIp6Alloc = ip6Alloc;</div><div class="line">        Assert_true(ip6Alloc);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return conn-&gt;number;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里主要三个操作：</p>
<ol>
<li>调用newConnection(true, context)创建一个IpTunnel_Connection类型的conn。</li>
<li>将conf配置中的publicKey信息赋值给conn-&gt;routeHeader.publicKey</li>
<li>将conf配置中的ip相关信息赋值给conn相关字段 </li>
</ol>
<h4 id="创建一个IpTunnel-Connection类型的conn-1"><a href="#创建一个IpTunnel-Connection类型的conn-1" class="headerlink" title="创建一个IpTunnel_Connection类型的conn"></a>创建一个IpTunnel_Connection类型的conn</h4><p>调用newConnection方法。<br>IpTunnel.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">static struct IpTunnel_Connection* newConnection(bool isOutgoing, struct IpTunnel_pvt* context)</div><div class="line">&#123;</div><div class="line">    if (context-&gt;pub.connectionList.count == context-&gt;connectionCapacity) &#123;</div><div class="line">        uint32_t newSize = (context-&gt;connectionCapacity + 4) * sizeof(struct IpTunnel_Connection);</div><div class="line">        context-&gt;pub.connectionList.connections =</div><div class="line">            Allocator_realloc(context-&gt;allocator, context-&gt;pub.connectionList.connections, newSize);</div><div class="line">        context-&gt;connectionCapacity += 4;</div><div class="line">    &#125;</div><div class="line">    struct IpTunnel_Connection* conn =</div><div class="line">        &amp;context-&gt;pub.connectionList.connections[context-&gt;pub.connectionList.count];</div><div class="line"></div><div class="line">    // If it&apos;s an incoming connection, it must be lower on the list than any outgoing connections.</div><div class="line">    if (!isOutgoing) &#123;</div><div class="line">        for (int i = (int)context-&gt;pub.connectionList.count - 1; i &gt;= 0; i--) &#123;</div><div class="line">            if (!context-&gt;pub.connectionList.connections[i].isOutgoing</div><div class="line">                &amp;&amp; conn != &amp;context-&gt;pub.connectionList.connections[i + 1])</div><div class="line">            &#123;</div><div class="line">                Bits_memcpy(conn,</div><div class="line">                                 &amp;context-&gt;pub.connectionList.connections[i + 1],</div><div class="line">                                 sizeof(struct IpTunnel_Connection));</div><div class="line">                conn = &amp;context-&gt;pub.connectionList.connections[i + 1];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    context-&gt;pub.connectionList.count++;</div><div class="line"></div><div class="line">    Bits_memset(conn, 0, sizeof(struct IpTunnel_Connection));</div><div class="line">    conn-&gt;number = context-&gt;nextConnectionNumber++;</div><div class="line">    conn-&gt;isOutgoing = isOutgoing;</div><div class="line">    conn-&gt;reachable = false;</div><div class="line"></div><div class="line">    // if there are 2 billion calls, die.</div><div class="line">    Assert_true(context-&gt;nextConnectionNumber &lt; (UINT32_MAX &gt;&gt; 1));</div><div class="line"></div><div class="line">    return conn;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第一个参数指定了是否为离岸点，其他部分没什么特别，普通的赋值操作。</p>
<h4 id="收到其他点发送来的分配地址的请求"><a href="#收到其他点发送来的分配地址的请求" class="headerlink" title="收到其他点发送来的分配地址的请求"></a>收到其他点发送来的分配地址的请求</h4><p>所有从其他点发送过来，进入IpTunnel的数据，都先到incomingFromNode方法中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">static Iface_DEFUN incomingFromNode(struct Message* message, struct Iface* nodeIf)</div><div class="line">&#123;</div><div class="line">    struct IpTunnel_pvt* context =</div><div class="line">        Identity_containerOf(nodeIf, struct IpTunnel_pvt, pub.nodeInterface);</div><div class="line"></div><div class="line">    //Log_debug(context-&gt;logger, &quot;Got incoming message&quot;);</div><div class="line"></div><div class="line">    Assert_true(message-&gt;length &gt;= RouteHeader_SIZE + DataHeader_SIZE);</div><div class="line">    struct RouteHeader* rh = (struct RouteHeader*) message-&gt;bytes;</div><div class="line">    struct DataHeader* dh = (struct DataHeader*) &amp;rh[1];</div><div class="line">    Assert_true(DataHeader_getContentType(dh) == ContentType_IPTUN);</div><div class="line">    struct IpTunnel_Connection* conn = connectionByPubKey(rh-&gt;publicKey, context);</div><div class="line">    if (!conn) &#123;</div><div class="line">        if (Defined(Log_DEBUG)) &#123;</div><div class="line">            uint8_t addr[40];</div><div class="line">            AddrTools_printIp(addr, rh-&gt;ip6);</div><div class="line">            Log_debug(context-&gt;logger, &quot;Got message from unrecognized node [%s]&quot;, addr);</div><div class="line">        &#125;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Message_shift(message, -(RouteHeader_SIZE + DataHeader_SIZE), NULL);</div><div class="line"></div><div class="line">    if (message-&gt;length &gt; 40 &amp;&amp; Headers_getIpVersion(message-&gt;bytes) == 6) &#123;</div><div class="line">        return ip6FromNode(message, conn, context);</div><div class="line">    &#125;</div><div class="line">    if (message-&gt;length &gt; 20 &amp;&amp; Headers_getIpVersion(message-&gt;bytes) == 4) &#123;</div><div class="line">        return ip4FromNode(message, conn, context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (Defined(Log_DEBUG)) &#123;</div><div class="line">        uint8_t addr[40];</div><div class="line">        AddrTools_printIp(addr, rh-&gt;ip6);</div><div class="line">        Log_debug(context-&gt;logger,</div><div class="line">                  &quot;Got message of unknown type, length: [%d], IP version [%d] from [%s]&quot;,</div><div class="line">                  message-&gt;length,</div><div class="line">                  (message-&gt;length &gt; 1) ? Headers_getIpVersion(message-&gt;bytes) : 0,</div><div class="line">                  addr);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li><p>通过publicKey找到对应的conn。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">struct IpTunnel_Connection* conn = connectionByPubKey(rh-&gt;publicKey, context);</div></pre></td></tr></table></figure>
</li>
<li><p>调用ip6FromNode</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (message-&gt;length &gt; 40 &amp;&amp; Headers_getIpVersion(message-&gt;bytes) == 6) &#123;</div><div class="line">    return ip6FromNode(message, conn, context);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">static Iface_DEFUN ip6FromNode(struct Message* message,</div><div class="line">                               struct IpTunnel_Connection* conn,</div><div class="line">                               struct IpTunnel_pvt* context)</div><div class="line">&#123;</div><div class="line">    struct Headers_IP6Header* header = (struct Headers_IP6Header*) message-&gt;bytes;</div><div class="line">    if (Bits_isZero(header-&gt;sourceAddr, 16) || Bits_isZero(header-&gt;destinationAddr, 16)) &#123;</div><div class="line">        if (Bits_isZero(header-&gt;sourceAddr, 32)) &#123;</div><div class="line">            return incomingControlMessage(message, conn, context);</div><div class="line">        &#125;</div><div class="line">        ......</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    if (!isValidAddress6(header-&gt;sourceAddr, false, conn)) &#123;</div><div class="line">        ......</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">    return Iface_next(&amp;context-&gt;pub.tunInterface, message);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此时header-&gt;sourceAddr为全0，会调用到incomingControlMessage方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">static Iface_DEFUN incomingControlMessage(struct Message* message,</div><div class="line">                                          struct IpTunnel_Connection* conn,</div><div class="line">                                          struct IpTunnel_pvt* context)</div><div class="line">&#123;</div><div class="line">       ......</div><div class="line">    Dict* d = NULL;</div><div class="line">    char* err = BencMessageReader_readNoExcept(message, alloc, &amp;d);</div><div class="line">    if (err) &#123;</div><div class="line">        Log_info(context-&gt;logger, &quot;Failed to parse message [%s]&quot;, err);</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">     ....</div><div class="line">    if (String_equals(String_CONST(&quot;IpTunnel_getAddresses&quot;),</div><div class="line">                      Dict_getStringC(d, &quot;q&quot;)))</div><div class="line">    &#123;</div><div class="line">        return requestForAddresses(d, conn, alloc, context);</div><div class="line">    &#125;</div><div class="line">    Log_warn(context-&gt;logger, &quot;Message which is unhandled&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为普通点在向离岸点发送分配ipv4地址的请求时，会将q字段的值设为IpTunnel_getAddresses，所以，在离岸点收到这类信息时，会调用到requestForAddresses方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">static Iface_DEFUN requestForAddresses(Dict* request,</div><div class="line">                                       struct IpTunnel_Connection* conn,</div><div class="line">                                       struct Allocator* requestAlloc,</div><div class="line">                                       struct IpTunnel_pvt* context)</div><div class="line">&#123;</div><div class="line">    ......</div><div class="line">    Dict* addresses = Dict_new(requestAlloc);</div><div class="line">    bool noAddresses = true;</div><div class="line">    if (!Bits_isZero(conn-&gt;connectionIp6, 16)) &#123;</div><div class="line">        ......</div><div class="line">    &#125;</div><div class="line">    if (!Bits_isZero(conn-&gt;connectionIp4, 4)) &#123;</div><div class="line">        Dict_putStringC(addresses,</div><div class="line">                       &quot;ip4&quot;,</div><div class="line">                       String_newBinary((char*)conn-&gt;connectionIp4, 4, requestAlloc),</div><div class="line">                       requestAlloc);</div><div class="line">        Dict_putIntC(addresses,</div><div class="line">                    &quot;ip4Prefix&quot;, (int64_t)conn-&gt;connectionIp4Prefix,</div><div class="line">                    requestAlloc);</div><div class="line">        Dict_putIntC(addresses,</div><div class="line">                    &quot;ip4Alloc&quot;, (int64_t)conn-&gt;connectionIp4Alloc,</div><div class="line">                    requestAlloc);</div><div class="line"></div><div class="line">        noAddresses = false;</div><div class="line">    &#125;</div><div class="line">    if (noAddresses) &#123;</div><div class="line">        Log_warn(context-&gt;logger, &quot;no addresses to provide&quot;);</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Dict* msg = Dict_new(requestAlloc);</div><div class="line">    Dict_putDictC(msg, &quot;addresses&quot;, addresses, requestAlloc);</div><div class="line"></div><div class="line">    String* txid = Dict_getStringC(request, &quot;txid&quot;);</div><div class="line">    if (txid) &#123;</div><div class="line">        Dict_putStringC(msg, &quot;txid&quot;, txid, requestAlloc);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    sendControlMessage(msg, conn, requestAlloc, context);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>将conf文件中，分配给这个连接的ipv4地址相关信息，填入addresses中，再将key为addresses，value为addresses的键值对，放入Dict中，调用sendControlMessage发送出去。当普通点收到这个回复后，会从中取出addresses，并进行ipv4相关字段的设置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">static void sendControlMessage(Dict* dict,</div><div class="line">                               struct IpTunnel_Connection* connection,</div><div class="line">                               struct Allocator* requestAlloc,</div><div class="line">                               struct IpTunnel_pvt* context)</div><div class="line">&#123;</div><div class="line">    struct Message* msg = Message_new(0, 1024, requestAlloc);</div><div class="line">    BencMessageWriter_write(dict, msg, NULL);</div><div class="line"></div><div class="line">    int length = msg-&gt;length;</div><div class="line"></div><div class="line">    // do UDP header.</div><div class="line">    Message_shift(msg, Headers_UDPHeader_SIZE, NULL);</div><div class="line">    struct Headers_UDPHeader* uh = (struct Headers_UDPHeader*) msg-&gt;bytes;</div><div class="line">    uh-&gt;srcPort_be = 0;</div><div class="line">    uh-&gt;destPort_be = 0;</div><div class="line">    uh-&gt;length_be = Endian_hostToBigEndian16(length);</div><div class="line">    uh-&gt;checksum_be = 0;</div><div class="line"></div><div class="line">    uint16_t payloadLength = msg-&gt;length;</div><div class="line"></div><div class="line">    Message_shift(msg, Headers_IP6Header_SIZE, NULL);</div><div class="line">    struct Headers_IP6Header* header = (struct Headers_IP6Header*) msg-&gt;bytes;</div><div class="line">    header-&gt;versionClassAndFlowLabel = 0;</div><div class="line">    header-&gt;flowLabelLow_be = 0;</div><div class="line">    header-&gt;nextHeader = 17;</div><div class="line">    header-&gt;hopLimit = 0;</div><div class="line">    header-&gt;payloadLength_be = Endian_hostToBigEndian16(payloadLength);</div><div class="line">    Headers_setIpVersion(header);</div><div class="line"></div><div class="line">    // zero the source and dest addresses.</div><div class="line">    Bits_memset(header-&gt;sourceAddr, 0, 32);</div><div class="line"></div><div class="line">    uh-&gt;checksum_be = Checksum_udpIp6(header-&gt;sourceAddr,</div><div class="line">                                      (uint8_t*) uh,</div><div class="line">                                      msg-&gt;length - Headers_IP6Header_SIZE);</div><div class="line"></div><div class="line">    Iface_CALL(sendToNode, msg, connection, context);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>调用sendToNode<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">static Iface_DEFUN sendToNode(struct Message* message,</div><div class="line">                              struct IpTunnel_Connection* connection,</div><div class="line">                              struct IpTunnel_pvt* context)</div><div class="line">&#123;</div><div class="line">    Message_push(message, NULL, DataHeader_SIZE, NULL);</div><div class="line">    struct DataHeader* dh = (struct DataHeader*) message-&gt;bytes;</div><div class="line">    DataHeader_setContentType(dh, ContentType_IPTUN);</div><div class="line">    DataHeader_setVersion(dh, DataHeader_CURRENT_VERSION);</div><div class="line">    Message_push(message, &amp;connection-&gt;routeHeader, RouteHeader_SIZE, NULL);</div><div class="line">    return Iface_next(&amp;context-&gt;pub.nodeInterface, message);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>至此，离岸点在收到普通点的ipv4分配申请后的执行流程分析完毕。</p>
<h2 id="处理从其他点发来的消息"><a href="#处理从其他点发来的消息" class="headerlink" title="处理从其他点发来的消息"></a>处理从其他点发来的消息</h2><p>上面讲到，所有从其他点发送过来，进入IpTunnel的数据，都先到incomingFromNode方法中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">static Iface_DEFUN incomingFromNode(struct Message* message, struct Iface* nodeIf)</div><div class="line">&#123;</div><div class="line">    struct IpTunnel_pvt* context =</div><div class="line">        Identity_containerOf(nodeIf, struct IpTunnel_pvt, pub.nodeInterface);</div><div class="line"></div><div class="line">    Assert_true(message-&gt;length &gt;= RouteHeader_SIZE + DataHeader_SIZE);</div><div class="line">    struct RouteHeader* rh = (struct RouteHeader*) message-&gt;bytes;</div><div class="line">    struct DataHeader* dh = (struct DataHeader*) &amp;rh[1];</div><div class="line">    Assert_true(DataHeader_getContentType(dh) == ContentType_IPTUN);</div><div class="line">    struct IpTunnel_Connection* conn = connectionByPubKey(rh-&gt;publicKey, context);</div><div class="line">    if (!conn) &#123;</div><div class="line">        if (Defined(Log_DEBUG)) &#123;</div><div class="line">            uint8_t addr[40];</div><div class="line">            AddrTools_printIp(addr, rh-&gt;ip6);</div><div class="line">            Log_debug(context-&gt;logger, &quot;Got message from unrecognized node [%s]&quot;, addr);</div><div class="line">        &#125;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Message_shift(message, -(RouteHeader_SIZE + DataHeader_SIZE), NULL);</div><div class="line"></div><div class="line">    if (message-&gt;length &gt; 40 &amp;&amp; Headers_getIpVersion(message-&gt;bytes) == 6) &#123;</div><div class="line">        return ip6FromNode(message, conn, context);</div><div class="line">    &#125;</div><div class="line">    if (message-&gt;length &gt; 20 &amp;&amp; Headers_getIpVersion(message-&gt;bytes) == 4) &#123;</div><div class="line">        return ip4FromNode(message, conn, context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (Defined(Log_DEBUG)) &#123;</div><div class="line">        uint8_t addr[40];</div><div class="line">        AddrTools_printIp(addr, rh-&gt;ip6);</div><div class="line">        Log_debug(context-&gt;logger,</div><div class="line">                  &quot;Got message of unknown type, length: [%d], IP version [%d] from [%s]&quot;,</div><div class="line">                  message-&gt;length,</div><div class="line">                  (message-&gt;length &gt; 1) ? Headers_getIpVersion(message-&gt;bytes) : 0,</div><div class="line">                  addr);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以ipv4为例，进入到ip4FromNode<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">static Iface_DEFUN ip4FromNode(struct Message* message,</div><div class="line">                               struct IpTunnel_Connection* conn,</div><div class="line">                               struct IpTunnel_pvt* context)</div><div class="line">&#123;</div><div class="line">    struct Headers_IP4Header* header = (struct Headers_IP4Header*) message-&gt;bytes;</div><div class="line">    if (Bits_isZero(header-&gt;sourceAddr, 4) || Bits_isZero(header-&gt;destAddr, 4)) &#123;</div><div class="line">        Log_debug(context-&gt;logger, &quot;Got message with zero address&quot;);</div><div class="line">        return 0;</div><div class="line">    &#125; else if (!isValidAddress4(header-&gt;sourceAddr, false, conn)) &#123;</div><div class="line">        Log_debug(context-&gt;logger, &quot;Got message with wrong address [%d.%d.%d.%d] for connection &quot;</div><div class="line">                                   &quot;[%d.%d.%d.%d/%d:%d]&quot;,</div><div class="line">                  header-&gt;sourceAddr[0], header-&gt;sourceAddr[1],</div><div class="line">                  header-&gt;sourceAddr[2], header-&gt;sourceAddr[3],</div><div class="line">                  conn-&gt;connectionIp4[0], conn-&gt;connectionIp4[1],</div><div class="line">                  conn-&gt;connectionIp4[2], conn-&gt;connectionIp4[3],</div><div class="line">                  conn-&gt;connectionIp4Alloc, conn-&gt;connectionIp4Prefix);</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    Log_debug(context-&gt;logger, &quot;jin Got message with address [%d.%d.%d.%d] for connection &quot;</div><div class="line">                                   &quot;[%d.%d.%d.%d/%d:%d]&quot;,</div><div class="line">                  header-&gt;sourceAddr[0], header-&gt;sourceAddr[1],</div><div class="line">                  header-&gt;sourceAddr[2], header-&gt;sourceAddr[3],</div><div class="line">                  conn-&gt;connectionIp4[0], conn-&gt;connectionIp4[1],</div><div class="line">                  conn-&gt;connectionIp4[2], conn-&gt;connectionIp4[3],</div><div class="line">                  conn-&gt;connectionIp4Alloc, conn-&gt;connectionIp4Prefix);</div><div class="line">    TUNMessageType_push(message, Ethernet_TYPE_IP4, NULL);</div><div class="line">    return Iface_next(&amp;context-&gt;pub.tunInterface, message);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>此时，header-&gt;sourceAddr是对方的ipv4地址，不会为全0，代码进入到一个ip地址合法性判断：isValidAddress4(header-&gt;sourceAddr, false, conn)。如果地址合法，消息进一步发送到context-&gt;pub.tunInterface中。<br>tunInterface是一个Iface，它的回调函数在IpTunnel_new中设置为incomingFromTun<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.pub = &#123;</div><div class="line">    .tunInterface = &#123; .send = incomingFromTun &#125;,</div><div class="line">&#125;,</div></pre></td></tr></table></figure></p>
<p>它的connectedIf在Core.c的Core_init方法中通过Iface_plumb方法与nc-&gt;tunAdapt-&gt;ipTunnelIf绑定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Iface_plumb(&amp;nc-&gt;tunAdapt-&gt;ipTunnelIf, &amp;ipTunnel-&gt;tunInterface);</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">static inline void Iface_plumb(struct Iface* a, struct Iface* b)</div><div class="line">&#123;</div><div class="line">    Assert_true(!a-&gt;connectedIf);</div><div class="line">    Assert_true(!b-&gt;connectedIf);</div><div class="line">    a-&gt;connectedIf = b;</div><div class="line">    b-&gt;connectedIf = a;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="查看地址合法性判断"><a href="#查看地址合法性判断" class="headerlink" title="查看地址合法性判断"></a>查看地址合法性判断</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">static bool isValidAddress4(uint8_t sourceAndDestIp4[8],</div><div class="line">                            bool isFromTun,</div><div class="line">                            struct IpTunnel_Connection* conn)</div><div class="line">&#123;</div><div class="line">    uint8_t* compareAddr = (isFromTun)</div><div class="line">        ? ((conn-&gt;isOutgoing) ? sourceAndDestIp4 : &amp;sourceAndDestIp4[4])</div><div class="line">        : ((conn-&gt;isOutgoing) ? &amp;sourceAndDestIp4[4] : sourceAndDestIp4);</div><div class="line">    return prefixMatches4(compareAddr, conn-&gt;connectionIp4, conn-&gt;connectionIp4Alloc);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ifFromTun为false，接下来根据isOutgoing的值来决定compareAddr的值，分为两种情况</p>
<ol>
<li>当前点是普通点，那么他收到的消息是从离岸点发送过来的，isOutgoing为<br>true，compareAddr赋值为sourceAndDestIp4[4]，也就是dest ip,从离岸点发来的包的dest ip就是当前这个普通点的ipv4地址。</li>
<li>当前点是离岸点，那么它收到的消息是从普通点发送过来的，isOutgoing为<br>false，compareAddr赋值为sourceAndDestIp4，也就是source ip，从普通点发来的包的source ip就是普通点的ipv4地址。<br>综上，compareAddr一定会被赋值为普通点的ipv4地址。接下来调用prefixMatches4方法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">static bool prefixMatches4(uint8_t* addressA, uint8_t* refAddr, uint32_t prefixLen)</div><div class="line">&#123;</div><div class="line">    if (!prefixLen) &#123;</div><div class="line">        Assert_true(Bits_isZero(refAddr, 4));</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">    Assert_true(prefixLen &amp;&amp; prefixLen &lt;= 32);</div><div class="line">    uint32_t a = GET32(addressA);</div><div class="line">    uint32_t b = GET32(refAddr);</div><div class="line">    return !((a ^ b) &gt;&gt; (32 - prefixLen));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这就只是一个简单的地址比较了。</p>
<h2 id="处理从Tun设备发来的消息"><a href="#处理从Tun设备发来的消息" class="headerlink" title="处理从Tun设备发来的消息"></a>处理从Tun设备发来的消息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">static Iface_DEFUN incomingFromTun(struct Message* message, struct Iface* tunIf)</div><div class="line">&#123;</div><div class="line">    struct IpTunnel_pvt* context = Identity_check((struct IpTunnel_pvt*)tunIf);</div><div class="line"></div><div class="line">    if (message-&gt;length &lt; 20) &#123;</div><div class="line">        Log_debug(context-&gt;logger, &quot;DROP runt&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    struct IpTunnel_Connection* conn = NULL;</div><div class="line">    if (!context-&gt;pub.connectionList.connections) &#123;</div><div class="line">        // No connections authorized, fall through to &quot;unrecognized address&quot;</div><div class="line">    &#125; else if (message-&gt;length &gt; 40 &amp;&amp; Headers_getIpVersion(message-&gt;bytes) == 6) &#123;</div><div class="line">        struct Headers_IP6Header* header = (struct Headers_IP6Header*) message-&gt;bytes;</div><div class="line">        conn = findConnection(header-&gt;sourceAddr, NULL, true, context);</div><div class="line">    &#125; else if (message-&gt;length &gt; 20 &amp;&amp; Headers_getIpVersion(message-&gt;bytes) == 4) &#123;</div><div class="line">        struct Headers_IP4Header* header = (struct Headers_IP4Header*) message-&gt;bytes;</div><div class="line">        conn = findConnection(NULL, header-&gt;sourceAddr, true, context);</div><div class="line">    &#125; else &#123;</div><div class="line">        Log_info(context-&gt;logger, &quot;Message of unknown type from TUN&quot;);</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (!conn) &#123;</div><div class="line">        Log_info(context-&gt;logger, &quot;Message with unrecognized address from TUN&quot;);</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return sendToNode(message, conn, context);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里主要进行了两个操作：</p>
<ol>
<li>调用findConnection查找conn</li>
<li>调用sendToNode</li>
</ol>
<h3 id="查找conn"><a href="#查找conn" class="headerlink" title="查找conn"></a>查找conn</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">static struct IpTunnel_Connection* findConnection(uint8_t sourceAndDestIp6[32],</div><div class="line">                                                  uint8_t sourceAndDestIp4[8],</div><div class="line">                                                  bool isFromTun,</div><div class="line">                                                  struct IpTunnel_pvt* context)</div><div class="line">&#123;</div><div class="line">    for (int i = 0; i &lt; (int)context-&gt;pub.connectionList.count; i++) &#123;</div><div class="line">        struct IpTunnel_Connection* conn = &amp;context-&gt;pub.connectionList.connections[i];</div><div class="line">        if (sourceAndDestIp6 &amp;&amp; isValidAddress6(sourceAndDestIp6, isFromTun, conn)) &#123;</div><div class="line">            return conn;</div><div class="line">        &#125;</div><div class="line">        if (sourceAndDestIp4 &amp;&amp; isValidAddress4(sourceAndDestIp4, isFromTun, conn)) &#123;</div><div class="line">            return conn;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return NULL;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以ipv4为例，调用isValidAddress4检查地址合法性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">static bool isValidAddress4(uint8_t sourceAndDestIp4[8],</div><div class="line">                            bool isFromTun,</div><div class="line">                            struct IpTunnel_Connection* conn)</div><div class="line">&#123;</div><div class="line">    uint8_t* compareAddr = (isFromTun)</div><div class="line">        ? ((conn-&gt;isOutgoing) ? sourceAndDestIp4 : &amp;sourceAndDestIp4[4])</div><div class="line">        : ((conn-&gt;isOutgoing) ? &amp;sourceAndDestIp4[4] : sourceAndDestIp4);</div><div class="line">    return prefixMatches4(compareAddr, conn-&gt;connectionIp4, conn-&gt;connectionIp4Alloc);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ifFromTun为true，接下来根据isOutgoing的值来决定compareAddr的值，分为两种情况</p>
<ol>
<li>当前点是普通点，那么他的消息是发往离岸点的，isOutgoing为<br>true，compareAddr赋值为sourceAndDestIp4，也就是source ip,是当前这个普通点的ipv4地址。</li>
<li>当前点是离岸点，那么他的消息是发往普通点的，isOutgoing为<br>false，compareAddr赋值为sourceAndDestIp4[4]，也就是dest ip，发往普通点的包的dest ip就是普通点的ipv4地址。<br>综上，compareAddr一定会被赋值为普通点的ipv4地址。接下来调用prefixMatches4方法，进行地址对比。</li>
</ol>
<h3 id="sendToNode"><a href="#sendToNode" class="headerlink" title="sendToNode"></a>sendToNode</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">static Iface_DEFUN sendToNode(struct Message* message,</div><div class="line">                              struct IpTunnel_Connection* connection,</div><div class="line">                              struct IpTunnel_pvt* context)</div><div class="line">&#123;</div><div class="line">    Message_push(message, NULL, DataHeader_SIZE, NULL);</div><div class="line">    struct DataHeader* dh = (struct DataHeader*) message-&gt;bytes;</div><div class="line">    DataHeader_setContentType(dh, ContentType_IPTUN);</div><div class="line">    DataHeader_setVersion(dh, DataHeader_CURRENT_VERSION);</div><div class="line">    Message_push(message, &amp;connection-&gt;routeHeader, RouteHeader_SIZE, NULL);</div><div class="line">    return Iface_next(&amp;context-&gt;pub.nodeInterface, message);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至此，IpTunnel收到从Tun上和从其他点发来的包，并进行处理的过程分析完成。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/07/25/cjdns_IpTunnel/" data-id="cje6pjw1b002aweyxrqyqzolu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C/">C/C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cjdns/">cjdns</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cjdns源码分析/">cjdns源码分析</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/08/02/cjdns_RouteGen-d/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          cjdns源码分析--RouteGen
        
      </div>
    </a>
  
  
    <a href="/2017/04/27/about-iptables/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">iptables在anet项目中的运用</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/Android-everyday/">Android_everyday</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android/Android开发工程师/">Android开发工程师</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/AndroidRom/">AndroidRom</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Anrom/">Anrom</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Anrom/rom7-0/">rom7.0</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/Android开发工程师/">Android开发工程师</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SEAndroid/">SEAndroid</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/cjdns/">cjdns</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/cjdns/cjdns源码分析/">cjdns源码分析</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/cjdns-cjdns源码分析/">cjdns - cjdns源码分析</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/hexo/">hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/music/">music</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/net/">net</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/net/iptables/">iptables</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/树莓派/">树莓派</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/树莓派/配置/">配置</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/算法/Java/">Java</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/Java/">Java</a></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android-everyday/">Android_everyday</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android开发工程师/">Android开发工程师</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Anrom/">Anrom</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-C/">C/C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SEAndroid/">SEAndroid</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SELinux/">SELinux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cjdns/">cjdns</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cjdns源码分析/">cjdns源码分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iptables/">iptables</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/music/">music</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/raspberry配置/">raspberry配置</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rom/">rom</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shadowsocks-vps/">shadowsocks/vps</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tool/">tool</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/填坑/">填坑</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/排序算法/">排序算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/查找算法/">查找算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/树莓派raspberry/">树莓派raspberry</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/Android-everyday/" style="font-size: 16.67px;">Android_everyday</a> <a href="/tags/Android开发工程师/" style="font-size: 15.56px;">Android开发工程师</a> <a href="/tags/Anrom/" style="font-size: 14.44px;">Anrom</a> <a href="/tags/C-C/" style="font-size: 14.44px;">C/C++</a> <a href="/tags/Java/" style="font-size: 18.89px;">Java</a> <a href="/tags/Linux/" style="font-size: 13.33px;">Linux</a> <a href="/tags/SEAndroid/" style="font-size: 10px;">SEAndroid</a> <a href="/tags/SELinux/" style="font-size: 10px;">SELinux</a> <a href="/tags/cjdns/" style="font-size: 14.44px;">cjdns</a> <a href="/tags/cjdns源码分析/" style="font-size: 14.44px;">cjdns源码分析</a> <a href="/tags/git/" style="font-size: 11.11px;">git</a> <a href="/tags/hexo/" style="font-size: 13.33px;">hexo</a> <a href="/tags/iptables/" style="font-size: 10px;">iptables</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/music/" style="font-size: 10px;">music</a> <a href="/tags/raspberry配置/" style="font-size: 10px;">raspberry配置</a> <a href="/tags/rom/" style="font-size: 10px;">rom</a> <a href="/tags/shadowsocks-vps/" style="font-size: 10px;">shadowsocks/vps</a> <a href="/tags/tool/" style="font-size: 11.11px;">tool</a> <a href="/tags/填坑/" style="font-size: 13.33px;">填坑</a> <a href="/tags/排序算法/" style="font-size: 11.11px;">排序算法</a> <a href="/tags/数据结构/" style="font-size: 10px;">数据结构</a> <a href="/tags/查找算法/" style="font-size: 11.11px;">查找算法</a> <a href="/tags/树莓派raspberry/" style="font-size: 11.11px;">树莓派raspberry</a> <a href="/tags/算法/" style="font-size: 12.22px;">算法</a> <a href="/tags/设计模式/" style="font-size: 17.78px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">June 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">April 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02/">February 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">January 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/03/">March 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/02/">February 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/06/">June 2013</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/01/29/cjnds-asymmetric-cryptography/">握手过程中，非对称密钥的应用</a>
          </li>
        
          <li>
            <a href="/2017/12/04/how-to-fix-rebase-still-in-progress/">如何解决报错“prior sync failed; rebase still in progress”</a>
          </li>
        
          <li>
            <a href="/2017/11/22/cjdns-3steps-lladdrsession/">使用SocketAddress来维护的EndpointsBySockaddr map机制中EndpointsBySockaddr session的建立过程</a>
          </li>
        
          <li>
            <a href="/2017/09/05/cjdns-cryptoauth/">cjdns源码分析--CryptoAuth</a>
          </li>
        
          <li>
            <a href="/2017/09/04/how-to-read-staff/">如何看懂五线谱</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Chris King<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>