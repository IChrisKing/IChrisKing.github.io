<!DOCTYPE html>
<html lang="zh-Hant-TW">
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="Chris King" />



<meta name="description" content="“IpTunnel中主要是和离岸点相关的代码。结合最近的需求，分析一下源码，设计一下需求的实现方案”">
<meta name="keywords" content="cjdns,cjdns源码分析,C&#x2F;C++">
<meta property="og:type" content="article">
<meta property="og:title" content="cjdns源码分析--IpTunnel">
<meta property="og:url" content="http://yoursite.com/2017/07/25/cjdns_IpTunnel/index.html">
<meta property="og:site_name" content="IChrisKing">
<meta property="og:description" content="“IpTunnel中主要是和离岸点相关的代码。结合最近的需求，分析一下源码，设计一下需求的实现方案”">
<meta property="og:locale" content="zh-Hant-TW">
<meta property="og:updated_time" content="2017-08-04T02:16:19.491Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="cjdns源码分析--IpTunnel">
<meta name="twitter:description" content="“IpTunnel中主要是和离岸点相关的代码。结合最近的需求，分析一下源码，设计一下需求的实现方案”">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="IChrisKing" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">



<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>cjdns源码分析--IpTunnel | IChrisKing</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: undefined
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">Chris King</a></h1>
        </hgroup>

        
        <p class="header-subtitle">#IMNOTCHRISLEE</p>
        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜單</li>
                        <li>標籤</li>
                        
                        <li>友情鏈接</li>
                        
                        
                        <li>關於我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主頁</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">標籤雲</a></li>
                        
                            <li><a href="/about/">關於我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="https://chrisking310@gmail.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="https://github.com/IChrisKing" title="GitHub"></a>
                            
                                <a class="fa 新浪博客" href="http://blog.sina.com.cn/u/1733434252" title="新浪博客"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android-everyday/">Android_everyday</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android开发工程师/">Android开发工程师</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Anrom/">Anrom</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-C/">C/C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SEAndroid/">SEAndroid</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SELinux/">SELinux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/anrom/">anrom</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cjdns/">cjdns</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cjdns源码分析/">cjdns源码分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iptables/">iptables</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/life/">life</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/music/">music</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/network/">network</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/raspberry配置/">raspberry配置</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rom/">rom</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shadowsocks-vps/">shadowsocks/vps</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tool/">tool</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/填坑/">填坑</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/排序算法/">排序算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/查找算法/">查找算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/树莓派raspberry/">树莓派raspberry</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络/">网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://anromos.github.io/">Anrom OS</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://github.com/AnromOS">Team GitHub</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">Android ROM 开发</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">Chris King</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">Chris King</a></h1>
            </hgroup>
            
            <p class="header-subtitle">#IMNOTCHRISLEE</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主頁</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">標籤雲</a></li>
                
                    <li><a href="/about/">關於我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="https://chrisking310@gmail.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/IChrisKing" title="GitHub"></a>
                            
                                <a class="fa 新浪博客" target="_blank" href="http://blog.sina.com.cn/u/1733434252" title="新浪博客"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="標籤" friends="友情鏈接" about="關於我"/>
</nav>
      <div class="body-wrap"><article id="post-cjdns_IpTunnel" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/07/25/cjdns_IpTunnel/" class="article-date">
      <time datetime="2017-07-25T01:48:00.000Z" itemprop="datePublished">2017-07-25</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      cjdns源码分析--IpTunnel
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/cjdns-cjdns源码分析/">cjdns - cjdns源码分析</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C/">C/C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cjdns/">cjdns</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cjdns源码分析/">cjdns源码分析</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>首先看一下IpTunnel的结构体定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">struct IpTunnel</div><div class="line">&#123;</div><div class="line">    /** The interface used to send and receive messages to the TUN device. */</div><div class="line">    struct Iface tunInterface;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * The interface used to send and receive messages to other nodes.</div><div class="line">     * All messages sent on this interface shall be preceeded with the RouterHeader and DataHeader.</div><div class="line">     */</div><div class="line">    struct Iface nodeInterface;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * The list of registered connections, do not modify manually.</div><div class="line">     * Will be reorganized from time to time so pointers are ephemeral.</div><div class="line">     */</div><div class="line">    struct &#123;</div><div class="line">        uint32_t count;</div><div class="line">        struct IpTunnel_Connection* connections;</div><div class="line">    &#125; connectionList;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>两个Iface，一个负责跟tun设备沟通，一个负责跟其他node沟通<br>一个connectionList，保存现有的所有connection。</p>
<p>然后看一下IpTunnel_Connection的结构体定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">struct IpTunnel_Connection</div><div class="line">&#123;</div><div class="line">    /** The header for routing to this node. */</div><div class="line">    struct RouteHeader routeHeader;</div><div class="line"></div><div class="line">    /** The IPv6 address used for this connection or all zeros if none was assigned. */</div><div class="line">    uint8_t connectionIp6[16];</div><div class="line"></div><div class="line">    /** The IPv4 address used for this connection or all zeros if none was assigned. */</div><div class="line">    uint8_t connectionIp4[4];</div><div class="line"></div><div class="line">    /** The IPv6 netmask/prefix length, in bits. Defaults to 128 if none was assigned. */</div><div class="line">    uint8_t connectionIp6Prefix;</div><div class="line"></div><div class="line">    /** The IPv6 prefix length in, in bits, defining netmask. 0xff if not used. */</div><div class="line">    uint8_t connectionIp6Alloc;</div><div class="line"></div><div class="line">    /** The IPv4 address prefix length, in bits. Defaults to 32 if none was assigned. */</div><div class="line">    uint8_t connectionIp4Prefix;</div><div class="line"></div><div class="line">    /** The IPv6 prefix length in, in bits, defining netmask. 0xff if not used. */</div><div class="line">    uint8_t connectionIp4Alloc;</div><div class="line"></div><div class="line">    /** non-zero if the connection was made using IpTunnel_connectTo(). */</div><div class="line">    int isOutgoing : 1;</div><div class="line"></div><div class="line">    /** The number of the connection so it can be identified when removing. */</div><div class="line">    int number : 31;</div><div class="line"></div><div class="line">    bool reachable;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p> 这个结构体记录的是当前点与其他node的连接信息。对于普通的点来说，这里保存着与离岸点的连接信息。每个在conf中定义的离岸点（outgoingConnections），对应着这里的一个IpTunnel_Connection对象，且该对象的isOutgoing字段为1，表明这是一个与离岸点的连接。对于离岸点来说，这里保存着所有连接到该离岸点的连接信息。每个在conf中定义的允许连接的点（allowedConnections），对应着这里的一个IpTunnel_Connection对象，且该对向的isOutgoing字段为0，表明这不是一个向离岸点的连接。</p>
<p>结构体中还有六个与ip相关的字段，3个ip4，3个ipv6，根据需要，使用其中3个。这些ip字段，记录着该连接中，非离岸点的ip信息。</p>
<p>结构体中的routeHeader字段，记录着去往对方的路由信息。</p>
<h3 id="conf文件起到的作用"><a href="#conf文件起到的作用" class="headerlink" title="conf文件起到的作用"></a>conf文件起到的作用</h3><p>有两种途径来新建一个IpTunnel_Connection。</p>
<ol>
<li><p>作为普通点，建立一个与离岸点的IpTunnel_Connection<br>对应着conf文件中的outgoingConnections配置，调用到IpTunnel_admin中的connectTo方法，继而调用到IpTunnel中的IpTunnel_connectTo方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&quot;outgoingConnections&quot;:[</div><div class="line">	&quot;wfzyzrc0q4g83y0dgzxx1l862u0lscucj75yw9q1ymbltzwh2fq0.k&quot;</div><div class="line">]</div></pre></td></tr></table></figure>
</li>
<li><p>作为离岸点，为每个允许连接过来的普通点建立一个IpTunnel_Connection，对应着conf文件中的allowedConnections配置，调用到IpTunnel_admin中的allowConnection方法，继而调用到IpTunnel中的IpTunnel_allowConnection方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&quot;allowedConnections&quot;: [</div><div class="line">        &#123;</div><div class="line">            &quot;ip4Address&quot;: &quot;192.168.254.2&quot;,</div><div class="line">            &quot;ip4Prefix&quot;: 0,</div><div class="line">            &quot;ip4Alloc&quot;: 32,</div><div class="line">            &quot;publicKey&quot;: &quot;uhmhts49tdm1ryb3q0pw95291uwt4xgvyk5s84vt2z2mnv3zp230.k&quot;</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            &quot;ip4Address&quot;: &quot;192.168.254.3&quot;,</div><div class="line">            &quot;ip4Prefix&quot;: 0,</div><div class="line">            &quot;ip4Alloc&quot;: 32,</div><div class="line">            &quot;publicKey&quot;: &quot;9c3x7hp181dv91tfkbngyhhu2uc3xhxuuh539l3g0gdjgjg1bs10.k&quot;</div><div class="line">        &#125;</div><div class="line">]</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="普通点建立一个离岸点的IpTunnel-Connection"><a href="#普通点建立一个离岸点的IpTunnel-Connection" class="headerlink" title="普通点建立一个离岸点的IpTunnel_Connection"></a>普通点建立一个离岸点的IpTunnel_Connection</h3><h4 id="conf文件配置"><a href="#conf文件配置" class="headerlink" title="conf文件配置"></a>conf文件配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&quot;outgoingConnections&quot;:[</div><div class="line">	&quot;wfzyzrc0q4g83y0dgzxx1l862u0lscucj75yw9q1ymbltzwh2fq0.k&quot;</div><div class="line">]</div></pre></td></tr></table></figure>
<h4 id="读取配置文件"><a href="#读取配置文件" class="headerlink" title="读取配置文件"></a>读取配置文件</h4><p>Configurator.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">List* outgoing = Dict_getListC(ifaceConf, &quot;outgoingConnections&quot;);</div><div class="line">if (outgoing) &#123;</div><div class="line">    String* s;</div><div class="line">    for (int i = 0; (s = List_getString(outgoing, i)) != NULL; i++) &#123;</div><div class="line">        Log_debug(ctx-&gt;logger, &quot;Initiating IpTunnel connection to [%s]&quot;, s-&gt;bytes);</div><div class="line">        Dict requestDict =</div><div class="line">            Dict_CONST(String_CONST(&quot;publicKeyOfNodeToConnectTo&quot;), String_OBJ(s), NULL);</div><div class="line">        Dict* resp = NULL;</div><div class="line">        rpcCall0(String_CONST(&quot;IpTunnel_connectTo&quot;), &amp;requestDict, ctx, tempAlloc, &amp;resp, true);</div><div class="line">        int64_t* num = Dict_getIntC(resp, &quot;connection&quot;);</div><div class="line">        Log_debug(ctx-&gt;logger,&quot;noti outgoing callback %d&quot;,(int)*num);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>读取配置文件中outgoingConnections中的离岸点pubkey信息，rpcall调用IpTunnel_connectTo方法。</p>
<h4 id="IpTunnel-connectTo方法"><a href="#IpTunnel-connectTo方法" class="headerlink" title="IpTunnel_connectTo方法"></a>IpTunnel_connectTo方法</h4><p>IpTunnel_admin.c<br>该方法在文件中注册为connectTo函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">static void connectTo(Dict* args, void* vcontext, String* txid, struct Allocator* requestAlloc)</div><div class="line">&#123;</div><div class="line">    struct Context* context = vcontext;</div><div class="line">    String* publicKeyOfNodeToConnectTo =</div><div class="line">        Dict_getStringC(args, &quot;publicKeyOfNodeToConnectTo&quot;);</div><div class="line"></div><div class="line">    uint8_t pubKey[32];</div><div class="line">    uint8_t ip6[16];</div><div class="line">    int ret;</div><div class="line">    if ((ret = Key_parse(publicKeyOfNodeToConnectTo, pubKey, ip6)) != 0) &#123;</div><div class="line">        sendError(Key_parse_strerror(ret), txid, context-&gt;admin);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    int conn = IpTunnel_connectTo(pubKey, context-&gt;ipTun);</div><div class="line">    sendResponse(conn, txid, context-&gt;admin);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>解析离岸点的pubkey，验证其合法性，调用IpTunnel_connectTo方法，建立IpTunnel_Connection。</p>
<h4 id="IpTunnel-connectTo方法-1"><a href="#IpTunnel-connectTo方法-1" class="headerlink" title="IpTunnel_connectTo方法"></a>IpTunnel_connectTo方法</h4><p>IpTunnel.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">int IpTunnel_connectTo(uint8_t publicKeyOfNodeToConnectTo[32], struct IpTunnel* tunnel)</div><div class="line">&#123;</div><div class="line">    struct IpTunnel_pvt* context = Identity_check((struct IpTunnel_pvt*)tunnel);</div><div class="line">    Log_debug(context-&gt;logger, &quot;noti outgoing call by IpTunnel_connectTo&quot;);</div><div class="line">    struct IpTunnel_Connection* conn = newConnection(true, context);</div><div class="line">    Bits_memcpy(conn-&gt;routeHeader.publicKey, publicKeyOfNodeToConnectTo, 32);</div><div class="line">    AddressCalc_addressForPublicKey(conn-&gt;routeHeader.ip6, publicKeyOfNodeToConnectTo);</div><div class="line"></div><div class="line">    if (Defined(Log_DEBUG)) &#123;</div><div class="line">        uint8_t addr[40];</div><div class="line">        AddrTools_printIp(addr, conn-&gt;routeHeader.ip6);</div><div class="line">        Log_debug(context-&gt;logger, &quot;Trying to connect to [%s]&quot;, addr);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    requestAddresses(conn, context);</div><div class="line">    return conn-&gt;number;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里主要有两个操作：</p>
<ol>
<li>调用newConnection(true, context)创建一个IpTunnel_Connection类型的conn，并将conf配置中的离岸点pubkey赋值给conn-&gt;routeHeader.publicKey。</li>
<li>调用requestAddresses方法，向离岸点申请ipv4地址。</li>
</ol>
<h4 id="创建一个IpTunnel-Connection类型的conn"><a href="#创建一个IpTunnel-Connection类型的conn" class="headerlink" title="创建一个IpTunnel_Connection类型的conn"></a>创建一个IpTunnel_Connection类型的conn</h4><p>调用newConnection方法。<br>IpTunnel.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">static struct IpTunnel_Connection* newConnection(bool isOutgoing, struct IpTunnel_pvt* context)</div><div class="line">&#123;</div><div class="line">    if (context-&gt;pub.connectionList.count == context-&gt;connectionCapacity) &#123;</div><div class="line">        uint32_t newSize = (context-&gt;connectionCapacity + 4) * sizeof(struct IpTunnel_Connection);</div><div class="line">        context-&gt;pub.connectionList.connections =</div><div class="line">            Allocator_realloc(context-&gt;allocator, context-&gt;pub.connectionList.connections, newSize);</div><div class="line">        context-&gt;connectionCapacity += 4;</div><div class="line">    &#125;</div><div class="line">    struct IpTunnel_Connection* conn =</div><div class="line">        &amp;context-&gt;pub.connectionList.connections[context-&gt;pub.connectionList.count];</div><div class="line"></div><div class="line">    // If it&apos;s an incoming connection, it must be lower on the list than any outgoing connections.</div><div class="line">    if (!isOutgoing) &#123;</div><div class="line">        for (int i = (int)context-&gt;pub.connectionList.count - 1; i &gt;= 0; i--) &#123;</div><div class="line">            if (!context-&gt;pub.connectionList.connections[i].isOutgoing</div><div class="line">                &amp;&amp; conn != &amp;context-&gt;pub.connectionList.connections[i + 1])</div><div class="line">            &#123;</div><div class="line">                Bits_memcpy(conn,</div><div class="line">                                 &amp;context-&gt;pub.connectionList.connections[i + 1],</div><div class="line">                                 sizeof(struct IpTunnel_Connection));</div><div class="line">                conn = &amp;context-&gt;pub.connectionList.connections[i + 1];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    context-&gt;pub.connectionList.count++;</div><div class="line"></div><div class="line">    Bits_memset(conn, 0, sizeof(struct IpTunnel_Connection));</div><div class="line">    conn-&gt;number = context-&gt;nextConnectionNumber++;</div><div class="line">    conn-&gt;isOutgoing = isOutgoing;</div><div class="line">    conn-&gt;reachable = false;</div><div class="line"></div><div class="line">    // if there are 2 billion calls, die.</div><div class="line">    Assert_true(context-&gt;nextConnectionNumber &lt; (UINT32_MAX &gt;&gt; 1));</div><div class="line"></div><div class="line">    return conn;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第一个参数指定了是否为离岸点，其他部分没什么特别，普通的赋值操作。</p>
<h4 id="向离岸点申请ipv4地址"><a href="#向离岸点申请ipv4地址" class="headerlink" title="向离岸点申请ipv4地址"></a>向离岸点申请ipv4地址</h4><p>调用requestAddresses方法<br>IpTunnel.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">static void requestAddresses(struct IpTunnel_Connection* conn, struct IpTunnel_pvt* context)</div><div class="line">&#123;</div><div class="line">    if (Defined(Log_DEBUG)) &#123;</div><div class="line">        uint8_t addr[40];</div><div class="line">        AddrTools_printIp(addr, conn-&gt;routeHeader.ip6);</div><div class="line">        Log_debug(context-&gt;logger, &quot;Requesting addresses from [%s] for connection [%d]&quot;,</div><div class="line">                  addr, conn-&gt;number);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    int number = conn-&gt;number;</div><div class="line">    Dict d = Dict_CONST(</div><div class="line">        String_CONST(&quot;q&quot;), String_OBJ(String_CONST(&quot;IpTunnel_getAddresses&quot;)), Dict_CONST(</div><div class="line">        String_CONST(&quot;txid&quot;), String_OBJ((&amp;(String)&#123; .len = 4, .bytes = (char*)&amp;number &#125;)),</div><div class="line">        NULL</div><div class="line">    ));</div><div class="line">    struct Allocator* msgAlloc = Allocator_child(context-&gt;allocator);</div><div class="line">    sendControlMessage(&amp;d, conn, msgAlloc, context);</div><div class="line">    Allocator_free(msgAlloc);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Dict中放入key为q，value为IpTunnel_getAddresses的键值对，调用sendControlMessage方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">static void sendControlMessage(Dict* dict,</div><div class="line">                               struct IpTunnel_Connection* connection,</div><div class="line">                               struct Allocator* requestAlloc,</div><div class="line">                               struct IpTunnel_pvt* context)</div><div class="line">&#123;</div><div class="line">    struct Message* msg = Message_new(0, 1024, requestAlloc);</div><div class="line">    BencMessageWriter_write(dict, msg, NULL);</div><div class="line"></div><div class="line">    int length = msg-&gt;length;</div><div class="line"></div><div class="line">    // do UDP header.</div><div class="line">    Message_shift(msg, Headers_UDPHeader_SIZE, NULL);</div><div class="line">    struct Headers_UDPHeader* uh = (struct Headers_UDPHeader*) msg-&gt;bytes;</div><div class="line">    uh-&gt;srcPort_be = 0;</div><div class="line">    uh-&gt;destPort_be = 0;</div><div class="line">    uh-&gt;length_be = Endian_hostToBigEndian16(length);</div><div class="line">    uh-&gt;checksum_be = 0;</div><div class="line"></div><div class="line">    uint16_t payloadLength = msg-&gt;length;</div><div class="line"></div><div class="line">    Message_shift(msg, Headers_IP6Header_SIZE, NULL);</div><div class="line">    struct Headers_IP6Header* header = (struct Headers_IP6Header*) msg-&gt;bytes;</div><div class="line">    header-&gt;versionClassAndFlowLabel = 0;</div><div class="line">    header-&gt;flowLabelLow_be = 0;</div><div class="line">    header-&gt;nextHeader = 17;</div><div class="line">    header-&gt;hopLimit = 0;</div><div class="line">    header-&gt;payloadLength_be = Endian_hostToBigEndian16(payloadLength);</div><div class="line">    Headers_setIpVersion(header);</div><div class="line"></div><div class="line">    // zero the source and dest addresses.</div><div class="line">    Bits_memset(header-&gt;sourceAddr, 0, 32);</div><div class="line"></div><div class="line">    uh-&gt;checksum_be = Checksum_udpIp6(header-&gt;sourceAddr,</div><div class="line">                                      (uint8_t*) uh,</div><div class="line">                                      msg-&gt;length - Headers_IP6Header_SIZE);</div><div class="line"></div><div class="line">    Iface_CALL(sendToNode, msg, connection, context);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一些初始化操作，然后Iface_CALL调用sendToNode方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">static Iface_DEFUN sendToNode(struct Message* message,</div><div class="line">                              struct IpTunnel_Connection* connection,</div><div class="line">                              struct IpTunnel_pvt* context)</div><div class="line">&#123;</div><div class="line">    Message_push(message, NULL, DataHeader_SIZE, NULL);</div><div class="line">    struct DataHeader* dh = (struct DataHeader*) message-&gt;bytes;</div><div class="line">    DataHeader_setContentType(dh, ContentType_IPTUN);</div><div class="line">    DataHeader_setVersion(dh, DataHeader_CURRENT_VERSION);</div><div class="line">    Message_push(message, &amp;connection-&gt;routeHeader, RouteHeader_SIZE, NULL);</div><div class="line">    return Iface_next(&amp;context-&gt;pub.nodeInterface, message);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>设置了ContentType和Version，调用Message_push方法调整消息内容。最后调用 Iface_next(&amp;context-&gt;pub.nodeInterface, message)方法，将消息发出去。<br>此处的context-&gt;pub.nodeInterface是一个Iface，它的回调函数在IpTunnel_new方法中，被设为incomingFromNode。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">      .pub = &#123;</div><div class="line">..........</div><div class="line">          .nodeInterface = &#123; .send = incomingFromNode &#125;</div><div class="line">      &#125;,</div></pre></td></tr></table></figure></p>
<p>它的connectedIf在Core.c的Core_init方法中通过Iface_plumb方法与nc-&gt;upper-&gt;ipTunnelIf绑定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Iface_plumb(&amp;nc-&gt;upper-&gt;ipTunnelIf, &amp;ipTunnel-&gt;nodeInterface);</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">static inline void Iface_plumb(struct Iface* a, struct Iface* b)</div><div class="line">&#123;</div><div class="line">    Assert_true(!a-&gt;connectedIf);</div><div class="line">    Assert_true(!b-&gt;connectedIf);</div><div class="line">    a-&gt;connectedIf = b;</div><div class="line">    b-&gt;connectedIf = a;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="收到离岸点分配的ipv4地址"><a href="#收到离岸点分配的ipv4地址" class="headerlink" title="收到离岸点分配的ipv4地址"></a>收到离岸点分配的ipv4地址</h4><p>上面讲到，回调函数被设为incomingFromNode，所以，所有从其他点发送过来，进入IpTunnel的数据，都先到incomingFromNode方法中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">static Iface_DEFUN incomingFromNode(struct Message* message, struct Iface* nodeIf)</div><div class="line">&#123;</div><div class="line">    struct IpTunnel_pvt* context =</div><div class="line">        Identity_containerOf(nodeIf, struct IpTunnel_pvt, pub.nodeInterface);</div><div class="line"></div><div class="line">    //Log_debug(context-&gt;logger, &quot;Got incoming message&quot;);</div><div class="line"></div><div class="line">    Assert_true(message-&gt;length &gt;= RouteHeader_SIZE + DataHeader_SIZE);</div><div class="line">    struct RouteHeader* rh = (struct RouteHeader*) message-&gt;bytes;</div><div class="line">    struct DataHeader* dh = (struct DataHeader*) &amp;rh[1];</div><div class="line">    Assert_true(DataHeader_getContentType(dh) == ContentType_IPTUN);</div><div class="line">    struct IpTunnel_Connection* conn = connectionByPubKey(rh-&gt;publicKey, context);</div><div class="line">    if (!conn) &#123;</div><div class="line">        if (Defined(Log_DEBUG)) &#123;</div><div class="line">            uint8_t addr[40];</div><div class="line">            AddrTools_printIp(addr, rh-&gt;ip6);</div><div class="line">            Log_debug(context-&gt;logger, &quot;Got message from unrecognized node [%s]&quot;, addr);</div><div class="line">        &#125;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Message_shift(message, -(RouteHeader_SIZE + DataHeader_SIZE), NULL);</div><div class="line"></div><div class="line">    if (message-&gt;length &gt; 40 &amp;&amp; Headers_getIpVersion(message-&gt;bytes) == 6) &#123;</div><div class="line">        return ip6FromNode(message, conn, context);</div><div class="line">    &#125;</div><div class="line">    if (message-&gt;length &gt; 20 &amp;&amp; Headers_getIpVersion(message-&gt;bytes) == 4) &#123;</div><div class="line">        return ip4FromNode(message, conn, context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (Defined(Log_DEBUG)) &#123;</div><div class="line">        uint8_t addr[40];</div><div class="line">        AddrTools_printIp(addr, rh-&gt;ip6);</div><div class="line">        Log_debug(context-&gt;logger,</div><div class="line">                  &quot;Got message of unknown type, length: [%d], IP version [%d] from [%s]&quot;,</div><div class="line">                  message-&gt;length,</div><div class="line">                  (message-&gt;length &gt; 1) ? Headers_getIpVersion(message-&gt;bytes) : 0,</div><div class="line">                  addr);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li><p>通过publicKey找到对应的conn，也就是离岸点的conn。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">struct IpTunnel_Connection* conn = connectionByPubKey(rh-&gt;publicKey, context);</div></pre></td></tr></table></figure>
</li>
<li><p>调用ip6FromNode</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (message-&gt;length &gt; 40 &amp;&amp; Headers_getIpVersion(message-&gt;bytes) == 6) &#123;</div><div class="line">    return ip6FromNode(message, conn, context);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">static Iface_DEFUN ip6FromNode(struct Message* message,</div><div class="line">                               struct IpTunnel_Connection* conn,</div><div class="line">                               struct IpTunnel_pvt* context)</div><div class="line">&#123;</div><div class="line">    struct Headers_IP6Header* header = (struct Headers_IP6Header*) message-&gt;bytes;</div><div class="line">    if (Bits_isZero(header-&gt;sourceAddr, 16) || Bits_isZero(header-&gt;destinationAddr, 16)) &#123;</div><div class="line">        if (Bits_isZero(header-&gt;sourceAddr, 32)) &#123;</div><div class="line">            return incomingControlMessage(message, conn, context);</div><div class="line">        &#125;</div><div class="line">        ......</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    if (!isValidAddress6(header-&gt;sourceAddr, false, conn)) &#123;</div><div class="line">        ......</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">    return Iface_next(&amp;context-&gt;pub.tunInterface, message);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此时header-&gt;sourceAddr为全0，会调用到incomingControlMessage方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">static Iface_DEFUN incomingControlMessage(struct Message* message,</div><div class="line">                                          struct IpTunnel_Connection* conn,</div><div class="line">                                          struct IpTunnel_pvt* context)</div><div class="line">&#123;</div><div class="line">    ......</div><div class="line"></div><div class="line">    struct Allocator* alloc = Allocator_child(message-&gt;alloc);</div><div class="line"></div><div class="line">    Dict* d = NULL;</div><div class="line"></div><div class="line">    if (Dict_getDictC(d, &quot;addresses&quot;)) &#123;</div><div class="line">        return incomingAddresses(d, conn, alloc, context);</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用到incomingAddresses</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">static Iface_DEFUN incomingAddresses(Dict* d,</div><div class="line">                                     struct IpTunnel_Connection* conn,</div><div class="line">                                     struct Allocator* alloc,</div><div class="line">                                     struct IpTunnel_pvt* context)</div><div class="line">&#123;</div><div class="line">      //一些数据合法性判断</div><div class="line"></div><div class="line">    Dict* addresses = Dict_getDictC(d, &quot;addresses&quot;);</div><div class="line"></div><div class="line">    String* ip4 = Dict_getStringC(addresses, &quot;ip4&quot;);</div><div class="line">    int64_t* ip4Prefix = Dict_getIntC(addresses, &quot;ip4Prefix&quot;);</div><div class="line">    int64_t* ip4Alloc = Dict_getIntC(addresses, &quot;ip4Alloc&quot;);</div><div class="line"></div><div class="line">    if (ip4 &amp;&amp; ip4-&gt;len == 4) &#123;</div><div class="line">        Bits_memcpy(conn-&gt;connectionIp4, ip4-&gt;bytes, 4);</div><div class="line"></div><div class="line">        if (ip4Prefix &amp;&amp; *ip4Prefix &gt;= 0 &amp;&amp; *ip4Prefix &lt;= 32) &#123;</div><div class="line">            conn-&gt;connectionIp4Prefix = (uint8_t) *ip4Prefix;</div><div class="line">        &#125; else &#123;</div><div class="line">            conn-&gt;connectionIp4Prefix = 32;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (ip4Alloc &amp;&amp; *ip4Alloc &gt;= 0 &amp;&amp; *ip4Alloc &lt;= 32) &#123;</div><div class="line">            conn-&gt;connectionIp4Alloc = (uint8_t) *ip4Alloc;</div><div class="line">        &#125; else &#123;</div><div class="line">            conn-&gt;connectionIp4Alloc = 32;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        struct Sockaddr* sa = Sockaddr_clone(Sockaddr_LOOPBACK, alloc);</div><div class="line">        uint8_t* addrBytes = NULL;</div><div class="line">        Sockaddr_getAddress(sa, &amp;addrBytes);</div><div class="line">        Bits_memcpy(addrBytes, ip4-&gt;bytes, 4);</div><div class="line">        char* printedAddr = Sockaddr_print(sa, alloc);</div><div class="line"></div><div class="line">        Log_info(context-&gt;logger, &quot;Got issued address [%s/%d:%d] for connection [%d]&quot;,</div><div class="line">                 printedAddr, conn-&gt;connectionIp4Alloc, conn-&gt;connectionIp4Prefix, conn-&gt;number);</div><div class="line"></div><div class="line">        addAddress(printedAddr, conn-&gt;connectionIp4Prefix, conn-&gt;connectionIp4Alloc, context);</div><div class="line">        Notification_doNotify_af(context-&gt;notification,</div><div class="line">                OUTGOING_REACHABLE,REACHABLE,Ethernet_TYPE_IP4);</div><div class="line">        conn-&gt;reachable = true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //与ipv4类似的，ipv6的处理。不做具体分析。</div><div class="line">    </div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从消息中取出ipv4相关的三个字段，这是离岸点分配给当前点的ipv4地址相关信息。设置conn中相关字段的内容。然后调用addAddress方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">static void addAddress(char* printedAddr, uint8_t prefixLen,</div><div class="line">                       uint8_t allocSize, struct IpTunnel_pvt* ctx)</div><div class="line">&#123;</div><div class="line">    struct Sockaddr_storage ss;</div><div class="line">    if (Sockaddr_parse(printedAddr, &amp;ss)) &#123;</div><div class="line">        Log_error(ctx-&gt;logger, &quot;Invalid ip, setting ip address on TUN&quot;);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    ss.addr.flags |= Sockaddr_flags_PREFIX;</div><div class="line">    ss.addr.prefix = prefixLen;</div><div class="line"></div><div class="line">    bool installRoute = false;</div><div class="line">    if (Sockaddr_getFamily(&amp;ss.addr) == Sockaddr_AF_INET) &#123;</div><div class="line">        installRoute = (prefixLen &lt; 32);</div><div class="line">    &#125; else if (Sockaddr_getFamily(&amp;ss.addr) == Sockaddr_AF_INET6) &#123;</div><div class="line">        installRoute = (prefixLen &lt; 128);</div><div class="line">    &#125; else &#123;</div><div class="line">        Assert_failure(&quot;bad address family&quot;);</div><div class="line">    &#125;</div><div class="line">    if (installRoute) &#123;</div><div class="line">        RouteGen_addPrefix(ctx-&gt;rg, &amp;ss.addr);</div><div class="line">    &#125;</div><div class="line">    if (!ctx-&gt;ifName) &#123;</div><div class="line">        Log_error(ctx-&gt;logger, &quot;Failed to set IP address because TUN interface is not setup&quot;);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ss.addr.prefix = allocSize;</div><div class="line">    struct Jmp j;</div><div class="line">    Jmp_try(j) &#123;</div><div class="line">        NetDev_addAddress(ctx-&gt;ifName-&gt;bytes, &amp;ss.addr, ctx-&gt;logger, &amp;j.handler);</div><div class="line">    &#125; Jmp_catch &#123;</div><div class="line">        Log_error(ctx-&gt;logger, &quot;Error setting ip address on TUN [%s]&quot;, j.message);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里主要调用了两个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">RouteGen_addPrefix(ctx-&gt;rg, &amp;ss.addr);</div><div class="line">NetDev_addAddress(ctx-&gt;ifName-&gt;bytes, &amp;ss.addr, ctx-&gt;logger, &amp;j.handler);</div></pre></td></tr></table></figure></p>
<p>已经不是IpTunnel范围内的代码了，具体内容不分析了。<br>至此，向离岸点申请ipv4，收到回复后设置ipv4的过程就结束了。</p>
<h3 id="离岸点为每个允许连接过来的普通点建立一个IpTunnel-Connection"><a href="#离岸点为每个允许连接过来的普通点建立一个IpTunnel-Connection" class="headerlink" title="离岸点为每个允许连接过来的普通点建立一个IpTunnel_Connection"></a>离岸点为每个允许连接过来的普通点建立一个IpTunnel_Connection</h3><h4 id="conf文件配置-1"><a href="#conf文件配置-1" class="headerlink" title="conf文件配置"></a>conf文件配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&quot;allowedConnections&quot;: [</div><div class="line">        &#123;</div><div class="line">            &quot;ip4Address&quot;: &quot;192.168.254.2&quot;,</div><div class="line">            &quot;ip4Prefix&quot;: 0,</div><div class="line">            &quot;ip4Alloc&quot;: 32,</div><div class="line">            &quot;publicKey&quot;: &quot;uhmhts49tdm1ryb3q0pw95291uwt4xgvyk5s84vt2z2mnv3zp230.k&quot;</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            &quot;ip4Address&quot;: &quot;192.168.254.3&quot;,</div><div class="line">            &quot;ip4Prefix&quot;: 0,</div><div class="line">            &quot;ip4Alloc&quot;: 32,</div><div class="line">            &quot;publicKey&quot;: &quot;9c3x7hp181dv91tfkbngyhhu2uc3xhxuuh539l3g0gdjgjg1bs10.k&quot;</div><div class="line">        &#125;</div><div class="line">]</div></pre></td></tr></table></figure>
<h4 id="读取配置文件-1"><a href="#读取配置文件-1" class="headerlink" title="读取配置文件"></a>读取配置文件</h4><p>Configurator.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">List* incoming = Dict_getListC(ifaceConf, &quot;allowedConnections&quot;);</div><div class="line">if (incoming) &#123;</div><div class="line">    Dict* d;</div><div class="line">    for (int i = 0; (d = List_getDict(incoming, i)) != NULL; i++) &#123;</div><div class="line">        String* key = Dict_getStringC(d, &quot;publicKey&quot;);</div><div class="line">        String* ip4 = Dict_getStringC(d, &quot;ip4Address&quot;);</div><div class="line">        // Note that the prefix length has to be a proper int in the config</div><div class="line">        // (not quoted!)</div><div class="line">        int64_t* ip4Prefix = Dict_getIntC(d, &quot;ip4Prefix&quot;);</div><div class="line">        String* ip6 = Dict_getStringC(d, &quot;ip6Address&quot;);</div><div class="line">        int64_t* ip6Prefix = Dict_getIntC(d, &quot;ip6Prefix&quot;);</div><div class="line">        if (!key) &#123;</div><div class="line">            Log_critical(ctx-&gt;logger, &quot;In router.ipTunnel.allowedConnections[%d]&quot;</div><div class="line">                                      &quot;&apos;publicKey&apos; required.&quot;, i);</div><div class="line">            exit(1);</div><div class="line">        &#125;</div><div class="line">        if (!ip4 &amp;&amp; !ip6) &#123;</div><div class="line">            Log_critical(ctx-&gt;logger, &quot;In router.ipTunnel.allowedConnections[%d]&quot;</div><div class="line">                                      &quot;either &apos;ip4Address&apos; or &apos;ip6Address&apos; required.&quot;, i);</div><div class="line">            exit(1);</div><div class="line">        &#125; else if (ip4Prefix &amp;&amp; !ip4) &#123;</div><div class="line">            Log_critical(ctx-&gt;logger, &quot;In router.ipTunnel.allowedConnections[%d]&quot;</div><div class="line">                                      &quot;&apos;ip4Address&apos; required with &apos;ip4Prefix&apos;.&quot;, i);</div><div class="line">            exit(1);</div><div class="line">        &#125; else if (ip6Prefix &amp;&amp; !ip6) &#123;</div><div class="line">            Log_critical(ctx-&gt;logger, &quot;In router.ipTunnel.allowedConnections[%d]&quot;</div><div class="line">                                      &quot;&apos;ip6Address&apos; required with &apos;ip6Prefix&apos;.&quot;, i);</div><div class="line">            exit(1);</div><div class="line">        &#125;</div><div class="line">        Log_debug(ctx-&gt;logger, &quot;Allowing IpTunnel connections from [%s]&quot;, key-&gt;bytes);</div><div class="line"></div><div class="line">        if (ip4) &#123;</div><div class="line">            Log_debug(ctx-&gt;logger, &quot;Issue IPv4 address %s&quot;, ip4-&gt;bytes);</div><div class="line">            if (ip4Prefix) &#123;</div><div class="line">                Log_debug(ctx-&gt;logger, &quot;Issue IPv4 netmask/prefix length /%d&quot;,</div><div class="line">                    (int) *ip4Prefix);</div><div class="line">            &#125; else &#123;</div><div class="line">                Log_debug(ctx-&gt;logger, &quot;Use default netmask/prefix length /0&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (ip6) &#123;</div><div class="line">            Log_debug(ctx-&gt;logger, &quot;Issue IPv6 address [%s]&quot;, ip6-&gt;bytes);</div><div class="line">            if (ip6Prefix) &#123;</div><div class="line">                Log_debug(ctx-&gt;logger, &quot;Issue IPv6 netmask/prefix length /%d&quot;,</div><div class="line">                    (int) *ip6Prefix);</div><div class="line">            &#125; else &#123;</div><div class="line">                Log_debug(ctx-&gt;logger, &quot;Use default netmask/prefix length /0&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Dict_putStringC(d, &quot;publicKeyOfAuthorizedNode&quot;, key, tempAlloc);</div><div class="line">        rpcCall0(String_CONST(&quot;IpTunnel_allowConnection&quot;), d, ctx, tempAlloc, NULL, true);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>读取配置文件中allowedConnections中各个点的相关信息，rpcall调用IpTunnel_allowConnection方法。</p>
<h4 id="IpTunnel-allowConnection方法"><a href="#IpTunnel-allowConnection方法" class="headerlink" title="IpTunnel_allowConnection方法"></a>IpTunnel_allowConnection方法</h4><p>IpTunnel_admin.c<br>该方法在文件中注册为allowConnection函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">static void allowConnection(Dict* args,</div><div class="line">                            void* vcontext,</div><div class="line">                            String* txid,</div><div class="line">                            struct Allocator* requestAlloc)</div><div class="line">&#123;</div><div class="line">    struct Context* context = (struct Context*) vcontext;</div><div class="line">    String* publicKeyOfAuthorizedNode =</div><div class="line">        Dict_getStringC(args, &quot;publicKeyOfAuthorizedNode&quot;);</div><div class="line">    String* ip6Address = Dict_getStringC(args, &quot;ip6Address&quot;);</div><div class="line">    int64_t* ip6Prefix = Dict_getIntC(args, &quot;ip6Prefix&quot;);</div><div class="line">    int64_t* ip6Alloc = Dict_getIntC(args, &quot;ip6Alloc&quot;);</div><div class="line">    String* ip4Address = Dict_getStringC(args, &quot;ip4Address&quot;);</div><div class="line">    int64_t* ip4Prefix = Dict_getIntC(args, &quot;ip4Prefix&quot;);</div><div class="line">    int64_t* ip4Alloc = Dict_getIntC(args, &quot;ip4Alloc&quot;);</div><div class="line"></div><div class="line">    uint8_t pubKey[32];</div><div class="line">    uint8_t ip6Addr[16];</div><div class="line"></div><div class="line">    struct Sockaddr_storage ip6ToGive;</div><div class="line">    struct Sockaddr_storage ip4ToGive;</div><div class="line"></div><div class="line">    char* error;</div><div class="line">    int ret;</div><div class="line">    if (!ip6Address &amp;&amp; !ip4Address) &#123;</div><div class="line">        error = &quot;Must specify ip6Address or ip4Address&quot;;</div><div class="line">    &#125; else if ((ret = Key_parse(publicKeyOfAuthorizedNode, pubKey, ip6Addr)) != 0) &#123;</div><div class="line">        error = Key_parse_strerror(ret);</div><div class="line"></div><div class="line">    &#125; else if (ip6Prefix &amp;&amp; !ip6Address) &#123;</div><div class="line">        error = &quot;Must specify ip6Address with ip6Prefix&quot;;</div><div class="line">    &#125; else if (ip6Alloc &amp;&amp; !ip6Address) &#123;</div><div class="line">        error = &quot;Must specify ip6Address with ip6Alloc&quot;;</div><div class="line">    &#125; else if (ip6Prefix &amp;&amp; (*ip6Prefix &gt; 128 || *ip6Prefix &lt; 0)) &#123;</div><div class="line">        error = &quot;ip6Prefix out of range: must be 0 to 128&quot;;</div><div class="line">    &#125; else if (ip6Alloc &amp;&amp; (*ip6Alloc &gt; 128 || *ip6Alloc &lt; 1)) &#123;</div><div class="line">        error = &quot;ip6Alloc out of range: must be 1 to 128&quot;;</div><div class="line"></div><div class="line">    &#125; else if (ip4Prefix &amp;&amp; !ip4Address) &#123;</div><div class="line">        error = &quot;Must specify ip4Address with ip4Prefix&quot;;</div><div class="line">    &#125; else if (ip4Alloc &amp;&amp; !ip4Address) &#123;</div><div class="line">        error = &quot;Must specify ip4Address with ip4Alloc&quot;;</div><div class="line">    &#125; else if (ip4Prefix &amp;&amp; (*ip4Prefix &gt; 32 || *ip4Prefix &lt; 0)) &#123;</div><div class="line">        error = &quot;ip4Prefix out of range: must be 0 to 32&quot;;</div><div class="line">    &#125; else if (ip4Alloc &amp;&amp; (*ip4Alloc &gt; 32 || *ip4Alloc &lt; 1)) &#123;</div><div class="line">        error = &quot;ip4Alloc out of range: must be 1 to 32&quot;;</div><div class="line"></div><div class="line">    &#125; else if (ip6Address</div><div class="line">        &amp;&amp; (Sockaddr_parse(ip6Address-&gt;bytes, &amp;ip6ToGive)</div><div class="line">            || Sockaddr_getFamily(&amp;ip6ToGive.addr) != Sockaddr_AF_INET6))</div><div class="line">    &#123;</div><div class="line">        error = &quot;malformed ip6Address&quot;;</div><div class="line">    &#125; else if (ip4Address</div><div class="line">        &amp;&amp; (Sockaddr_parse(ip4Address-&gt;bytes, &amp;ip4ToGive)</div><div class="line">            || Sockaddr_getFamily(&amp;ip4ToGive.addr) != Sockaddr_AF_INET))</div><div class="line">    &#123;</div><div class="line">        error = &quot;malformed ip4Address&quot;;</div><div class="line">    &#125; else &#123;</div><div class="line">        int conn = IpTunnel_allowConnection(pubKey,</div><div class="line">                                            (ip6Address) ? &amp;ip6ToGive.addr : NULL,</div><div class="line">                                            (ip6Prefix) ? (uint8_t) (*ip6Prefix) : 128,</div><div class="line">                                            (ip6Alloc) ? (uint8_t) (*ip6Alloc) : 128,</div><div class="line">                                            (ip4Address) ? &amp;ip4ToGive.addr : NULL,</div><div class="line">                                            (ip4Prefix) ? (uint8_t) (*ip4Prefix) : 32,</div><div class="line">                                            (ip4Alloc) ? (uint8_t) (*ip4Alloc) : 32,</div><div class="line">                                            context-&gt;ipTun);</div><div class="line">        sendResponse(conn, txid, context-&gt;admin);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    sendError(error, txid, context-&gt;admin);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>获取conf中该连接的相关信息，验证其合法性，调用IpTunnel_allowConnection方法，建立IpTunnel_Connection。</p>
<h4 id="IpTunnel-allowConnection方法-1"><a href="#IpTunnel-allowConnection方法-1" class="headerlink" title="IpTunnel_allowConnection方法"></a>IpTunnel_allowConnection方法</h4><p>IpTunnel.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">int IpTunnel_allowConnection(uint8_t publicKeyOfAuthorizedNode[32],</div><div class="line">                             struct Sockaddr* ip6Addr,</div><div class="line">                             uint8_t ip6Prefix,</div><div class="line">                             uint8_t ip6Alloc,</div><div class="line">                             struct Sockaddr* ip4Addr,</div><div class="line">                             uint8_t ip4Prefix,</div><div class="line">                             uint8_t ip4Alloc,</div><div class="line">                             struct IpTunnel* tunnel)</div><div class="line">&#123;</div><div class="line">    struct IpTunnel_pvt* context = Identity_check((struct IpTunnel_pvt*)tunnel);</div><div class="line"></div><div class="line">    Log_debug(context-&gt;logger, &quot;IPv4 Prefix to allow: %d&quot;, ip4Prefix);</div><div class="line"></div><div class="line">    uint8_t* ip6Address = NULL;</div><div class="line">    uint8_t* ip4Address = NULL;</div><div class="line">    if (ip6Addr) &#123;</div><div class="line">        Sockaddr_getAddress(ip6Addr, &amp;ip6Address);</div><div class="line">    &#125;</div><div class="line">    if (ip4Addr) &#123;</div><div class="line">        Sockaddr_getAddress(ip4Addr, &amp;ip4Address);</div><div class="line">    &#125;</div><div class="line">    Log_debug(context-&gt;logger, &quot;noti outgoing call by IpTunnel_allowConnection&quot;);</div><div class="line">    struct IpTunnel_Connection* conn = newConnection(false, context);</div><div class="line">    Bits_memcpy(conn-&gt;routeHeader.publicKey, publicKeyOfAuthorizedNode, 32);</div><div class="line">    AddressCalc_addressForPublicKey(conn-&gt;routeHeader.ip6, publicKeyOfAuthorizedNode);</div><div class="line">    if (ip4Address) &#123;</div><div class="line">        Bits_memcpy(conn-&gt;connectionIp4, ip4Address, 4);</div><div class="line">        conn-&gt;connectionIp4Prefix = ip4Prefix;</div><div class="line">        conn-&gt;connectionIp4Alloc = ip4Alloc;</div><div class="line">        Assert_true(ip4Alloc);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (ip6Address) &#123;</div><div class="line">        Bits_memcpy(conn-&gt;connectionIp6, ip6Address, 16);</div><div class="line">        conn-&gt;connectionIp6Prefix = ip6Prefix;</div><div class="line">        conn-&gt;connectionIp6Alloc = ip6Alloc;</div><div class="line">        Assert_true(ip6Alloc);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return conn-&gt;number;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里主要三个操作：</p>
<ol>
<li>调用newConnection(true, context)创建一个IpTunnel_Connection类型的conn。</li>
<li>将conf配置中的publicKey信息赋值给conn-&gt;routeHeader.publicKey</li>
<li>将conf配置中的ip相关信息赋值给conn相关字段 </li>
</ol>
<h4 id="创建一个IpTunnel-Connection类型的conn-1"><a href="#创建一个IpTunnel-Connection类型的conn-1" class="headerlink" title="创建一个IpTunnel_Connection类型的conn"></a>创建一个IpTunnel_Connection类型的conn</h4><p>调用newConnection方法。<br>IpTunnel.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">static struct IpTunnel_Connection* newConnection(bool isOutgoing, struct IpTunnel_pvt* context)</div><div class="line">&#123;</div><div class="line">    if (context-&gt;pub.connectionList.count == context-&gt;connectionCapacity) &#123;</div><div class="line">        uint32_t newSize = (context-&gt;connectionCapacity + 4) * sizeof(struct IpTunnel_Connection);</div><div class="line">        context-&gt;pub.connectionList.connections =</div><div class="line">            Allocator_realloc(context-&gt;allocator, context-&gt;pub.connectionList.connections, newSize);</div><div class="line">        context-&gt;connectionCapacity += 4;</div><div class="line">    &#125;</div><div class="line">    struct IpTunnel_Connection* conn =</div><div class="line">        &amp;context-&gt;pub.connectionList.connections[context-&gt;pub.connectionList.count];</div><div class="line"></div><div class="line">    // If it&apos;s an incoming connection, it must be lower on the list than any outgoing connections.</div><div class="line">    if (!isOutgoing) &#123;</div><div class="line">        for (int i = (int)context-&gt;pub.connectionList.count - 1; i &gt;= 0; i--) &#123;</div><div class="line">            if (!context-&gt;pub.connectionList.connections[i].isOutgoing</div><div class="line">                &amp;&amp; conn != &amp;context-&gt;pub.connectionList.connections[i + 1])</div><div class="line">            &#123;</div><div class="line">                Bits_memcpy(conn,</div><div class="line">                                 &amp;context-&gt;pub.connectionList.connections[i + 1],</div><div class="line">                                 sizeof(struct IpTunnel_Connection));</div><div class="line">                conn = &amp;context-&gt;pub.connectionList.connections[i + 1];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    context-&gt;pub.connectionList.count++;</div><div class="line"></div><div class="line">    Bits_memset(conn, 0, sizeof(struct IpTunnel_Connection));</div><div class="line">    conn-&gt;number = context-&gt;nextConnectionNumber++;</div><div class="line">    conn-&gt;isOutgoing = isOutgoing;</div><div class="line">    conn-&gt;reachable = false;</div><div class="line"></div><div class="line">    // if there are 2 billion calls, die.</div><div class="line">    Assert_true(context-&gt;nextConnectionNumber &lt; (UINT32_MAX &gt;&gt; 1));</div><div class="line"></div><div class="line">    return conn;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第一个参数指定了是否为离岸点，其他部分没什么特别，普通的赋值操作。</p>
<h4 id="收到其他点发送来的分配地址的请求"><a href="#收到其他点发送来的分配地址的请求" class="headerlink" title="收到其他点发送来的分配地址的请求"></a>收到其他点发送来的分配地址的请求</h4><p>所有从其他点发送过来，进入IpTunnel的数据，都先到incomingFromNode方法中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">static Iface_DEFUN incomingFromNode(struct Message* message, struct Iface* nodeIf)</div><div class="line">&#123;</div><div class="line">    struct IpTunnel_pvt* context =</div><div class="line">        Identity_containerOf(nodeIf, struct IpTunnel_pvt, pub.nodeInterface);</div><div class="line"></div><div class="line">    //Log_debug(context-&gt;logger, &quot;Got incoming message&quot;);</div><div class="line"></div><div class="line">    Assert_true(message-&gt;length &gt;= RouteHeader_SIZE + DataHeader_SIZE);</div><div class="line">    struct RouteHeader* rh = (struct RouteHeader*) message-&gt;bytes;</div><div class="line">    struct DataHeader* dh = (struct DataHeader*) &amp;rh[1];</div><div class="line">    Assert_true(DataHeader_getContentType(dh) == ContentType_IPTUN);</div><div class="line">    struct IpTunnel_Connection* conn = connectionByPubKey(rh-&gt;publicKey, context);</div><div class="line">    if (!conn) &#123;</div><div class="line">        if (Defined(Log_DEBUG)) &#123;</div><div class="line">            uint8_t addr[40];</div><div class="line">            AddrTools_printIp(addr, rh-&gt;ip6);</div><div class="line">            Log_debug(context-&gt;logger, &quot;Got message from unrecognized node [%s]&quot;, addr);</div><div class="line">        &#125;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Message_shift(message, -(RouteHeader_SIZE + DataHeader_SIZE), NULL);</div><div class="line"></div><div class="line">    if (message-&gt;length &gt; 40 &amp;&amp; Headers_getIpVersion(message-&gt;bytes) == 6) &#123;</div><div class="line">        return ip6FromNode(message, conn, context);</div><div class="line">    &#125;</div><div class="line">    if (message-&gt;length &gt; 20 &amp;&amp; Headers_getIpVersion(message-&gt;bytes) == 4) &#123;</div><div class="line">        return ip4FromNode(message, conn, context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (Defined(Log_DEBUG)) &#123;</div><div class="line">        uint8_t addr[40];</div><div class="line">        AddrTools_printIp(addr, rh-&gt;ip6);</div><div class="line">        Log_debug(context-&gt;logger,</div><div class="line">                  &quot;Got message of unknown type, length: [%d], IP version [%d] from [%s]&quot;,</div><div class="line">                  message-&gt;length,</div><div class="line">                  (message-&gt;length &gt; 1) ? Headers_getIpVersion(message-&gt;bytes) : 0,</div><div class="line">                  addr);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li><p>通过publicKey找到对应的conn。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">struct IpTunnel_Connection* conn = connectionByPubKey(rh-&gt;publicKey, context);</div></pre></td></tr></table></figure>
</li>
<li><p>调用ip6FromNode</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (message-&gt;length &gt; 40 &amp;&amp; Headers_getIpVersion(message-&gt;bytes) == 6) &#123;</div><div class="line">    return ip6FromNode(message, conn, context);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">static Iface_DEFUN ip6FromNode(struct Message* message,</div><div class="line">                               struct IpTunnel_Connection* conn,</div><div class="line">                               struct IpTunnel_pvt* context)</div><div class="line">&#123;</div><div class="line">    struct Headers_IP6Header* header = (struct Headers_IP6Header*) message-&gt;bytes;</div><div class="line">    if (Bits_isZero(header-&gt;sourceAddr, 16) || Bits_isZero(header-&gt;destinationAddr, 16)) &#123;</div><div class="line">        if (Bits_isZero(header-&gt;sourceAddr, 32)) &#123;</div><div class="line">            return incomingControlMessage(message, conn, context);</div><div class="line">        &#125;</div><div class="line">        ......</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    if (!isValidAddress6(header-&gt;sourceAddr, false, conn)) &#123;</div><div class="line">        ......</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">    return Iface_next(&amp;context-&gt;pub.tunInterface, message);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此时header-&gt;sourceAddr为全0，会调用到incomingControlMessage方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">static Iface_DEFUN incomingControlMessage(struct Message* message,</div><div class="line">                                          struct IpTunnel_Connection* conn,</div><div class="line">                                          struct IpTunnel_pvt* context)</div><div class="line">&#123;</div><div class="line">       ......</div><div class="line">    Dict* d = NULL;</div><div class="line">    char* err = BencMessageReader_readNoExcept(message, alloc, &amp;d);</div><div class="line">    if (err) &#123;</div><div class="line">        Log_info(context-&gt;logger, &quot;Failed to parse message [%s]&quot;, err);</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">     ....</div><div class="line">    if (String_equals(String_CONST(&quot;IpTunnel_getAddresses&quot;),</div><div class="line">                      Dict_getStringC(d, &quot;q&quot;)))</div><div class="line">    &#123;</div><div class="line">        return requestForAddresses(d, conn, alloc, context);</div><div class="line">    &#125;</div><div class="line">    Log_warn(context-&gt;logger, &quot;Message which is unhandled&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为普通点在向离岸点发送分配ipv4地址的请求时，会将q字段的值设为IpTunnel_getAddresses，所以，在离岸点收到这类信息时，会调用到requestForAddresses方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">static Iface_DEFUN requestForAddresses(Dict* request,</div><div class="line">                                       struct IpTunnel_Connection* conn,</div><div class="line">                                       struct Allocator* requestAlloc,</div><div class="line">                                       struct IpTunnel_pvt* context)</div><div class="line">&#123;</div><div class="line">    ......</div><div class="line">    Dict* addresses = Dict_new(requestAlloc);</div><div class="line">    bool noAddresses = true;</div><div class="line">    if (!Bits_isZero(conn-&gt;connectionIp6, 16)) &#123;</div><div class="line">        ......</div><div class="line">    &#125;</div><div class="line">    if (!Bits_isZero(conn-&gt;connectionIp4, 4)) &#123;</div><div class="line">        Dict_putStringC(addresses,</div><div class="line">                       &quot;ip4&quot;,</div><div class="line">                       String_newBinary((char*)conn-&gt;connectionIp4, 4, requestAlloc),</div><div class="line">                       requestAlloc);</div><div class="line">        Dict_putIntC(addresses,</div><div class="line">                    &quot;ip4Prefix&quot;, (int64_t)conn-&gt;connectionIp4Prefix,</div><div class="line">                    requestAlloc);</div><div class="line">        Dict_putIntC(addresses,</div><div class="line">                    &quot;ip4Alloc&quot;, (int64_t)conn-&gt;connectionIp4Alloc,</div><div class="line">                    requestAlloc);</div><div class="line"></div><div class="line">        noAddresses = false;</div><div class="line">    &#125;</div><div class="line">    if (noAddresses) &#123;</div><div class="line">        Log_warn(context-&gt;logger, &quot;no addresses to provide&quot;);</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Dict* msg = Dict_new(requestAlloc);</div><div class="line">    Dict_putDictC(msg, &quot;addresses&quot;, addresses, requestAlloc);</div><div class="line"></div><div class="line">    String* txid = Dict_getStringC(request, &quot;txid&quot;);</div><div class="line">    if (txid) &#123;</div><div class="line">        Dict_putStringC(msg, &quot;txid&quot;, txid, requestAlloc);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    sendControlMessage(msg, conn, requestAlloc, context);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>将conf文件中，分配给这个连接的ipv4地址相关信息，填入addresses中，再将key为addresses，value为addresses的键值对，放入Dict中，调用sendControlMessage发送出去。当普通点收到这个回复后，会从中取出addresses，并进行ipv4相关字段的设置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">static void sendControlMessage(Dict* dict,</div><div class="line">                               struct IpTunnel_Connection* connection,</div><div class="line">                               struct Allocator* requestAlloc,</div><div class="line">                               struct IpTunnel_pvt* context)</div><div class="line">&#123;</div><div class="line">    struct Message* msg = Message_new(0, 1024, requestAlloc);</div><div class="line">    BencMessageWriter_write(dict, msg, NULL);</div><div class="line"></div><div class="line">    int length = msg-&gt;length;</div><div class="line"></div><div class="line">    // do UDP header.</div><div class="line">    Message_shift(msg, Headers_UDPHeader_SIZE, NULL);</div><div class="line">    struct Headers_UDPHeader* uh = (struct Headers_UDPHeader*) msg-&gt;bytes;</div><div class="line">    uh-&gt;srcPort_be = 0;</div><div class="line">    uh-&gt;destPort_be = 0;</div><div class="line">    uh-&gt;length_be = Endian_hostToBigEndian16(length);</div><div class="line">    uh-&gt;checksum_be = 0;</div><div class="line"></div><div class="line">    uint16_t payloadLength = msg-&gt;length;</div><div class="line"></div><div class="line">    Message_shift(msg, Headers_IP6Header_SIZE, NULL);</div><div class="line">    struct Headers_IP6Header* header = (struct Headers_IP6Header*) msg-&gt;bytes;</div><div class="line">    header-&gt;versionClassAndFlowLabel = 0;</div><div class="line">    header-&gt;flowLabelLow_be = 0;</div><div class="line">    header-&gt;nextHeader = 17;</div><div class="line">    header-&gt;hopLimit = 0;</div><div class="line">    header-&gt;payloadLength_be = Endian_hostToBigEndian16(payloadLength);</div><div class="line">    Headers_setIpVersion(header);</div><div class="line"></div><div class="line">    // zero the source and dest addresses.</div><div class="line">    Bits_memset(header-&gt;sourceAddr, 0, 32);</div><div class="line"></div><div class="line">    uh-&gt;checksum_be = Checksum_udpIp6(header-&gt;sourceAddr,</div><div class="line">                                      (uint8_t*) uh,</div><div class="line">                                      msg-&gt;length - Headers_IP6Header_SIZE);</div><div class="line"></div><div class="line">    Iface_CALL(sendToNode, msg, connection, context);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>调用sendToNode<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">static Iface_DEFUN sendToNode(struct Message* message,</div><div class="line">                              struct IpTunnel_Connection* connection,</div><div class="line">                              struct IpTunnel_pvt* context)</div><div class="line">&#123;</div><div class="line">    Message_push(message, NULL, DataHeader_SIZE, NULL);</div><div class="line">    struct DataHeader* dh = (struct DataHeader*) message-&gt;bytes;</div><div class="line">    DataHeader_setContentType(dh, ContentType_IPTUN);</div><div class="line">    DataHeader_setVersion(dh, DataHeader_CURRENT_VERSION);</div><div class="line">    Message_push(message, &amp;connection-&gt;routeHeader, RouteHeader_SIZE, NULL);</div><div class="line">    return Iface_next(&amp;context-&gt;pub.nodeInterface, message);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>至此，离岸点在收到普通点的ipv4分配申请后的执行流程分析完毕。</p>
<h2 id="处理从其他点发来的消息"><a href="#处理从其他点发来的消息" class="headerlink" title="处理从其他点发来的消息"></a>处理从其他点发来的消息</h2><p>上面讲到，所有从其他点发送过来，进入IpTunnel的数据，都先到incomingFromNode方法中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">static Iface_DEFUN incomingFromNode(struct Message* message, struct Iface* nodeIf)</div><div class="line">&#123;</div><div class="line">    struct IpTunnel_pvt* context =</div><div class="line">        Identity_containerOf(nodeIf, struct IpTunnel_pvt, pub.nodeInterface);</div><div class="line"></div><div class="line">    Assert_true(message-&gt;length &gt;= RouteHeader_SIZE + DataHeader_SIZE);</div><div class="line">    struct RouteHeader* rh = (struct RouteHeader*) message-&gt;bytes;</div><div class="line">    struct DataHeader* dh = (struct DataHeader*) &amp;rh[1];</div><div class="line">    Assert_true(DataHeader_getContentType(dh) == ContentType_IPTUN);</div><div class="line">    struct IpTunnel_Connection* conn = connectionByPubKey(rh-&gt;publicKey, context);</div><div class="line">    if (!conn) &#123;</div><div class="line">        if (Defined(Log_DEBUG)) &#123;</div><div class="line">            uint8_t addr[40];</div><div class="line">            AddrTools_printIp(addr, rh-&gt;ip6);</div><div class="line">            Log_debug(context-&gt;logger, &quot;Got message from unrecognized node [%s]&quot;, addr);</div><div class="line">        &#125;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Message_shift(message, -(RouteHeader_SIZE + DataHeader_SIZE), NULL);</div><div class="line"></div><div class="line">    if (message-&gt;length &gt; 40 &amp;&amp; Headers_getIpVersion(message-&gt;bytes) == 6) &#123;</div><div class="line">        return ip6FromNode(message, conn, context);</div><div class="line">    &#125;</div><div class="line">    if (message-&gt;length &gt; 20 &amp;&amp; Headers_getIpVersion(message-&gt;bytes) == 4) &#123;</div><div class="line">        return ip4FromNode(message, conn, context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (Defined(Log_DEBUG)) &#123;</div><div class="line">        uint8_t addr[40];</div><div class="line">        AddrTools_printIp(addr, rh-&gt;ip6);</div><div class="line">        Log_debug(context-&gt;logger,</div><div class="line">                  &quot;Got message of unknown type, length: [%d], IP version [%d] from [%s]&quot;,</div><div class="line">                  message-&gt;length,</div><div class="line">                  (message-&gt;length &gt; 1) ? Headers_getIpVersion(message-&gt;bytes) : 0,</div><div class="line">                  addr);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以ipv4为例，进入到ip4FromNode<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">static Iface_DEFUN ip4FromNode(struct Message* message,</div><div class="line">                               struct IpTunnel_Connection* conn,</div><div class="line">                               struct IpTunnel_pvt* context)</div><div class="line">&#123;</div><div class="line">    struct Headers_IP4Header* header = (struct Headers_IP4Header*) message-&gt;bytes;</div><div class="line">    if (Bits_isZero(header-&gt;sourceAddr, 4) || Bits_isZero(header-&gt;destAddr, 4)) &#123;</div><div class="line">        Log_debug(context-&gt;logger, &quot;Got message with zero address&quot;);</div><div class="line">        return 0;</div><div class="line">    &#125; else if (!isValidAddress4(header-&gt;sourceAddr, false, conn)) &#123;</div><div class="line">        Log_debug(context-&gt;logger, &quot;Got message with wrong address [%d.%d.%d.%d] for connection &quot;</div><div class="line">                                   &quot;[%d.%d.%d.%d/%d:%d]&quot;,</div><div class="line">                  header-&gt;sourceAddr[0], header-&gt;sourceAddr[1],</div><div class="line">                  header-&gt;sourceAddr[2], header-&gt;sourceAddr[3],</div><div class="line">                  conn-&gt;connectionIp4[0], conn-&gt;connectionIp4[1],</div><div class="line">                  conn-&gt;connectionIp4[2], conn-&gt;connectionIp4[3],</div><div class="line">                  conn-&gt;connectionIp4Alloc, conn-&gt;connectionIp4Prefix);</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    Log_debug(context-&gt;logger, &quot;jin Got message with address [%d.%d.%d.%d] for connection &quot;</div><div class="line">                                   &quot;[%d.%d.%d.%d/%d:%d]&quot;,</div><div class="line">                  header-&gt;sourceAddr[0], header-&gt;sourceAddr[1],</div><div class="line">                  header-&gt;sourceAddr[2], header-&gt;sourceAddr[3],</div><div class="line">                  conn-&gt;connectionIp4[0], conn-&gt;connectionIp4[1],</div><div class="line">                  conn-&gt;connectionIp4[2], conn-&gt;connectionIp4[3],</div><div class="line">                  conn-&gt;connectionIp4Alloc, conn-&gt;connectionIp4Prefix);</div><div class="line">    TUNMessageType_push(message, Ethernet_TYPE_IP4, NULL);</div><div class="line">    return Iface_next(&amp;context-&gt;pub.tunInterface, message);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>此时，header-&gt;sourceAddr是对方的ipv4地址，不会为全0，代码进入到一个ip地址合法性判断：isValidAddress4(header-&gt;sourceAddr, false, conn)。如果地址合法，消息进一步发送到context-&gt;pub.tunInterface中。<br>tunInterface是一个Iface，它的回调函数在IpTunnel_new中设置为incomingFromTun<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.pub = &#123;</div><div class="line">    .tunInterface = &#123; .send = incomingFromTun &#125;,</div><div class="line">&#125;,</div></pre></td></tr></table></figure></p>
<p>它的connectedIf在Core.c的Core_init方法中通过Iface_plumb方法与nc-&gt;tunAdapt-&gt;ipTunnelIf绑定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Iface_plumb(&amp;nc-&gt;tunAdapt-&gt;ipTunnelIf, &amp;ipTunnel-&gt;tunInterface);</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">static inline void Iface_plumb(struct Iface* a, struct Iface* b)</div><div class="line">&#123;</div><div class="line">    Assert_true(!a-&gt;connectedIf);</div><div class="line">    Assert_true(!b-&gt;connectedIf);</div><div class="line">    a-&gt;connectedIf = b;</div><div class="line">    b-&gt;connectedIf = a;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="查看地址合法性判断"><a href="#查看地址合法性判断" class="headerlink" title="查看地址合法性判断"></a>查看地址合法性判断</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">static bool isValidAddress4(uint8_t sourceAndDestIp4[8],</div><div class="line">                            bool isFromTun,</div><div class="line">                            struct IpTunnel_Connection* conn)</div><div class="line">&#123;</div><div class="line">    uint8_t* compareAddr = (isFromTun)</div><div class="line">        ? ((conn-&gt;isOutgoing) ? sourceAndDestIp4 : &amp;sourceAndDestIp4[4])</div><div class="line">        : ((conn-&gt;isOutgoing) ? &amp;sourceAndDestIp4[4] : sourceAndDestIp4);</div><div class="line">    return prefixMatches4(compareAddr, conn-&gt;connectionIp4, conn-&gt;connectionIp4Alloc);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ifFromTun为false，接下来根据isOutgoing的值来决定compareAddr的值，分为两种情况</p>
<ol>
<li>当前点是普通点，那么他收到的消息是从离岸点发送过来的，isOutgoing为<br>true，compareAddr赋值为sourceAndDestIp4[4]，也就是dest ip,从离岸点发来的包的dest ip就是当前这个普通点的ipv4地址。</li>
<li>当前点是离岸点，那么它收到的消息是从普通点发送过来的，isOutgoing为<br>false，compareAddr赋值为sourceAndDestIp4，也就是source ip，从普通点发来的包的source ip就是普通点的ipv4地址。<br>综上，compareAddr一定会被赋值为普通点的ipv4地址。接下来调用prefixMatches4方法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">static bool prefixMatches4(uint8_t* addressA, uint8_t* refAddr, uint32_t prefixLen)</div><div class="line">&#123;</div><div class="line">    if (!prefixLen) &#123;</div><div class="line">        Assert_true(Bits_isZero(refAddr, 4));</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">    Assert_true(prefixLen &amp;&amp; prefixLen &lt;= 32);</div><div class="line">    uint32_t a = GET32(addressA);</div><div class="line">    uint32_t b = GET32(refAddr);</div><div class="line">    return !((a ^ b) &gt;&gt; (32 - prefixLen));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这就只是一个简单的地址比较了。</p>
<h2 id="处理从Tun设备发来的消息"><a href="#处理从Tun设备发来的消息" class="headerlink" title="处理从Tun设备发来的消息"></a>处理从Tun设备发来的消息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">static Iface_DEFUN incomingFromTun(struct Message* message, struct Iface* tunIf)</div><div class="line">&#123;</div><div class="line">    struct IpTunnel_pvt* context = Identity_check((struct IpTunnel_pvt*)tunIf);</div><div class="line"></div><div class="line">    if (message-&gt;length &lt; 20) &#123;</div><div class="line">        Log_debug(context-&gt;logger, &quot;DROP runt&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    struct IpTunnel_Connection* conn = NULL;</div><div class="line">    if (!context-&gt;pub.connectionList.connections) &#123;</div><div class="line">        // No connections authorized, fall through to &quot;unrecognized address&quot;</div><div class="line">    &#125; else if (message-&gt;length &gt; 40 &amp;&amp; Headers_getIpVersion(message-&gt;bytes) == 6) &#123;</div><div class="line">        struct Headers_IP6Header* header = (struct Headers_IP6Header*) message-&gt;bytes;</div><div class="line">        conn = findConnection(header-&gt;sourceAddr, NULL, true, context);</div><div class="line">    &#125; else if (message-&gt;length &gt; 20 &amp;&amp; Headers_getIpVersion(message-&gt;bytes) == 4) &#123;</div><div class="line">        struct Headers_IP4Header* header = (struct Headers_IP4Header*) message-&gt;bytes;</div><div class="line">        conn = findConnection(NULL, header-&gt;sourceAddr, true, context);</div><div class="line">    &#125; else &#123;</div><div class="line">        Log_info(context-&gt;logger, &quot;Message of unknown type from TUN&quot;);</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (!conn) &#123;</div><div class="line">        Log_info(context-&gt;logger, &quot;Message with unrecognized address from TUN&quot;);</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return sendToNode(message, conn, context);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里主要进行了两个操作：</p>
<ol>
<li>调用findConnection查找conn</li>
<li>调用sendToNode</li>
</ol>
<h3 id="查找conn"><a href="#查找conn" class="headerlink" title="查找conn"></a>查找conn</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">static struct IpTunnel_Connection* findConnection(uint8_t sourceAndDestIp6[32],</div><div class="line">                                                  uint8_t sourceAndDestIp4[8],</div><div class="line">                                                  bool isFromTun,</div><div class="line">                                                  struct IpTunnel_pvt* context)</div><div class="line">&#123;</div><div class="line">    for (int i = 0; i &lt; (int)context-&gt;pub.connectionList.count; i++) &#123;</div><div class="line">        struct IpTunnel_Connection* conn = &amp;context-&gt;pub.connectionList.connections[i];</div><div class="line">        if (sourceAndDestIp6 &amp;&amp; isValidAddress6(sourceAndDestIp6, isFromTun, conn)) &#123;</div><div class="line">            return conn;</div><div class="line">        &#125;</div><div class="line">        if (sourceAndDestIp4 &amp;&amp; isValidAddress4(sourceAndDestIp4, isFromTun, conn)) &#123;</div><div class="line">            return conn;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return NULL;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以ipv4为例，调用isValidAddress4检查地址合法性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">static bool isValidAddress4(uint8_t sourceAndDestIp4[8],</div><div class="line">                            bool isFromTun,</div><div class="line">                            struct IpTunnel_Connection* conn)</div><div class="line">&#123;</div><div class="line">    uint8_t* compareAddr = (isFromTun)</div><div class="line">        ? ((conn-&gt;isOutgoing) ? sourceAndDestIp4 : &amp;sourceAndDestIp4[4])</div><div class="line">        : ((conn-&gt;isOutgoing) ? &amp;sourceAndDestIp4[4] : sourceAndDestIp4);</div><div class="line">    return prefixMatches4(compareAddr, conn-&gt;connectionIp4, conn-&gt;connectionIp4Alloc);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ifFromTun为true，接下来根据isOutgoing的值来决定compareAddr的值，分为两种情况</p>
<ol>
<li>当前点是普通点，那么他的消息是发往离岸点的，isOutgoing为<br>true，compareAddr赋值为sourceAndDestIp4，也就是source ip,是当前这个普通点的ipv4地址。</li>
<li>当前点是离岸点，那么他的消息是发往普通点的，isOutgoing为<br>false，compareAddr赋值为sourceAndDestIp4[4]，也就是dest ip，发往普通点的包的dest ip就是普通点的ipv4地址。<br>综上，compareAddr一定会被赋值为普通点的ipv4地址。接下来调用prefixMatches4方法，进行地址对比。</li>
</ol>
<h3 id="sendToNode"><a href="#sendToNode" class="headerlink" title="sendToNode"></a>sendToNode</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">static Iface_DEFUN sendToNode(struct Message* message,</div><div class="line">                              struct IpTunnel_Connection* connection,</div><div class="line">                              struct IpTunnel_pvt* context)</div><div class="line">&#123;</div><div class="line">    Message_push(message, NULL, DataHeader_SIZE, NULL);</div><div class="line">    struct DataHeader* dh = (struct DataHeader*) message-&gt;bytes;</div><div class="line">    DataHeader_setContentType(dh, ContentType_IPTUN);</div><div class="line">    DataHeader_setVersion(dh, DataHeader_CURRENT_VERSION);</div><div class="line">    Message_push(message, &amp;connection-&gt;routeHeader, RouteHeader_SIZE, NULL);</div><div class="line">    return Iface_next(&amp;context-&gt;pub.nodeInterface, message);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至此，IpTunnel收到从Tun上和从其他点发来的包，并进行处理的过程分析完成。</p>
<h2 id="需求描述"><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h2><p>假设有一个连接到离岸点上的普通点A，离岸点分配给它的ipv4地址是192.168.253.111.同时A是内网net中的一个点，内网地址192.168.2.111  这时，内网net中的另一个点B，内网地址为192.168.2.222.B将A设置为网关，想要通过A访问外网。以向外发包为例，这个包的src地址是192.168.2.222.这是一个内网地址。<br>当前实现中，当离岸点收到这个由B发出的，经由A点的数据包时，会进行一个对于ip地址的判断。对于离岸点来说，这个包是A发送过来的，离岸点会找到对应着A的conn，进行一次地址判断。判断中，会发现这个src地址和离岸点分配给A点的ipv4地址不符。然后离岸点会丢弃这个包。外网向B点回包过程的也会经历这个地址判断的过程，离岸点也会丢弃地址不符的包。<br>现在需要一个机制，能让A代理所有内网中的包。也就是A会向离岸点报告自己代理的内网的网段。当离岸点收到src或者dst为该内网网段地址的包时，离岸点知道这个包应该交给A处理。</p>
<h2 id="方案设计"><a href="#方案设计" class="headerlink" title="方案设计"></a>方案设计</h2><h3 id="A点的conf中加入关于代理网段的信息"><a href="#A点的conf中加入关于代理网段的信息" class="headerlink" title="A点的conf中加入关于代理网段的信息"></a>A点的conf中加入关于代理网段的信息</h3><p>在A点的conf文件中加入代理网段的信息<br>同时，在读取conf的过程中，获取代理网段的信息，并调用IpTunnel中相应的方法，将代理网段的信息通知给离岸点。</p>
<h3 id="IpTunnel-Connection增加字段"><a href="#IpTunnel-Connection增加字段" class="headerlink" title="IpTunnel_Connection增加字段"></a>IpTunnel_Connection增加字段</h3><p>增加一个bool型字段useIntranet，标示当前连接是否使用了网段代理<br>增加一个ip地址地址字段和一个mask字段，共同标识内网网段信息</p>
<h3 id="普通点标注自己是一个带有网段代理功能的点"><a href="#普通点标注自己是一个带有网段代理功能的点" class="headerlink" title="普通点标注自己是一个带有网段代理功能的点"></a>普通点标注自己是一个带有网段代理功能的点</h3><p>普通点修改自己和离岸点的IpTunnel_Connection，增加代理网段信息，并标注当前连接使用了网段代理功能</p>
<h3 id="普通点通知离岸点，自己的代理网段"><a href="#普通点通知离岸点，自己的代理网段" class="headerlink" title="普通点通知离岸点，自己的代理网段"></a>普通点通知离岸点，自己的代理网段</h3><p>普通点将自己代理的网段信息发送给离岸点<br>离岸点将网段信息记录到该普通点对应的conn当中，并标注当前连接使用了网段代理功能</p>
<h3 id="在ip地址合法性检查时，增加对代理网段的判断"><a href="#在ip地址合法性检查时，增加对代理网段的判断" class="headerlink" title="在ip地址合法性检查时，增加对代理网段的判断"></a>在ip地址合法性检查时，增加对代理网段的判断</h3><p>除了当前已经有的直接对比ip地址的操作之外，根据是否标注了使用网段代理功能，配合代理网段的值，查看当前包是否是一个代理网段的包，并找到可以处理这个包的普通点。</p>

      
    </div>
    
  </div>
  
    


    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2017/07/31/build-intranet-test/">
                    一个简单的内外网连通实验
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2017/04/27/about-iptables/">
                    iptables在anet项目中的运用
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目錄</strong>
        
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#源码分析"><span class="toc-number">1.</span> <span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#结构体"><span class="toc-number">1.1.</span> <span class="toc-text">结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#conf文件起到的作用"><span class="toc-number">1.2.</span> <span class="toc-text">conf文件起到的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#普通点建立一个离岸点的IpTunnel-Connection"><span class="toc-number">1.3.</span> <span class="toc-text">普通点建立一个离岸点的IpTunnel_Connection</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#conf文件配置"><span class="toc-number">1.3.1.</span> <span class="toc-text">conf文件配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#读取配置文件"><span class="toc-number">1.3.2.</span> <span class="toc-text">读取配置文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IpTunnel-connectTo方法"><span class="toc-number">1.3.3.</span> <span class="toc-text">IpTunnel_connectTo方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IpTunnel-connectTo方法-1"><span class="toc-number">1.3.4.</span> <span class="toc-text">IpTunnel_connectTo方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#创建一个IpTunnel-Connection类型的conn"><span class="toc-number">1.3.5.</span> <span class="toc-text">创建一个IpTunnel_Connection类型的conn</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#向离岸点申请ipv4地址"><span class="toc-number">1.3.6.</span> <span class="toc-text">向离岸点申请ipv4地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#收到离岸点分配的ipv4地址"><span class="toc-number">1.3.7.</span> <span class="toc-text">收到离岸点分配的ipv4地址</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#离岸点为每个允许连接过来的普通点建立一个IpTunnel-Connection"><span class="toc-number">1.4.</span> <span class="toc-text">离岸点为每个允许连接过来的普通点建立一个IpTunnel_Connection</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#conf文件配置-1"><span class="toc-number">1.4.1.</span> <span class="toc-text">conf文件配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#读取配置文件-1"><span class="toc-number">1.4.2.</span> <span class="toc-text">读取配置文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IpTunnel-allowConnection方法"><span class="toc-number">1.4.3.</span> <span class="toc-text">IpTunnel_allowConnection方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IpTunnel-allowConnection方法-1"><span class="toc-number">1.4.4.</span> <span class="toc-text">IpTunnel_allowConnection方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#创建一个IpTunnel-Connection类型的conn-1"><span class="toc-number">1.4.5.</span> <span class="toc-text">创建一个IpTunnel_Connection类型的conn</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#收到其他点发送来的分配地址的请求"><span class="toc-number">1.4.6.</span> <span class="toc-text">收到其他点发送来的分配地址的请求</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#处理从其他点发来的消息"><span class="toc-number">2.</span> <span class="toc-text">处理从其他点发来的消息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#查看地址合法性判断"><span class="toc-number">2.1.</span> <span class="toc-text">查看地址合法性判断</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#处理从Tun设备发来的消息"><span class="toc-number">3.</span> <span class="toc-text">处理从Tun设备发来的消息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#查找conn"><span class="toc-number">3.1.</span> <span class="toc-text">查找conn</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sendToNode"><span class="toc-number">3.2.</span> <span class="toc-text">sendToNode</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#需求描述"><span class="toc-number">4.</span> <span class="toc-text">需求描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#方案设计"><span class="toc-number">5.</span> <span class="toc-text">方案设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A点的conf中加入关于代理网段的信息"><span class="toc-number">5.1.</span> <span class="toc-text">A点的conf中加入关于代理网段的信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IpTunnel-Connection增加字段"><span class="toc-number">5.2.</span> <span class="toc-text">IpTunnel_Connection增加字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#普通点标注自己是一个带有网段代理功能的点"><span class="toc-number">5.3.</span> <span class="toc-text">普通点标注自己是一个带有网段代理功能的点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#普通点通知离岸点，自己的代理网段"><span class="toc-number">5.4.</span> <span class="toc-text">普通点通知离岸点，自己的代理网段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在ip地址合法性检查时，增加对代理网段的判断"><span class="toc-number">5.5.</span> <span class="toc-text">在ip地址合法性检查时，增加对代理网段的判断</span></a></li></ol></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隱藏目錄"  title="點擊按鈕隱藏或者顯示文章目錄">

    <script>
        yiliaConfig.toc = ["隱藏目錄", "顯示目錄", !!"false"];
    </script>





    
      <div class="duoshuo" id="comments">
    <div id="comment-box" ></div>
    <div class="ds-thread" id="ds-thread" data-thread-key="2017/07/25/cjdns_IpTunnel/" data-title="cjdns源码分析--IpTunnel" data-url="http://yoursite.com/2017/07/25/cjdns_IpTunnel/"></div>
    <script>
        var duoshuoQuery = {short_name:"ichrisking"};
        var loadComment = function(){
            var d = document, s = d.createElement('script');
            s.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
            s.async = true; s.charset = 'UTF-8';
            (d.head || d.body).appendChild(s);
        }

        
    </script>
    
    <script> loadComment(); </script>

</div>
    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2017/07/31/build-intranet-test/" title="上一篇: 一个简单的内外网连通实验">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2017/04/27/about-iptables/" title="下一篇: iptables在anet项目中的运用">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/01/29/cjnds-asymmetric-cryptography/">cjnds_asymmetric_cryptography</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/19/cjdns-noisepackage/">cjdns之干扰包设计</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/04/how-to-fix-rebase-still-in-progress/">如何解决报错“prior sync failed; rebase still in progress”</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/22/cjdns-3steps-lladdrsession/">使用SocketAddress来维护的EndpointsBySockaddr map机制中EndpointsBySockaddr session的建立过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/07/snodes-backup/">多个snode互相备份</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/05/cjdns-cryptoauth/">cjdns源码分析--CryptoAuth</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/04/how-to-read-staff/">如何看懂五线谱</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/30/commands-about-cjdns/">记录一些在开发cjdns过程中用到的命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/30/rom7-0-phone/">rom7.0-phone 电话相关</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/28/cjdns-SuperNodeHunter/">初探Supernode</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/25/rom7.0-build/">Android7.0Rom编译相关</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/02/cjdns_RouteGen/">cjdns源码分析--RouteGen</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/31/build-intranet-test/">一个简单的内外网连通实验</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/25/cjdns_IpTunnel/">cjdns源码分析--IpTunnel</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/27/about-iptables/">iptables在anet项目中的运用</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/21/how-to-build-git-on-raspberry/">在树莓派上搭建私有git</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/15/raspberry-add-camera-dev/">树莓派摄像头没有/dev/video0设备节点的问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/12/ping-pong/">cjdns源码分析--SwitchPing的发送，接收与回复</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/04/contentprovider/">Android中的ContentProvider,ContentResolver,ContentObserver</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/21/pattern-proxy/">Android中的设计模式之代理模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/20/pattern-decorator/">Android中的设计模式之装饰者模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/13/activity-launch-mode/">activity启动模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/12/bin-tree/">二叉搜索树</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/29/pattern-builder/">Android中的设计模式之建造模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/23/pattern-strategy/">Android中的设计模式之策略模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/22/pattern-prototype/">Android中的设计模式之原型模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/21/Search/">各种查找算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/21/pattern-adapter/">Android中的设计模式之适配器模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/17/pattern-factory/">Android中的设计模式之工厂模式系列</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/10/pattern-flyweight/">Android中的设计模式之享元模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/09/pattern-memento/">Android中的设计模式之备忘录模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/08/pattern-template-method/">Android中的设计模式之模板方法模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/07/pattern-observer/">Android中的设计模式之观察者模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/04/pattern-composite/">Android中的设计模式之组合模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/02/Sort/">各种排序算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/01/oneday-ShardPreferences/">ShardPreferences</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/31/oneday-AsyncTask/">AsyncTask</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/26/pattern-singleton/">Android中的设计模式之单例模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/10/oneday-listview/">如何优化listView</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/08/oneday-context/">Android中的context详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/27/android-parcelable/">activity之间传递数据的方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/26/oneday-handler/">android的Handler机制详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/22/oneday-activity-lifecycle/">Activity生命周期</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/22/pass-by-value-or-reference/">Java中的值传递和引用传递</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/22/oneday_BroadcastReceiver/">BroadcastReceiver</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/21/oneday_service/">Android中的Service</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/21/sunjdk/">如何安装sunjdk，并用它替代openjdk</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/19/mvp_in_android/">MVP in Android</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/19/java_synchronized/">Java并发</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/18/java_list_hashmap/">Java集合框架</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/09/java_basic/">Java基础知识</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/08/pattern-design/">设计模式概述</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/31/Binder/">Binder</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/24/Fragment/">Fragment</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/24/Android-TouchEvent/">Android事件分发机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/23/ANR-and-FC/">ANR与FC</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/23/Android-performance-optimization/">Android性能优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/23/how_to_use_locate_image_file_in_hexo/">如何在hexo中使用本地图片</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/23/reinstall-hexo-after-reinstall-OS/">重装系统后，修复hexo</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/22/Android_memory_leak/">Android内存泄漏</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/18/Android1_1/">Android基础知识</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/05/build_shadowsocks/">配置shadowsocks</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/24/change-hexo-theme-to-maupassant/">对我的Blog做了点改动</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/23/AnromOS_deploy/">Anrom日常发布方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/21/AnromOS_Web_Build/">AnromOS发布网站的搭建</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/19/make_blog_with_hexo/">使用hexo搭建blog</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/08/rsync/">拷貝代碼利器rsync</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/31/add_jar_into_android_mk_file/">給Android系統應用加jar包</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/16/port22_Connection_refused/">port 22: Connection refused</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/12/01/SEAndroid/">SEAndroid in Android5.x</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/06/11/access_ssl_with_okhttp/">使用OkHttp访问ssl（https）网络</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/04/20/build_java_jar_based_on_android_code/">如何使用android源码来制作java的jar包</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/02/04/save_discarding_commits/">找回差點丟失的commit</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/01/16/build_new_project_in_work_zone/">如何爲辦公區新建一個項目</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/01/06/add_new_function_in_local_service/">爲android添加一個新的service函數</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/03/21/deny_connect_with_usb/">源碼中實現禁止手機鏈接usb</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/02/14/add_tomoyo_to_android_system/">移植TOMOYO的步驟</a></li><li class="post-list-item"><a class="post-list-link" href="/2013/06/09/make_deamon_thead_in_android/">爲android編寫一個deamon進程</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2018 Chris King
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、簡單且強大的網誌框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="簡而不減 Hexo 雙欄網誌主題  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到訪數"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本頁閱讀量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="返回頂部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看評論"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="轉到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
             categories: ".article-category a, a.tag-list-link", 
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>