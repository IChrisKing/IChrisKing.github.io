<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-Hant-TW">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="“IpTunnel中主要是和离岸点相关的代码。结合最近的需求，分析一下源码，设计一下需求的实现方案”">
<meta name="keywords" content="cjdns,cjdns源码分析,C&#x2F;C++">
<meta property="og:type" content="article">
<meta property="og:title" content="cjdns源码分析--IpTunnel">
<meta property="og:url" content="http://yoursite.com/2017/07/25/cjdns_IpTunnel/index.html">
<meta property="og:site_name" content="IChrisKing">
<meta property="og:description" content="“IpTunnel中主要是和离岸点相关的代码。结合最近的需求，分析一下源码，设计一下需求的实现方案”">
<meta property="og:locale" content="zh-Hant-TW">
<meta property="og:updated_time" content="2019-03-22T03:32:07.107Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="cjdns源码分析--IpTunnel">
<meta name="twitter:description" content="“IpTunnel中主要是和离岸点相关的代码。结合最近的需求，分析一下源码，设计一下需求的实现方案”">






  <link rel="canonical" href="http://yoursite.com/2017/07/25/cjdns_IpTunnel/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>cjdns源码分析--IpTunnel | IChrisKing</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hant-TW">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">IChrisKing</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">#IMNOTCHRISLEE</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/25/cjdns_IpTunnel/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chris King">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IChrisKing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">cjdns源码分析--IpTunnel

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2017-07-25 09:48:00" itemprop="dateCreated datePublished" datetime="2017-07-25T09:48:00+08:00">2017-07-25</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-03-22 11:32:07" itemprop="dateModified" datetime="2019-03-22T11:32:07+08:00">2019-03-22</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/cjdns-cjdns源码分析/" itemprop="url" rel="index"><span itemprop="name">cjdns - cjdns源码分析</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          
            <div class="post-description">“IpTunnel中主要是和离岸点相关的代码。结合最近的需求，分析一下源码，设计一下需求的实现方案”</div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>首先看一下IpTunnel的结构体定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">struct IpTunnel</span><br><span class="line">&#123;</span><br><span class="line">    /** The interface used to send and receive messages to the TUN device. */</span><br><span class="line">    struct Iface tunInterface;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The interface used to send and receive messages to other nodes.</span><br><span class="line">     * All messages sent on this interface shall be preceeded with the RouterHeader and DataHeader.</span><br><span class="line">     */</span><br><span class="line">    struct Iface nodeInterface;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The list of registered connections, do not modify manually.</span><br><span class="line">     * Will be reorganized from time to time so pointers are ephemeral.</span><br><span class="line">     */</span><br><span class="line">    struct &#123;</span><br><span class="line">        uint32_t count;</span><br><span class="line">        struct IpTunnel_Connection* connections;</span><br><span class="line">    &#125; connectionList;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>两个Iface，一个负责跟tun设备沟通，一个负责跟其他node沟通<br>一个connectionList，保存现有的所有connection。</p>
<p>然后看一下IpTunnel_Connection的结构体定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">struct IpTunnel_Connection</span><br><span class="line">&#123;</span><br><span class="line">    /** The header for routing to this node. */</span><br><span class="line">    struct RouteHeader routeHeader;</span><br><span class="line"></span><br><span class="line">    /** The IPv6 address used for this connection or all zeros if none was assigned. */</span><br><span class="line">    uint8_t connectionIp6[16];</span><br><span class="line"></span><br><span class="line">    /** The IPv4 address used for this connection or all zeros if none was assigned. */</span><br><span class="line">    uint8_t connectionIp4[4];</span><br><span class="line"></span><br><span class="line">    /** The IPv6 netmask/prefix length, in bits. Defaults to 128 if none was assigned. */</span><br><span class="line">    uint8_t connectionIp6Prefix;</span><br><span class="line"></span><br><span class="line">    /** The IPv6 prefix length in, in bits, defining netmask. 0xff if not used. */</span><br><span class="line">    uint8_t connectionIp6Alloc;</span><br><span class="line"></span><br><span class="line">    /** The IPv4 address prefix length, in bits. Defaults to 32 if none was assigned. */</span><br><span class="line">    uint8_t connectionIp4Prefix;</span><br><span class="line"></span><br><span class="line">    /** The IPv6 prefix length in, in bits, defining netmask. 0xff if not used. */</span><br><span class="line">    uint8_t connectionIp4Alloc;</span><br><span class="line"></span><br><span class="line">    /** non-zero if the connection was made using IpTunnel_connectTo(). */</span><br><span class="line">    int isOutgoing : 1;</span><br><span class="line"></span><br><span class="line">    /** The number of the connection so it can be identified when removing. */</span><br><span class="line">    int number : 31;</span><br><span class="line"></span><br><span class="line">    bool reachable;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p> 这个结构体记录的是当前点与其他node的连接信息。对于普通的点来说，这里保存着与离岸点的连接信息。每个在conf中定义的离岸点（outgoingConnections），对应着这里的一个IpTunnel_Connection对象，且该对象的isOutgoing字段为1，表明这是一个与离岸点的连接。对于离岸点来说，这里保存着所有连接到该离岸点的连接信息。每个在conf中定义的允许连接的点（allowedConnections），对应着这里的一个IpTunnel_Connection对象，且该对向的isOutgoing字段为0，表明这不是一个向离岸点的连接。</p>
<p>结构体中还有六个与ip相关的字段，3个ip4，3个ipv6，根据需要，使用其中3个。这些ip字段，记录着该连接中，非离岸点的ip信息。</p>
<p>结构体中的routeHeader字段，记录着去往对方的路由信息。</p>
<h3 id="conf文件起到的作用"><a href="#conf文件起到的作用" class="headerlink" title="conf文件起到的作用"></a>conf文件起到的作用</h3><p>有两种途径来新建一个IpTunnel_Connection。</p>
<ol>
<li><p>作为普通点，建立一个与离岸点的IpTunnel_Connection<br>对应着conf文件中的outgoingConnections配置，调用到IpTunnel_admin中的connectTo方法，继而调用到IpTunnel中的IpTunnel_connectTo方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;outgoingConnections&quot;:[</span><br><span class="line">	&quot;wfzyzrc0q4g83y0dgzxx1l862u0lscucj75yw9q1ymbltzwh2fq0.k&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
<li><p>作为离岸点，为每个允许连接过来的普通点建立一个IpTunnel_Connection，对应着conf文件中的allowedConnections配置，调用到IpTunnel_admin中的allowConnection方法，继而调用到IpTunnel中的IpTunnel_allowConnection方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&quot;allowedConnections&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;ip4Address&quot;: &quot;192.168.254.2&quot;,</span><br><span class="line">            &quot;ip4Prefix&quot;: 0,</span><br><span class="line">            &quot;ip4Alloc&quot;: 32,</span><br><span class="line">            &quot;publicKey&quot;: &quot;uhmhts49tdm1ryb3q0pw95291uwt4xgvyk5s84vt2z2mnv3zp230.k&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;ip4Address&quot;: &quot;192.168.254.3&quot;,</span><br><span class="line">            &quot;ip4Prefix&quot;: 0,</span><br><span class="line">            &quot;ip4Alloc&quot;: 32,</span><br><span class="line">            &quot;publicKey&quot;: &quot;9c3x7hp181dv91tfkbngyhhu2uc3xhxuuh539l3g0gdjgjg1bs10.k&quot;</span><br><span class="line">        &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="普通点建立一个离岸点的IpTunnel-Connection"><a href="#普通点建立一个离岸点的IpTunnel-Connection" class="headerlink" title="普通点建立一个离岸点的IpTunnel_Connection"></a>普通点建立一个离岸点的IpTunnel_Connection</h3><h4 id="conf文件配置"><a href="#conf文件配置" class="headerlink" title="conf文件配置"></a>conf文件配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;outgoingConnections&quot;:[</span><br><span class="line">	&quot;wfzyzrc0q4g83y0dgzxx1l862u0lscucj75yw9q1ymbltzwh2fq0.k&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h4 id="读取配置文件"><a href="#读取配置文件" class="headerlink" title="读取配置文件"></a>读取配置文件</h4><p>Configurator.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List* outgoing = Dict_getListC(ifaceConf, &quot;outgoingConnections&quot;);</span><br><span class="line">if (outgoing) &#123;</span><br><span class="line">    String* s;</span><br><span class="line">    for (int i = 0; (s = List_getString(outgoing, i)) != NULL; i++) &#123;</span><br><span class="line">        Log_debug(ctx-&gt;logger, &quot;Initiating IpTunnel connection to [%s]&quot;, s-&gt;bytes);</span><br><span class="line">        Dict requestDict =</span><br><span class="line">            Dict_CONST(String_CONST(&quot;publicKeyOfNodeToConnectTo&quot;), String_OBJ(s), NULL);</span><br><span class="line">        Dict* resp = NULL;</span><br><span class="line">        rpcCall0(String_CONST(&quot;IpTunnel_connectTo&quot;), &amp;requestDict, ctx, tempAlloc, &amp;resp, true);</span><br><span class="line">        int64_t* num = Dict_getIntC(resp, &quot;connection&quot;);</span><br><span class="line">        Log_debug(ctx-&gt;logger,&quot;noti outgoing callback %d&quot;,(int)*num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>读取配置文件中outgoingConnections中的离岸点pubkey信息，rpcall调用IpTunnel_connectTo方法。</p>
<h4 id="IpTunnel-connectTo方法"><a href="#IpTunnel-connectTo方法" class="headerlink" title="IpTunnel_connectTo方法"></a>IpTunnel_connectTo方法</h4><p>IpTunnel_admin.c<br>该方法在文件中注册为connectTo函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static void connectTo(Dict* args, void* vcontext, String* txid, struct Allocator* requestAlloc)</span><br><span class="line">&#123;</span><br><span class="line">    struct Context* context = vcontext;</span><br><span class="line">    String* publicKeyOfNodeToConnectTo =</span><br><span class="line">        Dict_getStringC(args, &quot;publicKeyOfNodeToConnectTo&quot;);</span><br><span class="line"></span><br><span class="line">    uint8_t pubKey[32];</span><br><span class="line">    uint8_t ip6[16];</span><br><span class="line">    int ret;</span><br><span class="line">    if ((ret = Key_parse(publicKeyOfNodeToConnectTo, pubKey, ip6)) != 0) &#123;</span><br><span class="line">        sendError(Key_parse_strerror(ret), txid, context-&gt;admin);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int conn = IpTunnel_connectTo(pubKey, context-&gt;ipTun);</span><br><span class="line">    sendResponse(conn, txid, context-&gt;admin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>解析离岸点的pubkey，验证其合法性，调用IpTunnel_connectTo方法，建立IpTunnel_Connection。</p>
<h4 id="IpTunnel-connectTo方法-1"><a href="#IpTunnel-connectTo方法-1" class="headerlink" title="IpTunnel_connectTo方法"></a>IpTunnel_connectTo方法</h4><p>IpTunnel.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int IpTunnel_connectTo(uint8_t publicKeyOfNodeToConnectTo[32], struct IpTunnel* tunnel)</span><br><span class="line">&#123;</span><br><span class="line">    struct IpTunnel_pvt* context = Identity_check((struct IpTunnel_pvt*)tunnel);</span><br><span class="line">    Log_debug(context-&gt;logger, &quot;noti outgoing call by IpTunnel_connectTo&quot;);</span><br><span class="line">    struct IpTunnel_Connection* conn = newConnection(true, context);</span><br><span class="line">    Bits_memcpy(conn-&gt;routeHeader.publicKey, publicKeyOfNodeToConnectTo, 32);</span><br><span class="line">    AddressCalc_addressForPublicKey(conn-&gt;routeHeader.ip6, publicKeyOfNodeToConnectTo);</span><br><span class="line"></span><br><span class="line">    if (Defined(Log_DEBUG)) &#123;</span><br><span class="line">        uint8_t addr[40];</span><br><span class="line">        AddrTools_printIp(addr, conn-&gt;routeHeader.ip6);</span><br><span class="line">        Log_debug(context-&gt;logger, &quot;Trying to connect to [%s]&quot;, addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    requestAddresses(conn, context);</span><br><span class="line">    return conn-&gt;number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里主要有两个操作：</p>
<ol>
<li>调用newConnection(true, context)创建一个IpTunnel_Connection类型的conn，并将conf配置中的离岸点pubkey赋值给conn-&gt;routeHeader.publicKey。</li>
<li>调用requestAddresses方法，向离岸点申请ipv4地址。</li>
</ol>
<h4 id="创建一个IpTunnel-Connection类型的conn"><a href="#创建一个IpTunnel-Connection类型的conn" class="headerlink" title="创建一个IpTunnel_Connection类型的conn"></a>创建一个IpTunnel_Connection类型的conn</h4><p>调用newConnection方法。<br>IpTunnel.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">static struct IpTunnel_Connection* newConnection(bool isOutgoing, struct IpTunnel_pvt* context)</span><br><span class="line">&#123;</span><br><span class="line">    if (context-&gt;pub.connectionList.count == context-&gt;connectionCapacity) &#123;</span><br><span class="line">        uint32_t newSize = (context-&gt;connectionCapacity + 4) * sizeof(struct IpTunnel_Connection);</span><br><span class="line">        context-&gt;pub.connectionList.connections =</span><br><span class="line">            Allocator_realloc(context-&gt;allocator, context-&gt;pub.connectionList.connections, newSize);</span><br><span class="line">        context-&gt;connectionCapacity += 4;</span><br><span class="line">    &#125;</span><br><span class="line">    struct IpTunnel_Connection* conn =</span><br><span class="line">        &amp;context-&gt;pub.connectionList.connections[context-&gt;pub.connectionList.count];</span><br><span class="line"></span><br><span class="line">    // If it&apos;s an incoming connection, it must be lower on the list than any outgoing connections.</span><br><span class="line">    if (!isOutgoing) &#123;</span><br><span class="line">        for (int i = (int)context-&gt;pub.connectionList.count - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">            if (!context-&gt;pub.connectionList.connections[i].isOutgoing</span><br><span class="line">                &amp;&amp; conn != &amp;context-&gt;pub.connectionList.connections[i + 1])</span><br><span class="line">            &#123;</span><br><span class="line">                Bits_memcpy(conn,</span><br><span class="line">                                 &amp;context-&gt;pub.connectionList.connections[i + 1],</span><br><span class="line">                                 sizeof(struct IpTunnel_Connection));</span><br><span class="line">                conn = &amp;context-&gt;pub.connectionList.connections[i + 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    context-&gt;pub.connectionList.count++;</span><br><span class="line"></span><br><span class="line">    Bits_memset(conn, 0, sizeof(struct IpTunnel_Connection));</span><br><span class="line">    conn-&gt;number = context-&gt;nextConnectionNumber++;</span><br><span class="line">    conn-&gt;isOutgoing = isOutgoing;</span><br><span class="line">    conn-&gt;reachable = false;</span><br><span class="line"></span><br><span class="line">    // if there are 2 billion calls, die.</span><br><span class="line">    Assert_true(context-&gt;nextConnectionNumber &lt; (UINT32_MAX &gt;&gt; 1));</span><br><span class="line"></span><br><span class="line">    return conn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第一个参数指定了是否为离岸点，其他部分没什么特别，普通的赋值操作。</p>
<h4 id="向离岸点申请ipv4地址"><a href="#向离岸点申请ipv4地址" class="headerlink" title="向离岸点申请ipv4地址"></a>向离岸点申请ipv4地址</h4><p>调用requestAddresses方法<br>IpTunnel.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static void requestAddresses(struct IpTunnel_Connection* conn, struct IpTunnel_pvt* context)</span><br><span class="line">&#123;</span><br><span class="line">    if (Defined(Log_DEBUG)) &#123;</span><br><span class="line">        uint8_t addr[40];</span><br><span class="line">        AddrTools_printIp(addr, conn-&gt;routeHeader.ip6);</span><br><span class="line">        Log_debug(context-&gt;logger, &quot;Requesting addresses from [%s] for connection [%d]&quot;,</span><br><span class="line">                  addr, conn-&gt;number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int number = conn-&gt;number;</span><br><span class="line">    Dict d = Dict_CONST(</span><br><span class="line">        String_CONST(&quot;q&quot;), String_OBJ(String_CONST(&quot;IpTunnel_getAddresses&quot;)), Dict_CONST(</span><br><span class="line">        String_CONST(&quot;txid&quot;), String_OBJ((&amp;(String)&#123; .len = 4, .bytes = (char*)&amp;number &#125;)),</span><br><span class="line">        NULL</span><br><span class="line">    ));</span><br><span class="line">    struct Allocator* msgAlloc = Allocator_child(context-&gt;allocator);</span><br><span class="line">    sendControlMessage(&amp;d, conn, msgAlloc, context);</span><br><span class="line">    Allocator_free(msgAlloc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Dict中放入key为q，value为IpTunnel_getAddresses的键值对，调用sendControlMessage方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">static void sendControlMessage(Dict* dict,</span><br><span class="line">                               struct IpTunnel_Connection* connection,</span><br><span class="line">                               struct Allocator* requestAlloc,</span><br><span class="line">                               struct IpTunnel_pvt* context)</span><br><span class="line">&#123;</span><br><span class="line">    struct Message* msg = Message_new(0, 1024, requestAlloc);</span><br><span class="line">    BencMessageWriter_write(dict, msg, NULL);</span><br><span class="line"></span><br><span class="line">    int length = msg-&gt;length;</span><br><span class="line"></span><br><span class="line">    // do UDP header.</span><br><span class="line">    Message_shift(msg, Headers_UDPHeader_SIZE, NULL);</span><br><span class="line">    struct Headers_UDPHeader* uh = (struct Headers_UDPHeader*) msg-&gt;bytes;</span><br><span class="line">    uh-&gt;srcPort_be = 0;</span><br><span class="line">    uh-&gt;destPort_be = 0;</span><br><span class="line">    uh-&gt;length_be = Endian_hostToBigEndian16(length);</span><br><span class="line">    uh-&gt;checksum_be = 0;</span><br><span class="line"></span><br><span class="line">    uint16_t payloadLength = msg-&gt;length;</span><br><span class="line"></span><br><span class="line">    Message_shift(msg, Headers_IP6Header_SIZE, NULL);</span><br><span class="line">    struct Headers_IP6Header* header = (struct Headers_IP6Header*) msg-&gt;bytes;</span><br><span class="line">    header-&gt;versionClassAndFlowLabel = 0;</span><br><span class="line">    header-&gt;flowLabelLow_be = 0;</span><br><span class="line">    header-&gt;nextHeader = 17;</span><br><span class="line">    header-&gt;hopLimit = 0;</span><br><span class="line">    header-&gt;payloadLength_be = Endian_hostToBigEndian16(payloadLength);</span><br><span class="line">    Headers_setIpVersion(header);</span><br><span class="line"></span><br><span class="line">    // zero the source and dest addresses.</span><br><span class="line">    Bits_memset(header-&gt;sourceAddr, 0, 32);</span><br><span class="line"></span><br><span class="line">    uh-&gt;checksum_be = Checksum_udpIp6(header-&gt;sourceAddr,</span><br><span class="line">                                      (uint8_t*) uh,</span><br><span class="line">                                      msg-&gt;length - Headers_IP6Header_SIZE);</span><br><span class="line"></span><br><span class="line">    Iface_CALL(sendToNode, msg, connection, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一些初始化操作，然后Iface_CALL调用sendToNode方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static Iface_DEFUN sendToNode(struct Message* message,</span><br><span class="line">                              struct IpTunnel_Connection* connection,</span><br><span class="line">                              struct IpTunnel_pvt* context)</span><br><span class="line">&#123;</span><br><span class="line">    Message_push(message, NULL, DataHeader_SIZE, NULL);</span><br><span class="line">    struct DataHeader* dh = (struct DataHeader*) message-&gt;bytes;</span><br><span class="line">    DataHeader_setContentType(dh, ContentType_IPTUN);</span><br><span class="line">    DataHeader_setVersion(dh, DataHeader_CURRENT_VERSION);</span><br><span class="line">    Message_push(message, &amp;connection-&gt;routeHeader, RouteHeader_SIZE, NULL);</span><br><span class="line">    return Iface_next(&amp;context-&gt;pub.nodeInterface, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>设置了ContentType和Version，调用Message_push方法调整消息内容。最后调用 Iface_next(&amp;context-&gt;pub.nodeInterface, message)方法，将消息发出去。<br>此处的context-&gt;pub.nodeInterface是一个Iface，它的回调函数在IpTunnel_new方法中，被设为incomingFromNode。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">      .pub = &#123;</span><br><span class="line">..........</span><br><span class="line">          .nodeInterface = &#123; .send = incomingFromNode &#125;</span><br><span class="line">      &#125;,</span><br></pre></td></tr></table></figure></p>
<p>它的connectedIf在Core.c的Core_init方法中通过Iface_plumb方法与nc-&gt;upper-&gt;ipTunnelIf绑定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Iface_plumb(&amp;nc-&gt;upper-&gt;ipTunnelIf, &amp;ipTunnel-&gt;nodeInterface);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static inline void Iface_plumb(struct Iface* a, struct Iface* b)</span><br><span class="line">&#123;</span><br><span class="line">    Assert_true(!a-&gt;connectedIf);</span><br><span class="line">    Assert_true(!b-&gt;connectedIf);</span><br><span class="line">    a-&gt;connectedIf = b;</span><br><span class="line">    b-&gt;connectedIf = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="收到离岸点分配的ipv4地址"><a href="#收到离岸点分配的ipv4地址" class="headerlink" title="收到离岸点分配的ipv4地址"></a>收到离岸点分配的ipv4地址</h4><p>上面讲到，回调函数被设为incomingFromNode，所以，所有从其他点发送过来，进入IpTunnel的数据，都先到incomingFromNode方法中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">static Iface_DEFUN incomingFromNode(struct Message* message, struct Iface* nodeIf)</span><br><span class="line">&#123;</span><br><span class="line">    struct IpTunnel_pvt* context =</span><br><span class="line">        Identity_containerOf(nodeIf, struct IpTunnel_pvt, pub.nodeInterface);</span><br><span class="line"></span><br><span class="line">    //Log_debug(context-&gt;logger, &quot;Got incoming message&quot;);</span><br><span class="line"></span><br><span class="line">    Assert_true(message-&gt;length &gt;= RouteHeader_SIZE + DataHeader_SIZE);</span><br><span class="line">    struct RouteHeader* rh = (struct RouteHeader*) message-&gt;bytes;</span><br><span class="line">    struct DataHeader* dh = (struct DataHeader*) &amp;rh[1];</span><br><span class="line">    Assert_true(DataHeader_getContentType(dh) == ContentType_IPTUN);</span><br><span class="line">    struct IpTunnel_Connection* conn = connectionByPubKey(rh-&gt;publicKey, context);</span><br><span class="line">    if (!conn) &#123;</span><br><span class="line">        if (Defined(Log_DEBUG)) &#123;</span><br><span class="line">            uint8_t addr[40];</span><br><span class="line">            AddrTools_printIp(addr, rh-&gt;ip6);</span><br><span class="line">            Log_debug(context-&gt;logger, &quot;Got message from unrecognized node [%s]&quot;, addr);</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Message_shift(message, -(RouteHeader_SIZE + DataHeader_SIZE), NULL);</span><br><span class="line"></span><br><span class="line">    if (message-&gt;length &gt; 40 &amp;&amp; Headers_getIpVersion(message-&gt;bytes) == 6) &#123;</span><br><span class="line">        return ip6FromNode(message, conn, context);</span><br><span class="line">    &#125;</span><br><span class="line">    if (message-&gt;length &gt; 20 &amp;&amp; Headers_getIpVersion(message-&gt;bytes) == 4) &#123;</span><br><span class="line">        return ip4FromNode(message, conn, context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (Defined(Log_DEBUG)) &#123;</span><br><span class="line">        uint8_t addr[40];</span><br><span class="line">        AddrTools_printIp(addr, rh-&gt;ip6);</span><br><span class="line">        Log_debug(context-&gt;logger,</span><br><span class="line">                  &quot;Got message of unknown type, length: [%d], IP version [%d] from [%s]&quot;,</span><br><span class="line">                  message-&gt;length,</span><br><span class="line">                  (message-&gt;length &gt; 1) ? Headers_getIpVersion(message-&gt;bytes) : 0,</span><br><span class="line">                  addr);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li><p>通过publicKey找到对应的conn，也就是离岸点的conn。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct IpTunnel_Connection* conn = connectionByPubKey(rh-&gt;publicKey, context);</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用ip6FromNode</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (message-&gt;length &gt; 40 &amp;&amp; Headers_getIpVersion(message-&gt;bytes) == 6) &#123;</span><br><span class="line">    return ip6FromNode(message, conn, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static Iface_DEFUN ip6FromNode(struct Message* message,</span><br><span class="line">                               struct IpTunnel_Connection* conn,</span><br><span class="line">                               struct IpTunnel_pvt* context)</span><br><span class="line">&#123;</span><br><span class="line">    struct Headers_IP6Header* header = (struct Headers_IP6Header*) message-&gt;bytes;</span><br><span class="line">    if (Bits_isZero(header-&gt;sourceAddr, 16) || Bits_isZero(header-&gt;destinationAddr, 16)) &#123;</span><br><span class="line">        if (Bits_isZero(header-&gt;sourceAddr, 32)) &#123;</span><br><span class="line">            return incomingControlMessage(message, conn, context);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!isValidAddress6(header-&gt;sourceAddr, false, conn)) &#123;</span><br><span class="line">        ......</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    return Iface_next(&amp;context-&gt;pub.tunInterface, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时header-&gt;sourceAddr为全0，会调用到incomingControlMessage方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static Iface_DEFUN incomingControlMessage(struct Message* message,</span><br><span class="line">                                          struct IpTunnel_Connection* conn,</span><br><span class="line">                                          struct IpTunnel_pvt* context)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    struct Allocator* alloc = Allocator_child(message-&gt;alloc);</span><br><span class="line"></span><br><span class="line">    Dict* d = NULL;</span><br><span class="line"></span><br><span class="line">    if (Dict_getDictC(d, &quot;addresses&quot;)) &#123;</span><br><span class="line">        return incomingAddresses(d, conn, alloc, context);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用到incomingAddresses</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">static Iface_DEFUN incomingAddresses(Dict* d,</span><br><span class="line">                                     struct IpTunnel_Connection* conn,</span><br><span class="line">                                     struct Allocator* alloc,</span><br><span class="line">                                     struct IpTunnel_pvt* context)</span><br><span class="line">&#123;</span><br><span class="line">      //一些数据合法性判断</span><br><span class="line"></span><br><span class="line">    Dict* addresses = Dict_getDictC(d, &quot;addresses&quot;);</span><br><span class="line"></span><br><span class="line">    String* ip4 = Dict_getStringC(addresses, &quot;ip4&quot;);</span><br><span class="line">    int64_t* ip4Prefix = Dict_getIntC(addresses, &quot;ip4Prefix&quot;);</span><br><span class="line">    int64_t* ip4Alloc = Dict_getIntC(addresses, &quot;ip4Alloc&quot;);</span><br><span class="line"></span><br><span class="line">    if (ip4 &amp;&amp; ip4-&gt;len == 4) &#123;</span><br><span class="line">        Bits_memcpy(conn-&gt;connectionIp4, ip4-&gt;bytes, 4);</span><br><span class="line"></span><br><span class="line">        if (ip4Prefix &amp;&amp; *ip4Prefix &gt;= 0 &amp;&amp; *ip4Prefix &lt;= 32) &#123;</span><br><span class="line">            conn-&gt;connectionIp4Prefix = (uint8_t) *ip4Prefix;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            conn-&gt;connectionIp4Prefix = 32;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (ip4Alloc &amp;&amp; *ip4Alloc &gt;= 0 &amp;&amp; *ip4Alloc &lt;= 32) &#123;</span><br><span class="line">            conn-&gt;connectionIp4Alloc = (uint8_t) *ip4Alloc;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            conn-&gt;connectionIp4Alloc = 32;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        struct Sockaddr* sa = Sockaddr_clone(Sockaddr_LOOPBACK, alloc);</span><br><span class="line">        uint8_t* addrBytes = NULL;</span><br><span class="line">        Sockaddr_getAddress(sa, &amp;addrBytes);</span><br><span class="line">        Bits_memcpy(addrBytes, ip4-&gt;bytes, 4);</span><br><span class="line">        char* printedAddr = Sockaddr_print(sa, alloc);</span><br><span class="line"></span><br><span class="line">        Log_info(context-&gt;logger, &quot;Got issued address [%s/%d:%d] for connection [%d]&quot;,</span><br><span class="line">                 printedAddr, conn-&gt;connectionIp4Alloc, conn-&gt;connectionIp4Prefix, conn-&gt;number);</span><br><span class="line"></span><br><span class="line">        addAddress(printedAddr, conn-&gt;connectionIp4Prefix, conn-&gt;connectionIp4Alloc, context);</span><br><span class="line">        Notification_doNotify_af(context-&gt;notification,</span><br><span class="line">                OUTGOING_REACHABLE,REACHABLE,Ethernet_TYPE_IP4);</span><br><span class="line">        conn-&gt;reachable = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //与ipv4类似的，ipv6的处理。不做具体分析。</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从消息中取出ipv4相关的三个字段，这是离岸点分配给当前点的ipv4地址相关信息。设置conn中相关字段的内容。然后调用addAddress方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">static void addAddress(char* printedAddr, uint8_t prefixLen,</span><br><span class="line">                       uint8_t allocSize, struct IpTunnel_pvt* ctx)</span><br><span class="line">&#123;</span><br><span class="line">    struct Sockaddr_storage ss;</span><br><span class="line">    if (Sockaddr_parse(printedAddr, &amp;ss)) &#123;</span><br><span class="line">        Log_error(ctx-&gt;logger, &quot;Invalid ip, setting ip address on TUN&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    ss.addr.flags |= Sockaddr_flags_PREFIX;</span><br><span class="line">    ss.addr.prefix = prefixLen;</span><br><span class="line"></span><br><span class="line">    bool installRoute = false;</span><br><span class="line">    if (Sockaddr_getFamily(&amp;ss.addr) == Sockaddr_AF_INET) &#123;</span><br><span class="line">        installRoute = (prefixLen &lt; 32);</span><br><span class="line">    &#125; else if (Sockaddr_getFamily(&amp;ss.addr) == Sockaddr_AF_INET6) &#123;</span><br><span class="line">        installRoute = (prefixLen &lt; 128);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Assert_failure(&quot;bad address family&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (installRoute) &#123;</span><br><span class="line">        RouteGen_addPrefix(ctx-&gt;rg, &amp;ss.addr);</span><br><span class="line">    &#125;</span><br><span class="line">    if (!ctx-&gt;ifName) &#123;</span><br><span class="line">        Log_error(ctx-&gt;logger, &quot;Failed to set IP address because TUN interface is not setup&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ss.addr.prefix = allocSize;</span><br><span class="line">    struct Jmp j;</span><br><span class="line">    Jmp_try(j) &#123;</span><br><span class="line">        NetDev_addAddress(ctx-&gt;ifName-&gt;bytes, &amp;ss.addr, ctx-&gt;logger, &amp;j.handler);</span><br><span class="line">    &#125; Jmp_catch &#123;</span><br><span class="line">        Log_error(ctx-&gt;logger, &quot;Error setting ip address on TUN [%s]&quot;, j.message);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里主要调用了两个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RouteGen_addPrefix(ctx-&gt;rg, &amp;ss.addr);</span><br><span class="line">NetDev_addAddress(ctx-&gt;ifName-&gt;bytes, &amp;ss.addr, ctx-&gt;logger, &amp;j.handler);</span><br></pre></td></tr></table></figure></p>
<p>已经不是IpTunnel范围内的代码了，具体内容不分析了。<br>至此，向离岸点申请ipv4，收到回复后设置ipv4的过程就结束了。</p>
<h3 id="离岸点为每个允许连接过来的普通点建立一个IpTunnel-Connection"><a href="#离岸点为每个允许连接过来的普通点建立一个IpTunnel-Connection" class="headerlink" title="离岸点为每个允许连接过来的普通点建立一个IpTunnel_Connection"></a>离岸点为每个允许连接过来的普通点建立一个IpTunnel_Connection</h3><h4 id="conf文件配置-1"><a href="#conf文件配置-1" class="headerlink" title="conf文件配置"></a>conf文件配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&quot;allowedConnections&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;ip4Address&quot;: &quot;192.168.254.2&quot;,</span><br><span class="line">            &quot;ip4Prefix&quot;: 0,</span><br><span class="line">            &quot;ip4Alloc&quot;: 32,</span><br><span class="line">            &quot;publicKey&quot;: &quot;uhmhts49tdm1ryb3q0pw95291uwt4xgvyk5s84vt2z2mnv3zp230.k&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;ip4Address&quot;: &quot;192.168.254.3&quot;,</span><br><span class="line">            &quot;ip4Prefix&quot;: 0,</span><br><span class="line">            &quot;ip4Alloc&quot;: 32,</span><br><span class="line">            &quot;publicKey&quot;: &quot;9c3x7hp181dv91tfkbngyhhu2uc3xhxuuh539l3g0gdjgjg1bs10.k&quot;</span><br><span class="line">        &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h4 id="读取配置文件-1"><a href="#读取配置文件-1" class="headerlink" title="读取配置文件"></a>读取配置文件</h4><p>Configurator.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">List* incoming = Dict_getListC(ifaceConf, &quot;allowedConnections&quot;);</span><br><span class="line">if (incoming) &#123;</span><br><span class="line">    Dict* d;</span><br><span class="line">    for (int i = 0; (d = List_getDict(incoming, i)) != NULL; i++) &#123;</span><br><span class="line">        String* key = Dict_getStringC(d, &quot;publicKey&quot;);</span><br><span class="line">        String* ip4 = Dict_getStringC(d, &quot;ip4Address&quot;);</span><br><span class="line">        // Note that the prefix length has to be a proper int in the config</span><br><span class="line">        // (not quoted!)</span><br><span class="line">        int64_t* ip4Prefix = Dict_getIntC(d, &quot;ip4Prefix&quot;);</span><br><span class="line">        String* ip6 = Dict_getStringC(d, &quot;ip6Address&quot;);</span><br><span class="line">        int64_t* ip6Prefix = Dict_getIntC(d, &quot;ip6Prefix&quot;);</span><br><span class="line">        if (!key) &#123;</span><br><span class="line">            Log_critical(ctx-&gt;logger, &quot;In router.ipTunnel.allowedConnections[%d]&quot;</span><br><span class="line">                                      &quot;&apos;publicKey&apos; required.&quot;, i);</span><br><span class="line">            exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">        if (!ip4 &amp;&amp; !ip6) &#123;</span><br><span class="line">            Log_critical(ctx-&gt;logger, &quot;In router.ipTunnel.allowedConnections[%d]&quot;</span><br><span class="line">                                      &quot;either &apos;ip4Address&apos; or &apos;ip6Address&apos; required.&quot;, i);</span><br><span class="line">            exit(1);</span><br><span class="line">        &#125; else if (ip4Prefix &amp;&amp; !ip4) &#123;</span><br><span class="line">            Log_critical(ctx-&gt;logger, &quot;In router.ipTunnel.allowedConnections[%d]&quot;</span><br><span class="line">                                      &quot;&apos;ip4Address&apos; required with &apos;ip4Prefix&apos;.&quot;, i);</span><br><span class="line">            exit(1);</span><br><span class="line">        &#125; else if (ip6Prefix &amp;&amp; !ip6) &#123;</span><br><span class="line">            Log_critical(ctx-&gt;logger, &quot;In router.ipTunnel.allowedConnections[%d]&quot;</span><br><span class="line">                                      &quot;&apos;ip6Address&apos; required with &apos;ip6Prefix&apos;.&quot;, i);</span><br><span class="line">            exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">        Log_debug(ctx-&gt;logger, &quot;Allowing IpTunnel connections from [%s]&quot;, key-&gt;bytes);</span><br><span class="line"></span><br><span class="line">        if (ip4) &#123;</span><br><span class="line">            Log_debug(ctx-&gt;logger, &quot;Issue IPv4 address %s&quot;, ip4-&gt;bytes);</span><br><span class="line">            if (ip4Prefix) &#123;</span><br><span class="line">                Log_debug(ctx-&gt;logger, &quot;Issue IPv4 netmask/prefix length /%d&quot;,</span><br><span class="line">                    (int) *ip4Prefix);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                Log_debug(ctx-&gt;logger, &quot;Use default netmask/prefix length /0&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (ip6) &#123;</span><br><span class="line">            Log_debug(ctx-&gt;logger, &quot;Issue IPv6 address [%s]&quot;, ip6-&gt;bytes);</span><br><span class="line">            if (ip6Prefix) &#123;</span><br><span class="line">                Log_debug(ctx-&gt;logger, &quot;Issue IPv6 netmask/prefix length /%d&quot;,</span><br><span class="line">                    (int) *ip6Prefix);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                Log_debug(ctx-&gt;logger, &quot;Use default netmask/prefix length /0&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Dict_putStringC(d, &quot;publicKeyOfAuthorizedNode&quot;, key, tempAlloc);</span><br><span class="line">        rpcCall0(String_CONST(&quot;IpTunnel_allowConnection&quot;), d, ctx, tempAlloc, NULL, true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>读取配置文件中allowedConnections中各个点的相关信息，rpcall调用IpTunnel_allowConnection方法。</p>
<h4 id="IpTunnel-allowConnection方法"><a href="#IpTunnel-allowConnection方法" class="headerlink" title="IpTunnel_allowConnection方法"></a>IpTunnel_allowConnection方法</h4><p>IpTunnel_admin.c<br>该方法在文件中注册为allowConnection函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">static void allowConnection(Dict* args,</span><br><span class="line">                            void* vcontext,</span><br><span class="line">                            String* txid,</span><br><span class="line">                            struct Allocator* requestAlloc)</span><br><span class="line">&#123;</span><br><span class="line">    struct Context* context = (struct Context*) vcontext;</span><br><span class="line">    String* publicKeyOfAuthorizedNode =</span><br><span class="line">        Dict_getStringC(args, &quot;publicKeyOfAuthorizedNode&quot;);</span><br><span class="line">    String* ip6Address = Dict_getStringC(args, &quot;ip6Address&quot;);</span><br><span class="line">    int64_t* ip6Prefix = Dict_getIntC(args, &quot;ip6Prefix&quot;);</span><br><span class="line">    int64_t* ip6Alloc = Dict_getIntC(args, &quot;ip6Alloc&quot;);</span><br><span class="line">    String* ip4Address = Dict_getStringC(args, &quot;ip4Address&quot;);</span><br><span class="line">    int64_t* ip4Prefix = Dict_getIntC(args, &quot;ip4Prefix&quot;);</span><br><span class="line">    int64_t* ip4Alloc = Dict_getIntC(args, &quot;ip4Alloc&quot;);</span><br><span class="line"></span><br><span class="line">    uint8_t pubKey[32];</span><br><span class="line">    uint8_t ip6Addr[16];</span><br><span class="line"></span><br><span class="line">    struct Sockaddr_storage ip6ToGive;</span><br><span class="line">    struct Sockaddr_storage ip4ToGive;</span><br><span class="line"></span><br><span class="line">    char* error;</span><br><span class="line">    int ret;</span><br><span class="line">    if (!ip6Address &amp;&amp; !ip4Address) &#123;</span><br><span class="line">        error = &quot;Must specify ip6Address or ip4Address&quot;;</span><br><span class="line">    &#125; else if ((ret = Key_parse(publicKeyOfAuthorizedNode, pubKey, ip6Addr)) != 0) &#123;</span><br><span class="line">        error = Key_parse_strerror(ret);</span><br><span class="line"></span><br><span class="line">    &#125; else if (ip6Prefix &amp;&amp; !ip6Address) &#123;</span><br><span class="line">        error = &quot;Must specify ip6Address with ip6Prefix&quot;;</span><br><span class="line">    &#125; else if (ip6Alloc &amp;&amp; !ip6Address) &#123;</span><br><span class="line">        error = &quot;Must specify ip6Address with ip6Alloc&quot;;</span><br><span class="line">    &#125; else if (ip6Prefix &amp;&amp; (*ip6Prefix &gt; 128 || *ip6Prefix &lt; 0)) &#123;</span><br><span class="line">        error = &quot;ip6Prefix out of range: must be 0 to 128&quot;;</span><br><span class="line">    &#125; else if (ip6Alloc &amp;&amp; (*ip6Alloc &gt; 128 || *ip6Alloc &lt; 1)) &#123;</span><br><span class="line">        error = &quot;ip6Alloc out of range: must be 1 to 128&quot;;</span><br><span class="line"></span><br><span class="line">    &#125; else if (ip4Prefix &amp;&amp; !ip4Address) &#123;</span><br><span class="line">        error = &quot;Must specify ip4Address with ip4Prefix&quot;;</span><br><span class="line">    &#125; else if (ip4Alloc &amp;&amp; !ip4Address) &#123;</span><br><span class="line">        error = &quot;Must specify ip4Address with ip4Alloc&quot;;</span><br><span class="line">    &#125; else if (ip4Prefix &amp;&amp; (*ip4Prefix &gt; 32 || *ip4Prefix &lt; 0)) &#123;</span><br><span class="line">        error = &quot;ip4Prefix out of range: must be 0 to 32&quot;;</span><br><span class="line">    &#125; else if (ip4Alloc &amp;&amp; (*ip4Alloc &gt; 32 || *ip4Alloc &lt; 1)) &#123;</span><br><span class="line">        error = &quot;ip4Alloc out of range: must be 1 to 32&quot;;</span><br><span class="line"></span><br><span class="line">    &#125; else if (ip6Address</span><br><span class="line">        &amp;&amp; (Sockaddr_parse(ip6Address-&gt;bytes, &amp;ip6ToGive)</span><br><span class="line">            || Sockaddr_getFamily(&amp;ip6ToGive.addr) != Sockaddr_AF_INET6))</span><br><span class="line">    &#123;</span><br><span class="line">        error = &quot;malformed ip6Address&quot;;</span><br><span class="line">    &#125; else if (ip4Address</span><br><span class="line">        &amp;&amp; (Sockaddr_parse(ip4Address-&gt;bytes, &amp;ip4ToGive)</span><br><span class="line">            || Sockaddr_getFamily(&amp;ip4ToGive.addr) != Sockaddr_AF_INET))</span><br><span class="line">    &#123;</span><br><span class="line">        error = &quot;malformed ip4Address&quot;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        int conn = IpTunnel_allowConnection(pubKey,</span><br><span class="line">                                            (ip6Address) ? &amp;ip6ToGive.addr : NULL,</span><br><span class="line">                                            (ip6Prefix) ? (uint8_t) (*ip6Prefix) : 128,</span><br><span class="line">                                            (ip6Alloc) ? (uint8_t) (*ip6Alloc) : 128,</span><br><span class="line">                                            (ip4Address) ? &amp;ip4ToGive.addr : NULL,</span><br><span class="line">                                            (ip4Prefix) ? (uint8_t) (*ip4Prefix) : 32,</span><br><span class="line">                                            (ip4Alloc) ? (uint8_t) (*ip4Alloc) : 32,</span><br><span class="line">                                            context-&gt;ipTun);</span><br><span class="line">        sendResponse(conn, txid, context-&gt;admin);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sendError(error, txid, context-&gt;admin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>获取conf中该连接的相关信息，验证其合法性，调用IpTunnel_allowConnection方法，建立IpTunnel_Connection。</p>
<h4 id="IpTunnel-allowConnection方法-1"><a href="#IpTunnel-allowConnection方法-1" class="headerlink" title="IpTunnel_allowConnection方法"></a>IpTunnel_allowConnection方法</h4><p>IpTunnel.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">int IpTunnel_allowConnection(uint8_t publicKeyOfAuthorizedNode[32],</span><br><span class="line">                             struct Sockaddr* ip6Addr,</span><br><span class="line">                             uint8_t ip6Prefix,</span><br><span class="line">                             uint8_t ip6Alloc,</span><br><span class="line">                             struct Sockaddr* ip4Addr,</span><br><span class="line">                             uint8_t ip4Prefix,</span><br><span class="line">                             uint8_t ip4Alloc,</span><br><span class="line">                             struct IpTunnel* tunnel)</span><br><span class="line">&#123;</span><br><span class="line">    struct IpTunnel_pvt* context = Identity_check((struct IpTunnel_pvt*)tunnel);</span><br><span class="line"></span><br><span class="line">    Log_debug(context-&gt;logger, &quot;IPv4 Prefix to allow: %d&quot;, ip4Prefix);</span><br><span class="line"></span><br><span class="line">    uint8_t* ip6Address = NULL;</span><br><span class="line">    uint8_t* ip4Address = NULL;</span><br><span class="line">    if (ip6Addr) &#123;</span><br><span class="line">        Sockaddr_getAddress(ip6Addr, &amp;ip6Address);</span><br><span class="line">    &#125;</span><br><span class="line">    if (ip4Addr) &#123;</span><br><span class="line">        Sockaddr_getAddress(ip4Addr, &amp;ip4Address);</span><br><span class="line">    &#125;</span><br><span class="line">    Log_debug(context-&gt;logger, &quot;noti outgoing call by IpTunnel_allowConnection&quot;);</span><br><span class="line">    struct IpTunnel_Connection* conn = newConnection(false, context);</span><br><span class="line">    Bits_memcpy(conn-&gt;routeHeader.publicKey, publicKeyOfAuthorizedNode, 32);</span><br><span class="line">    AddressCalc_addressForPublicKey(conn-&gt;routeHeader.ip6, publicKeyOfAuthorizedNode);</span><br><span class="line">    if (ip4Address) &#123;</span><br><span class="line">        Bits_memcpy(conn-&gt;connectionIp4, ip4Address, 4);</span><br><span class="line">        conn-&gt;connectionIp4Prefix = ip4Prefix;</span><br><span class="line">        conn-&gt;connectionIp4Alloc = ip4Alloc;</span><br><span class="line">        Assert_true(ip4Alloc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (ip6Address) &#123;</span><br><span class="line">        Bits_memcpy(conn-&gt;connectionIp6, ip6Address, 16);</span><br><span class="line">        conn-&gt;connectionIp6Prefix = ip6Prefix;</span><br><span class="line">        conn-&gt;connectionIp6Alloc = ip6Alloc;</span><br><span class="line">        Assert_true(ip6Alloc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return conn-&gt;number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里主要三个操作：</p>
<ol>
<li>调用newConnection(true, context)创建一个IpTunnel_Connection类型的conn。</li>
<li>将conf配置中的publicKey信息赋值给conn-&gt;routeHeader.publicKey</li>
<li>将conf配置中的ip相关信息赋值给conn相关字段 </li>
</ol>
<h4 id="创建一个IpTunnel-Connection类型的conn-1"><a href="#创建一个IpTunnel-Connection类型的conn-1" class="headerlink" title="创建一个IpTunnel_Connection类型的conn"></a>创建一个IpTunnel_Connection类型的conn</h4><p>调用newConnection方法。<br>IpTunnel.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">static struct IpTunnel_Connection* newConnection(bool isOutgoing, struct IpTunnel_pvt* context)</span><br><span class="line">&#123;</span><br><span class="line">    if (context-&gt;pub.connectionList.count == context-&gt;connectionCapacity) &#123;</span><br><span class="line">        uint32_t newSize = (context-&gt;connectionCapacity + 4) * sizeof(struct IpTunnel_Connection);</span><br><span class="line">        context-&gt;pub.connectionList.connections =</span><br><span class="line">            Allocator_realloc(context-&gt;allocator, context-&gt;pub.connectionList.connections, newSize);</span><br><span class="line">        context-&gt;connectionCapacity += 4;</span><br><span class="line">    &#125;</span><br><span class="line">    struct IpTunnel_Connection* conn =</span><br><span class="line">        &amp;context-&gt;pub.connectionList.connections[context-&gt;pub.connectionList.count];</span><br><span class="line"></span><br><span class="line">    // If it&apos;s an incoming connection, it must be lower on the list than any outgoing connections.</span><br><span class="line">    if (!isOutgoing) &#123;</span><br><span class="line">        for (int i = (int)context-&gt;pub.connectionList.count - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">            if (!context-&gt;pub.connectionList.connections[i].isOutgoing</span><br><span class="line">                &amp;&amp; conn != &amp;context-&gt;pub.connectionList.connections[i + 1])</span><br><span class="line">            &#123;</span><br><span class="line">                Bits_memcpy(conn,</span><br><span class="line">                                 &amp;context-&gt;pub.connectionList.connections[i + 1],</span><br><span class="line">                                 sizeof(struct IpTunnel_Connection));</span><br><span class="line">                conn = &amp;context-&gt;pub.connectionList.connections[i + 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    context-&gt;pub.connectionList.count++;</span><br><span class="line"></span><br><span class="line">    Bits_memset(conn, 0, sizeof(struct IpTunnel_Connection));</span><br><span class="line">    conn-&gt;number = context-&gt;nextConnectionNumber++;</span><br><span class="line">    conn-&gt;isOutgoing = isOutgoing;</span><br><span class="line">    conn-&gt;reachable = false;</span><br><span class="line"></span><br><span class="line">    // if there are 2 billion calls, die.</span><br><span class="line">    Assert_true(context-&gt;nextConnectionNumber &lt; (UINT32_MAX &gt;&gt; 1));</span><br><span class="line"></span><br><span class="line">    return conn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第一个参数指定了是否为离岸点，其他部分没什么特别，普通的赋值操作。</p>
<h4 id="收到其他点发送来的分配地址的请求"><a href="#收到其他点发送来的分配地址的请求" class="headerlink" title="收到其他点发送来的分配地址的请求"></a>收到其他点发送来的分配地址的请求</h4><p>所有从其他点发送过来，进入IpTunnel的数据，都先到incomingFromNode方法中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">static Iface_DEFUN incomingFromNode(struct Message* message, struct Iface* nodeIf)</span><br><span class="line">&#123;</span><br><span class="line">    struct IpTunnel_pvt* context =</span><br><span class="line">        Identity_containerOf(nodeIf, struct IpTunnel_pvt, pub.nodeInterface);</span><br><span class="line"></span><br><span class="line">    //Log_debug(context-&gt;logger, &quot;Got incoming message&quot;);</span><br><span class="line"></span><br><span class="line">    Assert_true(message-&gt;length &gt;= RouteHeader_SIZE + DataHeader_SIZE);</span><br><span class="line">    struct RouteHeader* rh = (struct RouteHeader*) message-&gt;bytes;</span><br><span class="line">    struct DataHeader* dh = (struct DataHeader*) &amp;rh[1];</span><br><span class="line">    Assert_true(DataHeader_getContentType(dh) == ContentType_IPTUN);</span><br><span class="line">    struct IpTunnel_Connection* conn = connectionByPubKey(rh-&gt;publicKey, context);</span><br><span class="line">    if (!conn) &#123;</span><br><span class="line">        if (Defined(Log_DEBUG)) &#123;</span><br><span class="line">            uint8_t addr[40];</span><br><span class="line">            AddrTools_printIp(addr, rh-&gt;ip6);</span><br><span class="line">            Log_debug(context-&gt;logger, &quot;Got message from unrecognized node [%s]&quot;, addr);</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Message_shift(message, -(RouteHeader_SIZE + DataHeader_SIZE), NULL);</span><br><span class="line"></span><br><span class="line">    if (message-&gt;length &gt; 40 &amp;&amp; Headers_getIpVersion(message-&gt;bytes) == 6) &#123;</span><br><span class="line">        return ip6FromNode(message, conn, context);</span><br><span class="line">    &#125;</span><br><span class="line">    if (message-&gt;length &gt; 20 &amp;&amp; Headers_getIpVersion(message-&gt;bytes) == 4) &#123;</span><br><span class="line">        return ip4FromNode(message, conn, context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (Defined(Log_DEBUG)) &#123;</span><br><span class="line">        uint8_t addr[40];</span><br><span class="line">        AddrTools_printIp(addr, rh-&gt;ip6);</span><br><span class="line">        Log_debug(context-&gt;logger,</span><br><span class="line">                  &quot;Got message of unknown type, length: [%d], IP version [%d] from [%s]&quot;,</span><br><span class="line">                  message-&gt;length,</span><br><span class="line">                  (message-&gt;length &gt; 1) ? Headers_getIpVersion(message-&gt;bytes) : 0,</span><br><span class="line">                  addr);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li><p>通过publicKey找到对应的conn。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct IpTunnel_Connection* conn = connectionByPubKey(rh-&gt;publicKey, context);</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用ip6FromNode</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (message-&gt;length &gt; 40 &amp;&amp; Headers_getIpVersion(message-&gt;bytes) == 6) &#123;</span><br><span class="line">    return ip6FromNode(message, conn, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static Iface_DEFUN ip6FromNode(struct Message* message,</span><br><span class="line">                               struct IpTunnel_Connection* conn,</span><br><span class="line">                               struct IpTunnel_pvt* context)</span><br><span class="line">&#123;</span><br><span class="line">    struct Headers_IP6Header* header = (struct Headers_IP6Header*) message-&gt;bytes;</span><br><span class="line">    if (Bits_isZero(header-&gt;sourceAddr, 16) || Bits_isZero(header-&gt;destinationAddr, 16)) &#123;</span><br><span class="line">        if (Bits_isZero(header-&gt;sourceAddr, 32)) &#123;</span><br><span class="line">            return incomingControlMessage(message, conn, context);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!isValidAddress6(header-&gt;sourceAddr, false, conn)) &#123;</span><br><span class="line">        ......</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    return Iface_next(&amp;context-&gt;pub.tunInterface, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时header-&gt;sourceAddr为全0，会调用到incomingControlMessage方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static Iface_DEFUN incomingControlMessage(struct Message* message,</span><br><span class="line">                                          struct IpTunnel_Connection* conn,</span><br><span class="line">                                          struct IpTunnel_pvt* context)</span><br><span class="line">&#123;</span><br><span class="line">       ......</span><br><span class="line">    Dict* d = NULL;</span><br><span class="line">    char* err = BencMessageReader_readNoExcept(message, alloc, &amp;d);</span><br><span class="line">    if (err) &#123;</span><br><span class="line">        Log_info(context-&gt;logger, &quot;Failed to parse message [%s]&quot;, err);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     ....</span><br><span class="line">    if (String_equals(String_CONST(&quot;IpTunnel_getAddresses&quot;),</span><br><span class="line">                      Dict_getStringC(d, &quot;q&quot;)))</span><br><span class="line">    &#123;</span><br><span class="line">        return requestForAddresses(d, conn, alloc, context);</span><br><span class="line">    &#125;</span><br><span class="line">    Log_warn(context-&gt;logger, &quot;Message which is unhandled&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为普通点在向离岸点发送分配ipv4地址的请求时，会将q字段的值设为IpTunnel_getAddresses，所以，在离岸点收到这类信息时，会调用到requestForAddresses方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">static Iface_DEFUN requestForAddresses(Dict* request,</span><br><span class="line">                                       struct IpTunnel_Connection* conn,</span><br><span class="line">                                       struct Allocator* requestAlloc,</span><br><span class="line">                                       struct IpTunnel_pvt* context)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    Dict* addresses = Dict_new(requestAlloc);</span><br><span class="line">    bool noAddresses = true;</span><br><span class="line">    if (!Bits_isZero(conn-&gt;connectionIp6, 16)) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    if (!Bits_isZero(conn-&gt;connectionIp4, 4)) &#123;</span><br><span class="line">        Dict_putStringC(addresses,</span><br><span class="line">                       &quot;ip4&quot;,</span><br><span class="line">                       String_newBinary((char*)conn-&gt;connectionIp4, 4, requestAlloc),</span><br><span class="line">                       requestAlloc);</span><br><span class="line">        Dict_putIntC(addresses,</span><br><span class="line">                    &quot;ip4Prefix&quot;, (int64_t)conn-&gt;connectionIp4Prefix,</span><br><span class="line">                    requestAlloc);</span><br><span class="line">        Dict_putIntC(addresses,</span><br><span class="line">                    &quot;ip4Alloc&quot;, (int64_t)conn-&gt;connectionIp4Alloc,</span><br><span class="line">                    requestAlloc);</span><br><span class="line"></span><br><span class="line">        noAddresses = false;</span><br><span class="line">    &#125;</span><br><span class="line">    if (noAddresses) &#123;</span><br><span class="line">        Log_warn(context-&gt;logger, &quot;no addresses to provide&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Dict* msg = Dict_new(requestAlloc);</span><br><span class="line">    Dict_putDictC(msg, &quot;addresses&quot;, addresses, requestAlloc);</span><br><span class="line"></span><br><span class="line">    String* txid = Dict_getStringC(request, &quot;txid&quot;);</span><br><span class="line">    if (txid) &#123;</span><br><span class="line">        Dict_putStringC(msg, &quot;txid&quot;, txid, requestAlloc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sendControlMessage(msg, conn, requestAlloc, context);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将conf文件中，分配给这个连接的ipv4地址相关信息，填入addresses中，再将key为addresses，value为addresses的键值对，放入Dict中，调用sendControlMessage发送出去。当普通点收到这个回复后，会从中取出addresses，并进行ipv4相关字段的设置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">static void sendControlMessage(Dict* dict,</span><br><span class="line">                               struct IpTunnel_Connection* connection,</span><br><span class="line">                               struct Allocator* requestAlloc,</span><br><span class="line">                               struct IpTunnel_pvt* context)</span><br><span class="line">&#123;</span><br><span class="line">    struct Message* msg = Message_new(0, 1024, requestAlloc);</span><br><span class="line">    BencMessageWriter_write(dict, msg, NULL);</span><br><span class="line"></span><br><span class="line">    int length = msg-&gt;length;</span><br><span class="line"></span><br><span class="line">    // do UDP header.</span><br><span class="line">    Message_shift(msg, Headers_UDPHeader_SIZE, NULL);</span><br><span class="line">    struct Headers_UDPHeader* uh = (struct Headers_UDPHeader*) msg-&gt;bytes;</span><br><span class="line">    uh-&gt;srcPort_be = 0;</span><br><span class="line">    uh-&gt;destPort_be = 0;</span><br><span class="line">    uh-&gt;length_be = Endian_hostToBigEndian16(length);</span><br><span class="line">    uh-&gt;checksum_be = 0;</span><br><span class="line"></span><br><span class="line">    uint16_t payloadLength = msg-&gt;length;</span><br><span class="line"></span><br><span class="line">    Message_shift(msg, Headers_IP6Header_SIZE, NULL);</span><br><span class="line">    struct Headers_IP6Header* header = (struct Headers_IP6Header*) msg-&gt;bytes;</span><br><span class="line">    header-&gt;versionClassAndFlowLabel = 0;</span><br><span class="line">    header-&gt;flowLabelLow_be = 0;</span><br><span class="line">    header-&gt;nextHeader = 17;</span><br><span class="line">    header-&gt;hopLimit = 0;</span><br><span class="line">    header-&gt;payloadLength_be = Endian_hostToBigEndian16(payloadLength);</span><br><span class="line">    Headers_setIpVersion(header);</span><br><span class="line"></span><br><span class="line">    // zero the source and dest addresses.</span><br><span class="line">    Bits_memset(header-&gt;sourceAddr, 0, 32);</span><br><span class="line"></span><br><span class="line">    uh-&gt;checksum_be = Checksum_udpIp6(header-&gt;sourceAddr,</span><br><span class="line">                                      (uint8_t*) uh,</span><br><span class="line">                                      msg-&gt;length - Headers_IP6Header_SIZE);</span><br><span class="line"></span><br><span class="line">    Iface_CALL(sendToNode, msg, connection, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用sendToNode<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static Iface_DEFUN sendToNode(struct Message* message,</span><br><span class="line">                              struct IpTunnel_Connection* connection,</span><br><span class="line">                              struct IpTunnel_pvt* context)</span><br><span class="line">&#123;</span><br><span class="line">    Message_push(message, NULL, DataHeader_SIZE, NULL);</span><br><span class="line">    struct DataHeader* dh = (struct DataHeader*) message-&gt;bytes;</span><br><span class="line">    DataHeader_setContentType(dh, ContentType_IPTUN);</span><br><span class="line">    DataHeader_setVersion(dh, DataHeader_CURRENT_VERSION);</span><br><span class="line">    Message_push(message, &amp;connection-&gt;routeHeader, RouteHeader_SIZE, NULL);</span><br><span class="line">    return Iface_next(&amp;context-&gt;pub.nodeInterface, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至此，离岸点在收到普通点的ipv4分配申请后的执行流程分析完毕。</p>
<h2 id="处理从其他点发来的消息"><a href="#处理从其他点发来的消息" class="headerlink" title="处理从其他点发来的消息"></a>处理从其他点发来的消息</h2><p>上面讲到，所有从其他点发送过来，进入IpTunnel的数据，都先到incomingFromNode方法中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">static Iface_DEFUN incomingFromNode(struct Message* message, struct Iface* nodeIf)</span><br><span class="line">&#123;</span><br><span class="line">    struct IpTunnel_pvt* context =</span><br><span class="line">        Identity_containerOf(nodeIf, struct IpTunnel_pvt, pub.nodeInterface);</span><br><span class="line"></span><br><span class="line">    Assert_true(message-&gt;length &gt;= RouteHeader_SIZE + DataHeader_SIZE);</span><br><span class="line">    struct RouteHeader* rh = (struct RouteHeader*) message-&gt;bytes;</span><br><span class="line">    struct DataHeader* dh = (struct DataHeader*) &amp;rh[1];</span><br><span class="line">    Assert_true(DataHeader_getContentType(dh) == ContentType_IPTUN);</span><br><span class="line">    struct IpTunnel_Connection* conn = connectionByPubKey(rh-&gt;publicKey, context);</span><br><span class="line">    if (!conn) &#123;</span><br><span class="line">        if (Defined(Log_DEBUG)) &#123;</span><br><span class="line">            uint8_t addr[40];</span><br><span class="line">            AddrTools_printIp(addr, rh-&gt;ip6);</span><br><span class="line">            Log_debug(context-&gt;logger, &quot;Got message from unrecognized node [%s]&quot;, addr);</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Message_shift(message, -(RouteHeader_SIZE + DataHeader_SIZE), NULL);</span><br><span class="line"></span><br><span class="line">    if (message-&gt;length &gt; 40 &amp;&amp; Headers_getIpVersion(message-&gt;bytes) == 6) &#123;</span><br><span class="line">        return ip6FromNode(message, conn, context);</span><br><span class="line">    &#125;</span><br><span class="line">    if (message-&gt;length &gt; 20 &amp;&amp; Headers_getIpVersion(message-&gt;bytes) == 4) &#123;</span><br><span class="line">        return ip4FromNode(message, conn, context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (Defined(Log_DEBUG)) &#123;</span><br><span class="line">        uint8_t addr[40];</span><br><span class="line">        AddrTools_printIp(addr, rh-&gt;ip6);</span><br><span class="line">        Log_debug(context-&gt;logger,</span><br><span class="line">                  &quot;Got message of unknown type, length: [%d], IP version [%d] from [%s]&quot;,</span><br><span class="line">                  message-&gt;length,</span><br><span class="line">                  (message-&gt;length &gt; 1) ? Headers_getIpVersion(message-&gt;bytes) : 0,</span><br><span class="line">                  addr);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以ipv4为例，进入到ip4FromNode<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">static Iface_DEFUN ip4FromNode(struct Message* message,</span><br><span class="line">                               struct IpTunnel_Connection* conn,</span><br><span class="line">                               struct IpTunnel_pvt* context)</span><br><span class="line">&#123;</span><br><span class="line">    struct Headers_IP4Header* header = (struct Headers_IP4Header*) message-&gt;bytes;</span><br><span class="line">    if (Bits_isZero(header-&gt;sourceAddr, 4) || Bits_isZero(header-&gt;destAddr, 4)) &#123;</span><br><span class="line">        Log_debug(context-&gt;logger, &quot;Got message with zero address&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125; else if (!isValidAddress4(header-&gt;sourceAddr, false, conn)) &#123;</span><br><span class="line">        Log_debug(context-&gt;logger, &quot;Got message with wrong address [%d.%d.%d.%d] for connection &quot;</span><br><span class="line">                                   &quot;[%d.%d.%d.%d/%d:%d]&quot;,</span><br><span class="line">                  header-&gt;sourceAddr[0], header-&gt;sourceAddr[1],</span><br><span class="line">                  header-&gt;sourceAddr[2], header-&gt;sourceAddr[3],</span><br><span class="line">                  conn-&gt;connectionIp4[0], conn-&gt;connectionIp4[1],</span><br><span class="line">                  conn-&gt;connectionIp4[2], conn-&gt;connectionIp4[3],</span><br><span class="line">                  conn-&gt;connectionIp4Alloc, conn-&gt;connectionIp4Prefix);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    Log_debug(context-&gt;logger, &quot;chris Got message with address [%d.%d.%d.%d] for connection &quot;</span><br><span class="line">                                   &quot;[%d.%d.%d.%d/%d:%d]&quot;,</span><br><span class="line">                  header-&gt;sourceAddr[0], header-&gt;sourceAddr[1],</span><br><span class="line">                  header-&gt;sourceAddr[2], header-&gt;sourceAddr[3],</span><br><span class="line">                  conn-&gt;connectionIp4[0], conn-&gt;connectionIp4[1],</span><br><span class="line">                  conn-&gt;connectionIp4[2], conn-&gt;connectionIp4[3],</span><br><span class="line">                  conn-&gt;connectionIp4Alloc, conn-&gt;connectionIp4Prefix);</span><br><span class="line">    TUNMessageType_push(message, Ethernet_TYPE_IP4, NULL);</span><br><span class="line">    return Iface_next(&amp;context-&gt;pub.tunInterface, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此时，header-&gt;sourceAddr是对方的ipv4地址，不会为全0，代码进入到一个ip地址合法性判断：isValidAddress4(header-&gt;sourceAddr, false, conn)。如果地址合法，消息进一步发送到context-&gt;pub.tunInterface中。<br>tunInterface是一个Iface，它的回调函数在IpTunnel_new中设置为incomingFromTun<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.pub = &#123;</span><br><span class="line">    .tunInterface = &#123; .send = incomingFromTun &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p>
<p>它的connectedIf在Core.c的Core_init方法中通过Iface_plumb方法与nc-&gt;tunAdapt-&gt;ipTunnelIf绑定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Iface_plumb(&amp;nc-&gt;tunAdapt-&gt;ipTunnelIf, &amp;ipTunnel-&gt;tunInterface);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static inline void Iface_plumb(struct Iface* a, struct Iface* b)</span><br><span class="line">&#123;</span><br><span class="line">    Assert_true(!a-&gt;connectedIf);</span><br><span class="line">    Assert_true(!b-&gt;connectedIf);</span><br><span class="line">    a-&gt;connectedIf = b;</span><br><span class="line">    b-&gt;connectedIf = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查看地址合法性判断"><a href="#查看地址合法性判断" class="headerlink" title="查看地址合法性判断"></a>查看地址合法性判断</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static bool isValidAddress4(uint8_t sourceAndDestIp4[8],</span><br><span class="line">                            bool isFromTun,</span><br><span class="line">                            struct IpTunnel_Connection* conn)</span><br><span class="line">&#123;</span><br><span class="line">    uint8_t* compareAddr = (isFromTun)</span><br><span class="line">        ? ((conn-&gt;isOutgoing) ? sourceAndDestIp4 : &amp;sourceAndDestIp4[4])</span><br><span class="line">        : ((conn-&gt;isOutgoing) ? &amp;sourceAndDestIp4[4] : sourceAndDestIp4);</span><br><span class="line">    return prefixMatches4(compareAddr, conn-&gt;connectionIp4, conn-&gt;connectionIp4Alloc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ifFromTun为false，接下来根据isOutgoing的值来决定compareAddr的值，分为两种情况</p>
<ol>
<li>当前点是普通点，那么他收到的消息是从离岸点发送过来的，isOutgoing为<br>true，compareAddr赋值为sourceAndDestIp4[4]，也就是dest ip,从离岸点发来的包的dest ip就是当前这个普通点的ipv4地址。</li>
<li>当前点是离岸点，那么它收到的消息是从普通点发送过来的，isOutgoing为<br>false，compareAddr赋值为sourceAndDestIp4，也就是source ip，从普通点发来的包的source ip就是普通点的ipv4地址。<br>综上，compareAddr一定会被赋值为普通点的ipv4地址。接下来调用prefixMatches4方法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static bool prefixMatches4(uint8_t* addressA, uint8_t* refAddr, uint32_t prefixLen)</span><br><span class="line">&#123;</span><br><span class="line">    if (!prefixLen) &#123;</span><br><span class="line">        Assert_true(Bits_isZero(refAddr, 4));</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    Assert_true(prefixLen &amp;&amp; prefixLen &lt;= 32);</span><br><span class="line">    uint32_t a = GET32(addressA);</span><br><span class="line">    uint32_t b = GET32(refAddr);</span><br><span class="line">    return !((a ^ b) &gt;&gt; (32 - prefixLen));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这就只是一个简单的地址比较了。</p>
<h2 id="处理从Tun设备发来的消息"><a href="#处理从Tun设备发来的消息" class="headerlink" title="处理从Tun设备发来的消息"></a>处理从Tun设备发来的消息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">static Iface_DEFUN incomingFromTun(struct Message* message, struct Iface* tunIf)</span><br><span class="line">&#123;</span><br><span class="line">    struct IpTunnel_pvt* context = Identity_check((struct IpTunnel_pvt*)tunIf);</span><br><span class="line"></span><br><span class="line">    if (message-&gt;length &lt; 20) &#123;</span><br><span class="line">        Log_debug(context-&gt;logger, &quot;DROP runt&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct IpTunnel_Connection* conn = NULL;</span><br><span class="line">    if (!context-&gt;pub.connectionList.connections) &#123;</span><br><span class="line">        // No connections authorized, fall through to &quot;unrecognized address&quot;</span><br><span class="line">    &#125; else if (message-&gt;length &gt; 40 &amp;&amp; Headers_getIpVersion(message-&gt;bytes) == 6) &#123;</span><br><span class="line">        struct Headers_IP6Header* header = (struct Headers_IP6Header*) message-&gt;bytes;</span><br><span class="line">        conn = findConnection(header-&gt;sourceAddr, NULL, true, context);</span><br><span class="line">    &#125; else if (message-&gt;length &gt; 20 &amp;&amp; Headers_getIpVersion(message-&gt;bytes) == 4) &#123;</span><br><span class="line">        struct Headers_IP4Header* header = (struct Headers_IP4Header*) message-&gt;bytes;</span><br><span class="line">        conn = findConnection(NULL, header-&gt;sourceAddr, true, context);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Log_info(context-&gt;logger, &quot;Message of unknown type from TUN&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!conn) &#123;</span><br><span class="line">        Log_info(context-&gt;logger, &quot;Message with unrecognized address from TUN&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return sendToNode(message, conn, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里主要进行了两个操作：</p>
<ol>
<li>调用findConnection查找conn</li>
<li>调用sendToNode</li>
</ol>
<h3 id="查找conn"><a href="#查找conn" class="headerlink" title="查找conn"></a>查找conn</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static struct IpTunnel_Connection* findConnection(uint8_t sourceAndDestIp6[32],</span><br><span class="line">                                                  uint8_t sourceAndDestIp4[8],</span><br><span class="line">                                                  bool isFromTun,</span><br><span class="line">                                                  struct IpTunnel_pvt* context)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; (int)context-&gt;pub.connectionList.count; i++) &#123;</span><br><span class="line">        struct IpTunnel_Connection* conn = &amp;context-&gt;pub.connectionList.connections[i];</span><br><span class="line">        if (sourceAndDestIp6 &amp;&amp; isValidAddress6(sourceAndDestIp6, isFromTun, conn)) &#123;</span><br><span class="line">            return conn;</span><br><span class="line">        &#125;</span><br><span class="line">        if (sourceAndDestIp4 &amp;&amp; isValidAddress4(sourceAndDestIp4, isFromTun, conn)) &#123;</span><br><span class="line">            return conn;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以ipv4为例，调用isValidAddress4检查地址合法性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static bool isValidAddress4(uint8_t sourceAndDestIp4[8],</span><br><span class="line">                            bool isFromTun,</span><br><span class="line">                            struct IpTunnel_Connection* conn)</span><br><span class="line">&#123;</span><br><span class="line">    uint8_t* compareAddr = (isFromTun)</span><br><span class="line">        ? ((conn-&gt;isOutgoing) ? sourceAndDestIp4 : &amp;sourceAndDestIp4[4])</span><br><span class="line">        : ((conn-&gt;isOutgoing) ? &amp;sourceAndDestIp4[4] : sourceAndDestIp4);</span><br><span class="line">    return prefixMatches4(compareAddr, conn-&gt;connectionIp4, conn-&gt;connectionIp4Alloc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ifFromTun为true，接下来根据isOutgoing的值来决定compareAddr的值，分为两种情况</p>
<ol>
<li>当前点是普通点，那么他的消息是发往离岸点的，isOutgoing为<br>true，compareAddr赋值为sourceAndDestIp4，也就是source ip,是当前这个普通点的ipv4地址。</li>
<li>当前点是离岸点，那么他的消息是发往普通点的，isOutgoing为<br>false，compareAddr赋值为sourceAndDestIp4[4]，也就是dest ip，发往普通点的包的dest ip就是普通点的ipv4地址。<br>综上，compareAddr一定会被赋值为普通点的ipv4地址。接下来调用prefixMatches4方法，进行地址对比。</li>
</ol>
<h3 id="sendToNode"><a href="#sendToNode" class="headerlink" title="sendToNode"></a>sendToNode</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static Iface_DEFUN sendToNode(struct Message* message,</span><br><span class="line">                              struct IpTunnel_Connection* connection,</span><br><span class="line">                              struct IpTunnel_pvt* context)</span><br><span class="line">&#123;</span><br><span class="line">    Message_push(message, NULL, DataHeader_SIZE, NULL);</span><br><span class="line">    struct DataHeader* dh = (struct DataHeader*) message-&gt;bytes;</span><br><span class="line">    DataHeader_setContentType(dh, ContentType_IPTUN);</span><br><span class="line">    DataHeader_setVersion(dh, DataHeader_CURRENT_VERSION);</span><br><span class="line">    Message_push(message, &amp;connection-&gt;routeHeader, RouteHeader_SIZE, NULL);</span><br><span class="line">    return Iface_next(&amp;context-&gt;pub.nodeInterface, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，IpTunnel收到从Tun上和从其他点发来的包，并进行处理的过程分析完成。</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/cjdns/" rel="tag"># cjdns</a>
          
            <a href="/tags/cjdns源码分析/" rel="tag"># cjdns源码分析</a>
          
            <a href="/tags/C-C/" rel="tag"># C/C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/04/27/about-iptables/" rel="next" title="cjdns源码分析--iptables在cjdns项目中的运用">
                <i class="fa fa-chevron-left"></i> cjdns源码分析--iptables在cjdns项目中的运用
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/08/02/cjdns_RouteGen-d/" rel="prev" title="cjdns源码分析--RouteGen">
                cjdns源码分析--RouteGen <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Chris King</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">74</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">23</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">29</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#源码分析"><span class="nav-number">1.</span> <span class="nav-text">源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#结构体"><span class="nav-number">1.1.</span> <span class="nav-text">结构体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#conf文件起到的作用"><span class="nav-number">1.2.</span> <span class="nav-text">conf文件起到的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#普通点建立一个离岸点的IpTunnel-Connection"><span class="nav-number">1.3.</span> <span class="nav-text">普通点建立一个离岸点的IpTunnel_Connection</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#conf文件配置"><span class="nav-number">1.3.1.</span> <span class="nav-text">conf文件配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#读取配置文件"><span class="nav-number">1.3.2.</span> <span class="nav-text">读取配置文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IpTunnel-connectTo方法"><span class="nav-number">1.3.3.</span> <span class="nav-text">IpTunnel_connectTo方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IpTunnel-connectTo方法-1"><span class="nav-number">1.3.4.</span> <span class="nav-text">IpTunnel_connectTo方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#创建一个IpTunnel-Connection类型的conn"><span class="nav-number">1.3.5.</span> <span class="nav-text">创建一个IpTunnel_Connection类型的conn</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#向离岸点申请ipv4地址"><span class="nav-number">1.3.6.</span> <span class="nav-text">向离岸点申请ipv4地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#收到离岸点分配的ipv4地址"><span class="nav-number">1.3.7.</span> <span class="nav-text">收到离岸点分配的ipv4地址</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#离岸点为每个允许连接过来的普通点建立一个IpTunnel-Connection"><span class="nav-number">1.4.</span> <span class="nav-text">离岸点为每个允许连接过来的普通点建立一个IpTunnel_Connection</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#conf文件配置-1"><span class="nav-number">1.4.1.</span> <span class="nav-text">conf文件配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#读取配置文件-1"><span class="nav-number">1.4.2.</span> <span class="nav-text">读取配置文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IpTunnel-allowConnection方法"><span class="nav-number">1.4.3.</span> <span class="nav-text">IpTunnel_allowConnection方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IpTunnel-allowConnection方法-1"><span class="nav-number">1.4.4.</span> <span class="nav-text">IpTunnel_allowConnection方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#创建一个IpTunnel-Connection类型的conn-1"><span class="nav-number">1.4.5.</span> <span class="nav-text">创建一个IpTunnel_Connection类型的conn</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#收到其他点发送来的分配地址的请求"><span class="nav-number">1.4.6.</span> <span class="nav-text">收到其他点发送来的分配地址的请求</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#处理从其他点发来的消息"><span class="nav-number">2.</span> <span class="nav-text">处理从其他点发来的消息</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#查看地址合法性判断"><span class="nav-number">2.1.</span> <span class="nav-text">查看地址合法性判断</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#处理从Tun设备发来的消息"><span class="nav-number">3.</span> <span class="nav-text">处理从Tun设备发来的消息</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#查找conn"><span class="nav-number">3.1.</span> <span class="nav-text">查找conn</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sendToNode"><span class="nav-number">3.2.</span> <span class="nav-text">sendToNode</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chris King</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.0.1</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/schemes/muse.js?v=7.0.1"></script>



  
  <script src="/js/src/scrollspy.js?v=7.0.1"></script>
<script src="/js/src/post-details.js?v=7.0.1"></script>



  


  <script src="/js/src/next-boot.js?v=7.0.1"></script>


  

  

  

  


  


  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
