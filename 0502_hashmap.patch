diff --git a/net/TUNAdapter.c b/net/TUNAdapter.c
index 353e386..98da399 100644
--- a/net/TUNAdapter.c
+++ b/net/TUNAdapter.c
@@ -29,6 +29,7 @@
 #include "policy/PacketParser.h"
 #include "policy/Policy.h"
 #include "policy/SessionState.h"
+#include "util/Hashmap.h"
 
 struct TUNAdapter_pvt
 {
@@ -38,7 +39,7 @@ struct TUNAdapter_pvt
     struct PacketParser* parser;
     uint8_t myIp6[16];
     struct Allocator* alloc;
-    struct Map_SessionStates sessionMap;
+    struct Hashmap_hash* sessionMap;
     Identity
 };
 
@@ -63,7 +64,7 @@ static Iface_DEFUN incomingFromTunIf(struct Message* msg, struct Iface* tunIf)
         if (PacketParser_parse(ud->parser, msg, &hdr) == 0) {
             SessionState_printHeader(version, &hdr, ud->log, false);
             int sessionState = SessionState_getSessionState(&hdr, false,
-                                    &ud->sessionMap, ud->alloc, ud->log);
+                                    ud->sessionMap, ud->alloc, ud->log);
             Log_debug(ud->log,"jin out sessionState is [%d]", sessionState);
             Log_debug(ud->log,"jin---");
         }
@@ -183,7 +184,7 @@ static Iface_DEFUN sendToTunIf(struct Message* msg, struct TUNAdapter_pvt* ud)
         Message_shift(msg,-4,NULL);
         if (PacketParser_parse(ud->parser, msg, &hdr) == 0) {
             int sessionState = SessionState_getSessionState(&hdr, true,
-                                    &ud->sessionMap, ud->alloc, ud->log);
+                                    ud->sessionMap, ud->alloc, ud->log);
             Log_debug(ud->log,"jin in sessionState is [%d]", sessionState);
             Log_debug(ud->log,"jin---");
         }
@@ -285,9 +286,12 @@ struct TUNAdapter* TUNAdapter_new(struct Allocator* allocator, struct Log* log,
     out->log = log;
     out->policy = policy;
     out->parser = PacketParser_new(log, alloc);
-    out->sessionMap.allocator = alloc;
+    //out->sessionMap.allocator = alloc;
     out->alloc = alloc;
     Identity_set(out);
     Bits_memcpy(out->myIp6, myIp6, 16);
+    out->sessionMap = Hashmap_new(PacketParserHeader_hash,
+                                  PacketParserHeader_compare,
+                                  NULL, NULL);
     return &out->pub;
 }
diff --git a/policy/SessionState.c b/policy/SessionState.c
index bb426c5..2b0a58f 100644
--- a/policy/SessionState.c
+++ b/policy/SessionState.c
@@ -18,7 +18,7 @@
 #include <sys/time.h>
 #include <stdbool.h>
 #include "policy/PacketParser.h"
-#include "util/Hash.h"
+//#include "util/Hash.h"
 
 /*
 #define SESSIONSTATE_NEW 0
@@ -27,8 +27,8 @@
 #define SESSIONSTATE_INVALID -1
 */
 
-#define SESSIONMAP_SIZE_MAX 2000
-#define SESSIONMAP_SIZE_WARNNING 1800
+#define SESSIONMAP_SIZE_MAX 5000
+#define SESSIONMAP_SIZE_WARNNING 4500
 #define TIMEOUT_SECONDS 60
 
 static bool isReply(struct SessionState* sessionState, struct PacketParser_Header* hdr)
@@ -40,20 +40,25 @@ static bool isReply(struct SessionState* sessionState, struct PacketParser_Heade
 void SessionState_printHeader(int version, struct PacketParser_Header* hdr,
                                        struct Log* log, bool in)
 {
+    HashmapKey hkey = {
+        .key = hdr,
+        .length = sizeof(struct PacketParser_Header)
+    };
     if (version == 4)
     {
         Log_debug(log,
         "jin [%s] version:4 af:[%s] src:[%u] dst:[%u] protocol:[%d] srcPort:[%u] "
-        "dstPort:[%u],tcp:[%x],hash:[%u]",
+        "dstPort:[%u],tcp:[%x],hash:[%u],isIpv4:[%s]",
         in? "in":"out", (hdr->af == AF_INET)? "AF_INET":"AF_INET6", hdr->src.v4, hdr->dst.v4,
         //(hdr->protocol == IPPROTO_TCP)? "TCP":((hdr->protocol == IPPROTO_UDP)? "UDP":"OTHER"),
         hdr->protocol,
-        hdr->srcPort_be, hdr->dstPort_be,hdr->tcp.flags,PacketParserHeader_hash(hdr));
+        hdr->srcPort_be, hdr->dstPort_be,hdr->tcp.flags,PacketParserHeader_hash(&hkey),
+        hdr->isIpv4? "true":"false");
     } else {
         Log_debug(log,
         "jin [%s] version:6 af:[%s] src:[%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x] "
         "dst:[%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x] protocol:[%d] "
-        "srcPort:[%u],dstPort:[%u],tcp:[%x], hash:[%u]", in? "in":"out",
+        "srcPort:[%u],dstPort:[%u],tcp:[%x], hash:[%u],isIpv4:[%s]", in? "in":"out",
         (hdr->af == AF_INET)? "AF_INET":"AF_INET6",
         hdr->src.v6[0],hdr->src.v6[1],hdr->src.v6[2],hdr->src.v6[3],
         hdr->src.v6[4],hdr->src.v6[5],hdr->src.v6[6],hdr->src.v6[7],
@@ -65,14 +70,16 @@ void SessionState_printHeader(int version, struct PacketParser_Header* hdr,
         hdr->dst.v6[12],hdr->dst.v6[13],hdr->dst.v6[14],hdr->dst.v6[15],
         //(hdr->protocol == IPPROTO_TCP)? "TCP":((hdr->protocol == IPPROTO_UDP)? "UDP":"OTHER"),
         hdr->protocol,
-        hdr->srcPort_be, hdr->dstPort_be,hdr->tcp.flags,PacketParserHeader_hash(hdr));
+        hdr->srcPort_be, hdr->dstPort_be,hdr->tcp.flags,PacketParserHeader_hash(&hkey),
+        hdr->isIpv4? "true":"false");
     }
 }
 
-static void remove_timeout_sessionStates(time_t now, struct Map_SessionStates* map,
+/*
+static void remove_timeout_sessionStates(time_t now, struct Hashmap_hash* map,
                                         struct Log* log)
 {
-    for (int i=0; i<((int)map->count)/2; i++)
+    for (int i=0; i<((int)Hashmap_get_count(map))/2; i++)
     {
         struct SessionState* sessionState = map->values[i];
         long lastPkt = (long)sessionState->timeOfLastPacket;
@@ -81,19 +88,27 @@ static void remove_timeout_sessionStates(time_t now, struct Map_SessionStates* m
         {
             SessionState_printHeader(map->keys[i]->isIpv4? 4:6,map->keys[i],log,true);
             Log_debug(log,"jin state is [%d]",sessionState->state);
-
-            Map_SessionStates_remove(i,map);
+            HashmapKey hkey = {
+                .key = hdr,
+                .length = sizeof(struct PacketParser_Header)
+            };
+            Hashmap_remove(map, &hkey);
+            //Map_SessionStates_remove(i,map);
             Allocator_free(sessionState->alloc);
             Log_debug(log,"jin remove index is [%d],now count is [%d].",i,map->count);
         }
     }
-}
+}*/
 
-static int createNewSessionState(struct PacketParser_Header* head,
-        struct Map_SessionStates* map, struct Allocator* alloc, bool isIn, struct Log* log)
+static void createNewSessionState(struct PacketParser_Header* head,
+        struct Hashmap_hash* map, struct Allocator* alloc, bool isIn, struct Log* log)
 {
     struct Allocator* mapItemAlloc = Allocator_child(alloc);
     struct PacketParser_Header* hdr = Header_clone(head, mapItemAlloc);
+//~ struct RuleSet_pvt* out = Allocator_calloc(alloc, sizeof(struct RuleSet_pvt), 1);
+    HashmapKey* hkey = Allocator_calloc(mapItemAlloc,sizeof(HashmapKey), 1);
+    hkey->key = hdr,
+    hkey->length = sizeof(struct PacketParser_Header);
 
     struct SessionState* sessionState = Allocator_calloc(mapItemAlloc,
                                              sizeof(struct SessionState), 1);
@@ -105,30 +120,37 @@ static int createNewSessionState(struct PacketParser_Header* head,
     sessionState->smallerInit = isSrcSmaller(hdr);
     sessionState->alloc = mapItemAlloc;
 
-    int index = Map_SessionStates_put(&hdr, &sessionState, map);
-    Log_debug(log,"jin create new session state,index is [%d],time is [%ld]",
-            index,sessionState->timeOfLastPacket);
-    return index;
+    int result = Hashmap_put(map, hkey, sessionState);
+    //int index = Map_SessionStates_put(&hdr, &sessionState, map);
+    Log_debug(log,"jin create new session state,result is [%d],time is [%ld]",
+            result,sessionState->timeOfLastPacket);
 }
 
 int SessionState_getSessionState(struct PacketParser_Header* hdr, bool isIn,
-                    struct Map_SessionStates* map, struct Allocator* alloc, struct Log* log)
+                    struct Hashmap_hash* map, struct Allocator* alloc, struct Log* log)
 {
-    if (map->count > SESSIONMAP_SIZE_WARNNING)
+    /*if (map->count > SESSIONMAP_SIZE_WARNNING)
     {
         time_t now;
         time(&now);
         remove_timeout_sessionStates(now,map,log);
-    }
-    if (map->count < SESSIONMAP_SIZE_MAX)
+    }*/
+    if ((int)Hashmap_get_count(map) < SESSIONMAP_SIZE_MAX)
     {
-        int index = Map_SessionStates_indexForKey(&hdr, map);
-        if (index == -1) {
-            index = createNewSessionState(hdr, map, alloc, isIn, log);
+        time_t before_find;
+        time(&before_find);
+        //int index = Map_SessionStates_indexForKey(&hdr, map);
+        HashmapKey hkey = {
+            .key = hdr,
+            .length = sizeof(struct PacketParser_Header)
+        };
+        struct SessionState* sessionState = Hashmap_get(map,&hkey);
+        if (sessionState == NULL) {
+            createNewSessionState(hdr, map, alloc, isIn, log);
             //struct PacketParser_Header* head = Header_clone(hdr, alloc);
             //index = createNewSessionState(head, map, alloc, isIn, log);
         } else {
-            struct SessionState* sessionState = map->values[index];
+            //struct SessionState* sessionState = map->values[index];
             int state = sessionState->state;
             time(&(sessionState->timeOfLastPacket));
             Log_debug(log,"jin state is [%d],reply is [%d], smallerInit is [%s], time [%ld]",
@@ -158,15 +180,21 @@ int SessionState_getSessionState(struct PacketParser_Header* hdr, bool isIn,
                     break;
             }
         }
-        index = Map_SessionStates_indexForKey(&hdr, map);
-        struct SessionState* sessionState_new = map->values[index];
-        int state_new = sessionState_new->state;
-        Log_debug(log,"jin now index is [%d],state is [%d],reply is [%d], smallerInit is [%s]",
-            index,state_new,sessionState_new->reply,sessionState_new->smallerInit?"true":"false");
+        //index = Map_SessionStates_indexForKey(&hdr, map);
+        //struct SessionState* sessionState_new = map->values[index];
+        struct SessionState* sessionState_new = Hashmap_get(map,&hkey);
+        int state_new = (int)sessionState_new->state;
+        Log_debug(log,"jin now state is [%d],reply is [%d], smallerInit is [%s]",
+            state_new,sessionState_new->reply,sessionState_new->smallerInit?"true":"false");
+        time_t after_find;
+        time(&after_find);
+        Log_debug(log,"jin bef%ld,aft%ldfind%ldms,map size%d",(long)after_find, (long)before_find,
+                        (long)after_find - (long)before_find,(int)Hashmap_get_count(map));
         return state_new;
     }else{
         Log_debug(log,"jin SESSION MAP SIZE MAX");
         return SessionState_ESTABLISH;
     }
+    return SessionState_ESTABLISH;
 }
 
diff --git a/policy/SessionState.h b/policy/SessionState.h
index 0d0e8a7..30aee96 100644
--- a/policy/SessionState.h
+++ b/policy/SessionState.h
@@ -19,6 +19,7 @@
 #include <stdbool.h>
 #include "policy/PacketParser.h"
 #include "util/Hash.h"
+#include "util/Hashmap.h"
 #include "memory/Allocator.h"
 #include "util/log/Log.h"
 #include "util/Linker.h"
@@ -56,8 +57,9 @@ static bool isSrcSmaller(const struct PacketParser_Header* hdr)
     return result;
 }
 
-static uint32_t PacketParserHeader_hash(const struct PacketParser_Header* hdr)
+static uint32_t PacketParserHeader_hash(const HashmapKey* hkey)
 {
+    const struct PacketParser_Header* hdr = hkey->key;
     bool cmpIp = isSrcSmaller(hdr);
     if (cmpIp){
         struct PacketParser_Header hashHead = {
@@ -84,14 +86,16 @@ static uint32_t PacketParserHeader_hash(const struct PacketParser_Header* hdr)
     }
 }
 
-static int PacketParserHeader_compare(const struct PacketParser_Header* a,
-                                           const struct PacketParser_Header* b)
+static inline int PacketParserHeader_compare(const HashmapKey* hkeya,
+                                           const HashmapKey* hkeyb)
 {
-    uint32_t hash_a = PacketParserHeader_hash(a);
-    uint32_t hash_b = PacketParserHeader_hash(b);
+    //const struct PacketParser_Header* a = hkeya->key;
+    //const struct PacketParser_Header* b = hkeyb->key;
+    uint32_t hash_a = PacketParserHeader_hash(hkeya);
+    uint32_t hash_b = PacketParserHeader_hash(hkeyb);
     return (long)hash_a - (long)hash_b;
 }
-
+/*
 // ---------------- Map ----------------
 #define Map_NAME SessionStates
 #define Map_ENABLE_HANDLES
@@ -110,12 +114,12 @@ static inline int Map_SessionStates_compare(struct PacketParser_Header** keyA,
     return PacketParserHeader_compare(*keyA, *keyB);
 }
 // ---------------- EndMap ----------------
-
+*/
 void SessionState_printHeader(int version, struct PacketParser_Header* hdr,
                                        struct Log* log, bool in);
 
 
 int SessionState_getSessionState(struct PacketParser_Header* hdr, bool isIn,
-                    struct Map_SessionStates* map, struct Allocator* alloc, struct Log* log);
+                    struct Hashmap_hash* map, struct Allocator* alloc, struct Log* log);
 
 #endif
