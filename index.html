<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>IChrisKing</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="IChrisKing">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="IChrisKing">
<meta property="og:locale" content="zh-Hant-TW">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="IChrisKing">
  
    <link rel="alternate" href="/atom.xml" title="IChrisKing" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">IChrisKing</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">#IMNOTCHRISLEE</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-cjnds-asymmetric-cryptography" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/29/cjnds-asymmetric-cryptography/" class="article-date">
  <time datetime="2018-01-29T08:25:40.000Z" itemprop="datePublished">2018-01-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/cjdns/">cjdns</a>►<a class="article-category-link" href="/categories/cjdns/cjdns源码分析/">cjdns源码分析</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/29/cjnds-asymmetric-cryptography/">握手过程中，非对称密钥的应用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在cjdns中，使用到了两组非对称密钥对。</p>
<ul>
<li>一组稳定的公私钥，主要用于握手阶段的身份验证等操作。<br>  这一组密钥也就是我们在conf中所配置的privateKey和publicKey。同时，publicKey也会出现在那些将我们设置为接入点的节点的conf文件中，作为connectTo中的publicKey字段。</li>
<li>一组临时的公私钥，用于握手完成后，正式通讯时加密数据。<br>  每一次会话都会生成临时的公私钥，这对公私钥才是真正用于加密数据的。</li>
</ul>
<p>本文主要分析，在cjdns源码中，是如何使用稳定的公私钥进行身份验证的，又是如何在节点握手过程中完成临时公私钥生成，和临时公钥交换的。<br>文章将从普通节点向接入点连接开始分析，遵循节点之间建立连接的过程，逐步分析两对非对称密钥在连接建立过程当中的产生和作用。</p>
<h2 id="普通点和接入点"><a href="#普通点和接入点" class="headerlink" title="普通点和接入点"></a>普通点和接入点</h2><p>当我们要和接入点建立连接时，我们是知道接入点的publicKey的。这个值会和password一起写在conf文件中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&quot;connectTo&quot;:&#123;</div><div class="line">                    &quot;xx.xxx.xx.xxx:30199&quot;: &#123;</div><div class="line">                        &quot;password&quot;: &quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;,</div><div class="line">                        &quot;publicKey&quot;:&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.k&quot;</div><div class="line">                    &#125;</div><div class="line">				&#125;</div></pre></td></tr></table></figure></p>
<h3 id="发出第一个包：普通点向接入点发起连接"><a href="#发出第一个包：普通点向接入点发起连接" class="headerlink" title="发出第一个包：普通点向接入点发起连接"></a>发出第一个包：普通点向接入点发起连接</h3><p>本文不会分析配置从conf文件中读出的过程，直接进入到InterfaceConntroller.c中，有关和接入点建立链接的过程。<br>直接进入InterfaceController_bootstrapPeer方法，只分析相关代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">int InterfaceController_bootstrapPeer(struct InterfaceController* ifc,</div><div class="line">                                      int interfaceNumber,</div><div class="line">                                      uint8_t* herPublicKey,</div><div class="line">                                      const struct Sockaddr* lladdrParm,</div><div class="line">                                      String* password,</div><div class="line">                                      String* login,</div><div class="line">                                      String* user,</div><div class="line">                                      struct Allocator* alloc)</div><div class="line">&#123;</div><div class="line">    ......</div><div class="line">    struct Peer* ep = Allocator_calloc(epAlloc, sizeof(struct Peer), 1);</div><div class="line">    ......</div><div class="line">    ep-&gt;caSession = CryptoAuth_newSession(ic-&gt;ca, epAlloc, herPublicKey, false, &quot;outer&quot;);</div><div class="line">    ......</div><div class="line">	sendPing(ep);</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>先看一下CryptoAuth_newSession方法，在CryptoAuth.c中</p>
<h4 id="CryptoAuth-newSession"><a href="#CryptoAuth-newSession" class="headerlink" title="CryptoAuth_newSession"></a>CryptoAuth_newSession</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">struct CryptoAuth_Session* CryptoAuth_newSession(struct CryptoAuth* ca,</div><div class="line">                                                 struct Allocator* alloc,</div><div class="line">                                                 const uint8_t herPublicKey[32],</div><div class="line">                                                 const bool requireAuth,</div><div class="line">                                                 char* displayName)</div><div class="line">&#123;</div><div class="line">    ......</div><div class="line">    struct CryptoAuth_Session_pvt* session =</div><div class="line">        Allocator_calloc(alloc, sizeof(struct CryptoAuth_Session_pvt), 1);</div><div class="line">    ......</div><div class="line">    Assert_true(herPublicKey);</div><div class="line">    Bits_memcpy(session-&gt;pub.herPublicKey, herPublicKey, 32);</div><div class="line">    uint8_t calculatedIp6[16];</div><div class="line">    AddressCalc_addressForPublicKey(calculatedIp6, herPublicKey);</div><div class="line">    Bits_memcpy(session-&gt;pub.herIp6, calculatedIp6, 16);</div><div class="line"></div><div class="line">    return &amp;session-&gt;pub;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>只分析和公私钥对有关的部分。<br>主要操作是将conf中，接入点的publicKey，通过CryptoAuth_newSession方法，设置到代表接入点的ep的caSession的pub.herPublicKey,并且计算出对应的ip6，设置到session-&gt;pub.herIp6中。</p>
<h4 id="sendPing"><a href="#sendPing" class="headerlink" title="sendPing"></a>sendPing</h4><p>sendPing的具体调用流程不在这里详细分析，只截取和公私钥有关的部分。<br>在sendPing的过程中，会经历两次加密。事实上，每次发包过程，都会经历两次加密。</p>
<ol>
<li>首先是针对目标节点的加密，使用自己和目标节点之间的公私钥对进行加密。调用点在SessionManager.c中的readyToSend中,<code>Assert_true(!CryptoAuth_encrypt(sess-&gt;pub.caSession, msg));</code>.</li>
<li>然后是针对peer节点的加密，使用自己和peer节点之间的公私钥对进行加密。调用点在InterfaceController.c的sendFromSwitch中,<code>Assert_true(!CryptoAuth_encrypt(ep-&gt;caSession, msg));</code>。</li>
</ol>
<p>这两次加密调用的都是同一个加密函数，但是传入的第一个参数不同。第一次调用时，会传入目标点的caSession。第二次调用时，会传入peer的caSession。<br>在连接接入点的过程中，两次加密都使用了自己和接入点之间的公私钥对，但两个caSession是不同的。</p>
<h4 id="CryptoAuth-encrypt"><a href="#CryptoAuth-encrypt" class="headerlink" title="CryptoAuth_encrypt"></a>CryptoAuth_encrypt</h4><p>直接看一下加密函数，CryptoAuth.c中的CryptoAuth_encrypt。两次加密使用的都是这个函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">    struct CryptoAuth_Session_pvt* session =</div><div class="line">        Identity_check((struct CryptoAuth_Session_pvt*) sessionPub);</div><div class="line"></div><div class="line">    ......</div><div class="line"></div><div class="line">    if (session-&gt;nextNonce &lt;= CryptoAuth_State_RECEIVED_KEY) &#123;</div><div class="line">        if (session-&gt;nextNonce &lt; CryptoAuth_State_RECEIVED_KEY) &#123;</div><div class="line">            encryptHandshake(msg, session, 0);</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">        ......</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ......</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这是我们和接入点之间的第一个包，两个caSession的session-&gt;nextNonce = CryptoAuth_State_INIT = 0.所以，无论是第一次加密还是第二次加密，都会进入到encryptHandshake中</p>
<h4 id="encryptHandshake"><a href="#encryptHandshake" class="headerlink" title="encryptHandshake"></a>encryptHandshake</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">static void encryptHandshake(struct Message* message,</div><div class="line">                             struct CryptoAuth_Session_pvt* session,</div><div class="line">                             int setupMessage)</div><div class="line">&#123;</div><div class="line">	......</div><div class="line">    struct CryptoHeader* header = (struct CryptoHeader*) message-&gt;bytes;</div><div class="line">    ......</div><div class="line"></div><div class="line">    // set the permanent key</div><div class="line">    Bits_memcpy(header-&gt;publicKey, session-&gt;context-&gt;pub.publicKey, 32);</div><div class="line"></div><div class="line">    ......</div><div class="line">    // Set the session state</div><div class="line">    header-&gt;nonce = Endian_hostToBigEndian32(session-&gt;nextNonce);</div><div class="line"></div><div class="line">    if (session-&gt;nextNonce == CryptoAuth_State_INIT ||</div><div class="line">        session-&gt;nextNonce == CryptoAuth_State_RECEIVED_HELLO)</div><div class="line">    &#123;</div><div class="line">        // If we&apos;re sending a hello or a key</div><div class="line">        // Here we make up a temp keypair</div><div class="line">        Random_bytes(session-&gt;context-&gt;rand, session-&gt;ourTempPrivKey, 32);</div><div class="line">        crypto_scalarmult_curve25519_base(session-&gt;ourTempPubKey, session-&gt;ourTempPrivKey);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Bits_memcpy(header-&gt;encryptedTempKey, session-&gt;ourTempPubKey, 32);</div><div class="line"></div><div class="line">    ......</div><div class="line"></div><div class="line">    uint8_t sharedSecret[32];</div><div class="line">    if (session-&gt;nextNonce &lt; CryptoAuth_State_RECEIVED_HELLO) &#123;</div><div class="line">        getSharedSecret(sharedSecret,</div><div class="line">                        session-&gt;context-&gt;privateKey,</div><div class="line">                        session-&gt;pub.herPublicKey,</div><div class="line">                        passwordHash,</div><div class="line">                        session-&gt;context-&gt;logger);</div><div class="line"></div><div class="line">        session-&gt;isInitiator = true;</div><div class="line"></div><div class="line">        Assert_true(session-&gt;nextNonce &lt;= CryptoAuth_State_SENT_HELLO);</div><div class="line">        session-&gt;nextNonce = CryptoAuth_State_SENT_HELLO;</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line"></div><div class="line">    encryptRndNonce(header-&gt;handshakeNonce, message, sharedSecret);</div><div class="line"></div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>主要做了一下几个操作：</p>
<h5 id="1-把自己的稳定的publicKey放入握手message中"><a href="#1-把自己的稳定的publicKey放入握手message中" class="headerlink" title="1. 把自己的稳定的publicKey放入握手message中"></a>1. 把自己的稳定的publicKey放入握手message中</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">......</div><div class="line">   struct CryptoHeader* header = (struct CryptoHeader*) message-&gt;bytes;</div><div class="line">   ......</div><div class="line"></div><div class="line">   // set the permanent key</div><div class="line">   Bits_memcpy(header-&gt;publicKey, session-&gt;context-&gt;pub.publicKey, 32);</div></pre></td></tr></table></figure>
<h5 id="2-把自己的nextNonce放入握手message中的nonce字段"><a href="#2-把自己的nextNonce放入握手message中的nonce字段" class="headerlink" title="2. 把自己的nextNonce放入握手message中的nonce字段"></a>2. 把自己的nextNonce放入握手message中的nonce字段</h5><p>此时的session-&gt;nextNonce为CryptoAuth_State_INIT，也就是0<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// Set the session state</div><div class="line">header-&gt;nonce = Endian_hostToBigEndian32(session-&gt;nextNonce);</div></pre></td></tr></table></figure></p>
<h5 id="3-生成握手过程中使用的临时公私钥对，并将临时公钥放入握手message中"><a href="#3-生成握手过程中使用的临时公私钥对，并将临时公钥放入握手message中" class="headerlink" title="3. 生成握手过程中使用的临时公私钥对，并将临时公钥放入握手message中"></a>3. 生成握手过程中使用的临时公私钥对，并将临时公钥放入握手message中</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">if (session-&gt;nextNonce == CryptoAuth_State_INIT ||</div><div class="line">    session-&gt;nextNonce == CryptoAuth_State_RECEIVED_HELLO)</div><div class="line">&#123;</div><div class="line">    // If we&apos;re sending a hello or a key</div><div class="line">    // Here we make up a temp keypair</div><div class="line">    Random_bytes(session-&gt;context-&gt;rand, session-&gt;ourTempPrivKey, 32);</div><div class="line">    crypto_scalarmult_curve25519_base(session-&gt;ourTempPubKey, session-&gt;ourTempPrivKey);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Bits_memcpy(header-&gt;encryptedTempKey, session-&gt;ourTempPubKey, 32);</div></pre></td></tr></table></figure>
<h5 id="4-生成握手过程中使用的加密密钥sharedSecret，修改nextNonce为SENT-HELLO-1"><a href="#4-生成握手过程中使用的加密密钥sharedSecret，修改nextNonce为SENT-HELLO-1" class="headerlink" title="4. 生成握手过程中使用的加密密钥sharedSecret，修改nextNonce为SENT_HELLO = 1"></a>4. 生成握手过程中使用的加密密钥sharedSecret，修改nextNonce为SENT_HELLO = 1</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">uint8_t sharedSecret[32];</div><div class="line">    if (session-&gt;nextNonce &lt; CryptoAuth_State_RECEIVED_HELLO) &#123;</div><div class="line">        getSharedSecret(sharedSecret,</div><div class="line">                        session-&gt;context-&gt;privateKey,</div><div class="line">                        session-&gt;pub.herPublicKey,</div><div class="line">                        passwordHash,</div><div class="line">                        session-&gt;context-&gt;logger);</div><div class="line"></div><div class="line">        session-&gt;isInitiator = true;</div><div class="line"></div><div class="line">        Assert_true(session-&gt;nextNonce &lt;= CryptoAuth_State_SENT_HELLO);</div><div class="line">        session-&gt;nextNonce = CryptoAuth_State_SENT_HELLO;</div><div class="line">    &#125; else &#123;</div><div class="line">        ......</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>注意看这里的getSharedSecret的参数，是自己的稳定私钥session-&gt;context-&gt;privateKey，对方的稳定公钥session-&gt;pub.herPublicKey,passwordHash。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">static inline void getSharedSecret(uint8_t outputSecret[32],</div><div class="line">                                   uint8_t myPrivateKey[32],</div><div class="line">                                   uint8_t herPublicKey[32],</div><div class="line">                                   uint8_t passwordHash[32],</div><div class="line">                                   struct Log* logger)</div><div class="line">&#123;</div><div class="line">    if (passwordHash == NULL) &#123;</div><div class="line">        crypto_box_curve25519xsalsa20poly1305_beforenm(outputSecret, herPublicKey, myPrivateKey);</div><div class="line">    &#125; else &#123;</div><div class="line">        union &#123;</div><div class="line">            struct &#123;</div><div class="line">                uint8_t key[32];</div><div class="line">                uint8_t passwd[32];</div><div class="line">            &#125; components;</div><div class="line">            uint8_t bytes[64];</div><div class="line">        &#125; buff;</div><div class="line"></div><div class="line">        crypto_scalarmult_curve25519(buff.components.key, myPrivateKey, herPublicKey);</div><div class="line">        Bits_memcpy(buff.components.passwd, passwordHash, 32);</div><div class="line">        crypto_hash_sha256(outputSecret, buff.bytes, 64);</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>根据passwordHash是否存在，也就是conf中是否有password字段，分为两种不同的方法来计算outputSecret。具体计算方法不需要分析。只需要知道，根据非对称加密的原理，在正确的成对使用双方的公私钥对，且password相同的情况下，一方加密的内容是一定会被对方解密的。在本次收发包中，使用的是双方的稳定公私钥对，只要接收方在解密握手包时，也使用双方的稳定公私钥对，message一定会被正确的解开。</p>
<h5 id="5-使用sharedSecret加密握手message"><a href="#5-使用sharedSecret加密握手message" class="headerlink" title="5. 使用sharedSecret加密握手message"></a>5. 使用sharedSecret加密握手message</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">encryptRndNonce(header-&gt;handshakeNonce, message, sharedSecret);</div></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在普通点向接入点发出第一个包后，普通点上会建立一个接入点作为peer的caSession，和一个接入点作为目标点的caSession。</p>
<ol>
<li><p>对于第一个caSession，他是代表邻居节点的struct Peer* ep的成员。这个ep会加入到ici-&gt;peerMap中，map名为EndpointsBySockaddr。所有对于它的维护都在InterfaceController.c中进行，代表的是对于邻居节点的状态维护。当第一个包发送完成后，这个caSessio中包括</p>
<ul>
<li>邻居节点的稳定公钥herPublicKey</li>
<li>自己的稳定公钥publicKey</li>
<li>自己的稳定私钥privateKey</li>
<li>自己的临时公钥ourTempPubKey</li>
<li>自己的临时私钥ourTempPrivKey、</li>
<li>密钥sharedSecret</li>
<li><p>nextNonce值为CryptoAuth_State_SENT_HELLO = 1。</p>
<p>计算sharedSecret使用到</p>
</li>
<li>自己的稳定私钥privateKey</li>
<li><p>邻居节点的稳定公钥herTempPubKey</p>
<p>在发出去的握手包中包括</p>
</li>
<li>值为CryptoAuth_State_INIT = 0的nonce字段</li>
<li>自己的稳定公钥publicKey</li>
<li>自己的临时公钥ourTempPubKey</li>
<li>使用sharedSecret加密过的message内容</li>
</ul>
</li>
<li><p>对于第二个caSession，他是代表与其他节点的会话的struct SessionManager_Session_pvt* sess的成员。这个sess会加入到sm-&gt;ifaceMap中，map名为OfSessionsByIp6。所有对于它的维护都在SessionManager.c中进行，代表的是对于与其他节点的会话的状态维护。当第一个包发送完成后，这个caSessio中包括</p>
<ul>
<li>目标节点的稳定公钥herPublicKey</li>
<li>自己的稳定公钥publicKey</li>
<li>自己的稳定私钥privateKey</li>
<li>自己的临时公钥ourTempPubKey</li>
<li>自己的临时私钥ourTempPrivKey</li>
<li>密钥sharedSecret</li>
<li><p>nextNonce值为CryptoAuth_State_SENT_HELLO = 1</p>
<p>计算sharedSecret使用到</p>
</li>
<li>自己的稳定私钥privateKey</li>
<li><p>目标节点的临时公钥herTempPubKey</p>
<p>在发出去的握手包中包括</p>
</li>
<li>值为CryptoAuth_State_INIT = 0的nonce字段</li>
<li>自己的稳定公钥publicKey</li>
<li>自己的临时公钥ourTempPubKey</li>
<li>使用sharedSecret加密过的message内容</li>
</ul>
</li>
</ol>
<h3 id="收到第一个包：接入点对握手包的解析处理"><a href="#收到第一个包：接入点对握手包的解析处理" class="headerlink" title="收到第一个包：接入点对握手包的解析处理"></a>收到第一个包：接入点对握手包的解析处理</h3><p>当接入点收到握手包后，会对这个包进行解密。解密过程同样有两次解密操作。</p>
<ol>
<li><p>首先解密针对peer节点的加密，使用自己和peer节点之间的公私钥对进行解密。调用点在InterfaceController.c中,有两处：</p>
<ul>
<li>handleIncomingFromWire函数中<code>if (CryptoAuth_decrypt(ep-&gt;caSession, msg))</code></li>
<li>handleUnexpectedIncoming函数中<code>if (CryptoAuth_decrypt(ep-&gt;caSession, msg))</code>。<br>这两处调用都在收到数据包后的处理逻辑线上，根据不同情况，调用到其中的一个。</li>
</ul>
</li>
<li><p>然后解密针对目标节点的加密，使用自己和目标节点之间的公私钥对进行解密。调用点在SessionManager.c中的incomingFromSwitchIf中,<code>enum CryptoAuth_DecryptErr ret = CryptoAuth_decrypt(session-&gt;pub.caSession, msg);</code>.<br>这三个解密调用的都是同一个解密函数，但是传入的第一个参数不同。第一次调用时，会传入peer节点的caSession。第二次调用时，会传入目标节点的caSession。<br>在接入点处理握手包的过程中，两次解密都使用了向他连接的普通点和它之间的公私钥对，但两个caSession是不同的。</p>
</li>
</ol>
<p>根据收到包后的处理逻辑，这个包首先会进入到InterfaceController.c的handleUnexpectedIncoming函数中</p>
<h4 id="handleIncomingFromWire"><a href="#handleIncomingFromWire" class="headerlink" title="handleIncomingFromWire"></a>handleIncomingFromWire</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">static Iface_DEFUN handleIncomingFromWire(struct Message* msg, struct Iface* addrIf)</div><div class="line">&#123;</div><div class="line">    ......</div><div class="line">    int epIndex = Map_EndpointsBySockaddr_indexForKey(&amp;lladdr, &amp;ici-&gt;peerMap);</div><div class="line">    if (epIndex == -1) &#123;</div><div class="line">        return handleUnexpectedIncoming(msg, ici);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    struct Peer* ep = Identity_check((struct Peer*) ici-&gt;peerMap.values[epIndex]);</div><div class="line">    ......</div><div class="line">    if (CryptoAuth_decrypt(ep-&gt;caSession, msg)) &#123;</div><div class="line">        return NULL;</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">    return receivedPostCryptoAuth(msg, ep, ici-&gt;ic);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先试图在ici-&gt;peerMap中查找是否有这个点。<br>接下来针对查找结果有一个判断逻辑，</p>
<pre><code>* 如果没有记录，进入handleUnexpectedIncoming；
* 如果有，取出对应的Peer,并调用CryptoAuth_decrypt。最后调用receivedPostCryptoAuth。
</code></pre><p>因为这是接入点收到普通点的第一个包，所以，不会有关于普通点的记录。我们直接进入进入handleUnexpectedIncoming</p>
<h4 id="handleUnexpectedIncoming"><a href="#handleUnexpectedIncoming" class="headerlink" title="handleUnexpectedIncoming"></a>handleUnexpectedIncoming</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">static Iface_DEFUN handleUnexpectedIncoming(struct Message* msg,</div><div class="line">                                            struct InterfaceController_Iface_pvt* ici)</div><div class="line">&#123;</div><div class="line">    ......</div><div class="line">    struct Peer* ep = Allocator_calloc(epAlloc, sizeof(struct Peer), 1);</div><div class="line">    ......</div><div class="line">    ep-&gt;caSession = CryptoAuth_newSession(ic-&gt;ca, epAlloc, ch-&gt;publicKey, true, &quot;outer&quot;);</div><div class="line">    if (CryptoAuth_decrypt(ep-&gt;caSession, msg)) &#123;</div><div class="line">        // If the first message is a dud, drop all state for this peer.</div><div class="line">        // probably some random crap that wandered in the socket.</div><div class="line">        Allocator_free(epAlloc);</div><div class="line">        return NULL;</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">    return receivedPostCryptoAuth(msg, ep, ic);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="1-创建Peer，并调用CryptoAuth-newSession"><a href="#1-创建Peer，并调用CryptoAuth-newSession" class="headerlink" title="1. 创建Peer，并调用CryptoAuth_newSession"></a>1. 创建Peer，并调用CryptoAuth_newSession</h5><p>重温一下CryptoAuth_newSession<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">struct CryptoAuth_Session* CryptoAuth_newSession(struct CryptoAuth* ca,</div><div class="line">                                                 struct Allocator* alloc,</div><div class="line">                                                 const uint8_t herPublicKey[32],</div><div class="line">                                                 const bool requireAuth,</div><div class="line">                                                 char* displayName)</div><div class="line">&#123;</div><div class="line">    .......</div><div class="line">    Assert_true(herPublicKey);</div><div class="line">    Bits_memcpy(session-&gt;pub.herPublicKey, herPublicKey, 32);</div><div class="line">    uint8_t calculatedIp6[16];</div><div class="line">    AddressCalc_addressForPublicKey(calculatedIp6, herPublicKey);</div><div class="line">    Bits_memcpy(session-&gt;pub.herIp6, calculatedIp6, 16);</div><div class="line"></div><div class="line">    return &amp;session-&gt;pub;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>将收到的包中，普通点的publicKey，通过CryptoAuth_newSession方法，设置到代表普通点的ep的caSession的pub.herPublicKey,并且计算出对应的ip6，设置到session-&gt;pub.herIp6中。</p>
<h5 id="2-调用CryptoAuth-decrypt，解密握手message"><a href="#2-调用CryptoAuth-decrypt，解密握手message" class="headerlink" title="2. 调用CryptoAuth_decrypt，解密握手message"></a>2. 调用CryptoAuth_decrypt，解密握手message</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">enum CryptoAuth_DecryptErr CryptoAuth_decrypt(struct CryptoAuth_Session* sessionPub,</div><div class="line">                                              struct Message* msg)</div><div class="line">&#123;</div><div class="line">    ......</div><div class="line">    if (!session-&gt;established) &#123;</div><div class="line">        if (nonce &gt;= Nonce_FIRST_TRAFFIC_PACKET) &#123;</div><div class="line">            ......</div><div class="line">        &#125;</div><div class="line">        ......</div><div class="line">        return decryptHandshake(session, nonce, msg, header);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="3-调用decryptHandshake"><a href="#3-调用decryptHandshake" class="headerlink" title="3. 调用decryptHandshake"></a>3. 调用decryptHandshake</h5><p>先简单说明下几个变量：</p>
<ul>
<li>nonce:从收到的包里取出，是发包者那边的nextNonce，值为CryptoAuth_State_INIT = 0</li>
<li>nextNonce:一个局部变量，随情况变化，最后会被设置到session-&gt;nextNonce</li>
<li>session-&gt;nextNonce:session中的nextNonce，真正标识这个session的状态,目前为CryptoAuth_State_INIT = 0</li>
</ul>
<p>对照一下Nonce和CryptoAuth_State<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">enum Nonce &#123;</div><div class="line">    Nonce_HELLO = 0,</div><div class="line">    Nonce_REPEAT_HELLO = 1,</div><div class="line">    Nonce_KEY = 2,</div><div class="line">    Nonce_REPEAT_KEY = 3,</div><div class="line">    Nonce_FIRST_TRAFFIC_PACKET = 4</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">enum CryptoAuth_State &#123;</div><div class="line">    // New CryptoAuth session, has not sent or received anything</div><div class="line">    CryptoAuth_State_INIT = 0,</div><div class="line"></div><div class="line">    // Sent a hello message, waiting for reply</div><div class="line">    CryptoAuth_State_SENT_HELLO = 1,</div><div class="line"></div><div class="line">    // Received a hello message, have not yet sent a reply</div><div class="line">    CryptoAuth_State_RECEIVED_HELLO = 2,</div><div class="line"></div><div class="line">    // Received a hello message, sent a key message, waiting for the session to complete</div><div class="line">    CryptoAuth_State_SENT_KEY = 3,</div><div class="line"></div><div class="line">    // Sent a hello message, received a key message, may or may not have sent some data traffic</div><div class="line">    // but no data traffic has yet been received</div><div class="line">    CryptoAuth_State_RECEIVED_KEY = 4,</div><div class="line"></div><div class="line">    // Received data traffic, session is in run state</div><div class="line">    CryptoAuth_State_ESTABLISHED = 100</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">static enum CryptoAuth_DecryptErr decryptHandshake(struct CryptoAuth_Session_pvt* session,</div><div class="line">                                                   const uint32_t nonce,</div><div class="line">                                                   struct Message* message,</div><div class="line">                                                   struct CryptoHeader* header)</div><div class="line">&#123;</div><div class="line">    ......</div><div class="line">    if (nonce &lt; Nonce_KEY) &#123; // HELLO or REPEAT_HELLO</div><div class="line">        ......</div><div class="line">        getSharedSecret(sharedSecret,</div><div class="line">                        session-&gt;context-&gt;privateKey,</div><div class="line">                        session-&gt;pub.herPublicKey,</div><div class="line">                        passwordHash,</div><div class="line">                        session-&gt;context-&gt;logger);</div><div class="line">        nextNonce = CryptoAuth_State_RECEIVED_HELLO;</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">    // Decrypt her temp public key and the message.</div><div class="line">    if (decryptRndNonce(header-&gt;handshakeNonce, message, sharedSecret)) &#123;</div><div class="line">        // just in case</div><div class="line">        Bits_memset(header, 0, CryptoHeader_SIZE);</div><div class="line">        cryptoAuthDebug(session, &quot;DROP message with nonce [%d], decryption failed&quot;, nonce);</div><div class="line">        return CryptoAuth_DecryptErr_HANDSHAKE_DECRYPT_FAILED;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (Bits_isZero(header-&gt;encryptedTempKey, 32)) &#123;</div><div class="line">        // we need to reject 0 public keys outright because they will be confused with &quot;unknown&quot;</div><div class="line">        cryptoAuthDebug0(session, &quot;DROP message with zero as temp public key&quot;);</div><div class="line">        return CryptoAuth_DecryptErr_WISEGUY;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Post-decryption checking</div><div class="line">    if (nonce == Nonce_HELLO) &#123;</div><div class="line">        // A new hello packet</div><div class="line">        if (!Bits_memcmp(session-&gt;herTempPubKey, header-&gt;encryptedTempKey, 32)) &#123;</div><div class="line">            // possible replay attack or duped packet</div><div class="line">            cryptoAuthDebug0(session, &quot;DROP dupe hello packet with same temp key&quot;);</div><div class="line">            return CryptoAuth_DecryptErr_INVALID_PACKET;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line"></div><div class="line">    if (nextNonce == CryptoAuth_State_RECEIVED_KEY) &#123;</div><div class="line">       ......</div><div class="line">    &#125; else if (nextNonce == CryptoAuth_State_RECEIVED_HELLO) &#123;</div><div class="line">        Assert_true(nonce == Nonce_HELLO || nonce == Nonce_REPEAT_HELLO);</div><div class="line">        if (Bits_memcmp(session-&gt;herTempPubKey, header-&gt;encryptedTempKey, 32)) &#123;</div><div class="line">            // fresh new hello packet, we should reset the session.</div><div class="line">            switch (session-&gt;nextNonce) &#123;</div><div class="line">                case CryptoAuth_State_SENT_HELLO: &#123;</div><div class="line">                   	......</div><div class="line">                &#125;</div><div class="line">                case CryptoAuth_State_INIT: &#123;</div><div class="line">                    Bits_memcpy(session-&gt;herTempPubKey, header-&gt;encryptedTempKey, 32);</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">                default: &#123;</div><div class="line">                    ......</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">        	......</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        ......</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">    session-&gt;nextNonce = nextNonce;</div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数主要做了一下操作：</p>
<h6 id="3-1-计算SharedSecret"><a href="#3-1-计算SharedSecret" class="headerlink" title="3.1. 计算SharedSecret"></a>3.1. 计算SharedSecret</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">getSharedSecret(sharedSecret,</div><div class="line">                session-&gt;context-&gt;privateKey,</div><div class="line">                session-&gt;pub.herPublicKey,</div><div class="line">                passwordHash,</div><div class="line">                session-&gt;context-&gt;logger);</div><div class="line">nextNonce = CryptoAuth_State_RECEIVED_HELLO;</div></pre></td></tr></table></figure>
<p>关于这个函数的具体实现，在加密部分已经分析过，得出结论，因为双方使用的都是稳定的公私钥对，所以，计算出的SharedSecret是可以解密握手包的。</p>
<h6 id="3-2-解密message和一些字段的合法性检查"><a href="#3-2-解密message和一些字段的合法性检查" class="headerlink" title="3.2. 解密message和一些字段的合法性检查"></a>3.2. 解密message和一些字段的合法性检查</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">// Decrypt her temp public key and the message.</div><div class="line">if (decryptRndNonce(header-&gt;handshakeNonce, message, sharedSecret)) &#123;</div><div class="line">    // just in case</div><div class="line">    Bits_memset(header, 0, CryptoHeader_SIZE);</div><div class="line">    cryptoAuthDebug(session, &quot;DROP message with nonce [%d], decryption failed&quot;, nonce);</div><div class="line">    return CryptoAuth_DecryptErr_HANDSHAKE_DECRYPT_FAILED;</div><div class="line">&#125;</div><div class="line"></div><div class="line">if (Bits_isZero(header-&gt;encryptedTempKey, 32)) &#123;</div><div class="line">    // we need to reject 0 public keys outright because they will be confused with &quot;unknown&quot;</div><div class="line">    cryptoAuthDebug0(session, &quot;DROP message with zero as temp public key&quot;);</div><div class="line">    return CryptoAuth_DecryptErr_WISEGUY;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Post-decryption checking</div><div class="line">if (nonce == Nonce_HELLO) &#123;</div><div class="line">    // A new hello packet</div><div class="line">    if (!Bits_memcmp(session-&gt;herTempPubKey, header-&gt;encryptedTempKey, 32)) &#123;</div><div class="line">        // possible replay attack or duped packet</div><div class="line">        cryptoAuthDebug0(session, &quot;DROP dupe hello packet with same temp key&quot;);</div><div class="line">        return CryptoAuth_DecryptErr_INVALID_PACKET;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不做具体分析</p>
<h6 id="3-3-将message中对方的临时公钥保存到herTempPubKey中"><a href="#3-3-将message中对方的临时公钥保存到herTempPubKey中" class="headerlink" title="3.3. 将message中对方的临时公钥保存到herTempPubKey中"></a>3.3. 将message中对方的临时公钥保存到herTempPubKey中</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">case CryptoAuth_State_INIT: &#123;</div><div class="line">    Bits_memcpy(session-&gt;herTempPubKey, header-&gt;encryptedTempKey, 32);</div><div class="line">    break;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h6 id="3-4-设置session-gt-nextNonce"><a href="#3-4-设置session-gt-nextNonce" class="headerlink" title="3.4 设置session-&gt;nextNonce"></a>3.4 设置session-&gt;nextNonce</h6><p>设为CryptoAuth_State_RECEIVED_HELLO = 2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">session-&gt;nextNonce = nextNonce;</div></pre></td></tr></table></figure></p>
<h5 id="4-调用receivedPostCryptoAuth"><a href="#4-调用receivedPostCryptoAuth" class="headerlink" title="4. 调用receivedPostCryptoAuth"></a>4. 调用receivedPostCryptoAuth</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">static Iface_DEFUN receivedPostCryptoAuth(struct Message* msg,</div><div class="line">                                          struct Peer* ep,</div><div class="line">                                          struct InterfaceController_pvt* ic)</div><div class="line">&#123;</div><div class="line">    ......</div><div class="line">    if (ep-&gt;state &lt; InterfaceController_PeerState_ESTABLISHED) &#123;</div><div class="line">        ......</div><div class="line">        if (caState == CryptoAuth_State_ESTABLISHED) &#123;</div><div class="line">            ......</div><div class="line">        &#125; else &#123;</div><div class="line">            ......</div><div class="line">            if (msg-&gt;length &lt; 8 || msg-&gt;bytes[7] != 1) &#123;</div><div class="line">                ......</div><div class="line">            &#125; else &#123;</div><div class="line">                ......</div><div class="line">                if ((ep-&gt;pingCount + 1) % 7) &#123;</div><div class="line">                    sendPing(ep);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">    return Iface_next(&amp;ep-&gt;switchIf, msg);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h6 id="4-1-sendPing"><a href="#4-1-sendPing" class="headerlink" title="4.1 sendPing"></a>4.1 sendPing</h6><p>这是针对收到握手包之后发回的回应包，具体操作放在后面分析。</p>
<h6 id="4-2-Iface-next-amp-ep-gt-switchIf-msg"><a href="#4-2-Iface-next-amp-ep-gt-switchIf-msg" class="headerlink" title="4.2 Iface_next(&amp;ep-&gt;switchIf, msg)"></a>4.2 Iface_next(&amp;ep-&gt;switchIf, msg)</h6><p>代码执行到这里，接入点作为peer的解密已经完成了。接下来将会去寻找这个包的下一跳，而这个包的目标节点也是接入点，所以这个包最终会交给SessionManager来处理。由incomingFromSwitchIf函数来解密，并维护caSession状态，很相似，不再具体分析了。</p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>当接入点收到普通点发出第一个包后，接入点上会建立一个普通点点作为peer的caSession，和一个普通点作为目标点的caSession。</p>
<ol>
<li><p>对于第一个caSession，他是代表邻居节点的struct Peer* ep的成员。这个ep会加入到ici-&gt;peerMap中，map名为EndpointsBySockaddr。所有对于它的维护都在InterfaceController.c中进行，代表的是对于邻居节点的状态维护。当这个包接收过程完成后，这个caSessio中包括</p>
<ul>
<li>邻居节点的稳定公钥herPublicKey</li>
<li>邻居节点的临时公钥herTempPubKey</li>
<li>自己的稳定公钥publicKey</li>
<li>自己的稳定私钥privateKey</li>
<li><p>nextNonce值为CryptoAuth_State_RECEIVED_HELLO = 2</p>
<p>计算sharedSecret使用到</p>
</li>
<li>自己的稳定私钥privateKey</li>
<li>邻居节点的临时公钥herTempPubKey</li>
</ul>
</li>
<li><p>对于第二个caSession，他是代表与其他节点的会话的struct SessionManager_Session_pvt* sess的成员。这个sess会加入到sm-&gt;ifaceMap中，map名为OfSessionsByIp6。所有对于它的维护都在SessionManager.c中进行，代表的是对于与其他节点的会话的状态维护。当第一个包的接收过程处理完成后，这个caSessio中包括</p>
<ul>
<li>目标节点的稳定公钥herPublicKey</li>
<li>目标节点的临时公钥herTempPublicKey</li>
<li>自己的稳定公钥publicKey</li>
<li>自己的稳定私钥privateKey</li>
<li><p>nextNonce值为CryptoAuth_State_RECEIVED_HELLO = 2</p>
<p>计算sharedSecret使用到</p>
</li>
<li>自己的稳定私钥privateKey</li>
<li>目标节点的临时公钥herTempPubKey</li>
</ul>
</li>
</ol>
<h3 id="发出第二个包：接入点的回包"><a href="#发出第二个包：接入点的回包" class="headerlink" title="发出第二个包：接入点的回包"></a>发出第二个包：接入点的回包</h3><p>接入点的回包操作，就是上面的sendPing。依然不详细分析具体调用流程，只关注对于加密部分的函数的调用，直接进入到CryptoAuth_encrypt方法。</p>
<h4 id="CryptoAuth-encrypt-1"><a href="#CryptoAuth-encrypt-1" class="headerlink" title="CryptoAuth_encrypt"></a>CryptoAuth_encrypt</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">int CryptoAuth_encrypt(struct CryptoAuth_Session* sessionPub, struct Message* msg)</div><div class="line">&#123;</div><div class="line">    ......</div><div class="line">    if (session-&gt;nextNonce &lt;= CryptoAuth_State_RECEIVED_KEY) &#123;</div><div class="line">        if (session-&gt;nextNonce &lt; CryptoAuth_State_RECEIVED_KEY) &#123;</div><div class="line">            encryptHandshake(msg, session, 0);</div><div class="line">            return 0;</div><div class="line">        &#125; else &#123;</div><div class="line">            ......</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="encryptHandshake-1"><a href="#encryptHandshake-1" class="headerlink" title="encryptHandshake"></a>encryptHandshake</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">static void encryptHandshake(struct Message* message,</div><div class="line">                             struct CryptoAuth_Session_pvt* session,</div><div class="line">                             int setupMessage)</div><div class="line">&#123;</div><div class="line">    ......</div><div class="line">    // set the permanent key</div><div class="line">    Bits_memcpy(header-&gt;publicKey, session-&gt;context-&gt;pub.publicKey, 32);</div><div class="line"></div><div class="line">    // Set the session state</div><div class="line">    header-&gt;nonce = Endian_hostToBigEndian32(session-&gt;nextNonce);</div><div class="line"></div><div class="line">    if (session-&gt;nextNonce == CryptoAuth_State_INIT ||</div><div class="line">        session-&gt;nextNonce == CryptoAuth_State_RECEIVED_HELLO)</div><div class="line">    &#123;</div><div class="line">        // If we&apos;re sending a hello or a key</div><div class="line">        // Here we make up a temp keypair</div><div class="line">        Random_bytes(session-&gt;context-&gt;rand, session-&gt;ourTempPrivKey, 32);</div><div class="line">        crypto_scalarmult_curve25519_base(session-&gt;ourTempPubKey, session-&gt;ourTempPrivKey);</div><div class="line">		......</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Bits_memcpy(header-&gt;encryptedTempKey, session-&gt;ourTempPubKey, 32);</div><div class="line">    ......</div><div class="line">    uint8_t sharedSecret[32];</div><div class="line">    if (session-&gt;nextNonce &lt; CryptoAuth_State_RECEIVED_HELLO) &#123;</div><div class="line">        ......</div><div class="line">    &#125; else &#123;</div><div class="line">        // Handshake2</div><div class="line">        // herTempPubKey was set by decryptHandshake()</div><div class="line">        Assert_ifParanoid(!Bits_isZero(session-&gt;herTempPubKey, 32));</div><div class="line">        getSharedSecret(sharedSecret,</div><div class="line">                        session-&gt;context-&gt;privateKey,</div><div class="line">                        session-&gt;herTempPubKey,</div><div class="line">                        passwordHash,</div><div class="line">                        session-&gt;context-&gt;logger);</div><div class="line"></div><div class="line">        Assert_true(session-&gt;nextNonce &lt;= CryptoAuth_State_SENT_KEY);</div><div class="line">        session-&gt;nextNonce = CryptoAuth_State_SENT_KEY;</div><div class="line">        ......</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ......</div><div class="line">    encryptRndNonce(header-&gt;handshakeNonce, message, sharedSecret);</div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数的主要操作：</p>
<h5 id="1-将自己的稳定公钥放到message中"><a href="#1-将自己的稳定公钥放到message中" class="headerlink" title="1. 将自己的稳定公钥放到message中"></a>1. 将自己的稳定公钥放到message中</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// set the permanent key</div><div class="line">   Bits_memcpy(header-&gt;publicKey, session-&gt;context-&gt;pub.publicKey, 32);</div></pre></td></tr></table></figure>
<h5 id="2-将自己的nextNonce放到message中"><a href="#2-将自己的nextNonce放到message中" class="headerlink" title="2. 将自己的nextNonce放到message中"></a>2. 将自己的nextNonce放到message中</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// Set the session state</div><div class="line">   header-&gt;nonce = Endian_hostToBigEndian32(session-&gt;nextNonce);</div></pre></td></tr></table></figure>
<p>此时，nextNonce值为CryptoAuth_State_RECEIVED_HELLO = 2</p>
<h5 id="3-生成握手过程中使用的临时公私钥对，并将临时公钥放入握手message中-1"><a href="#3-生成握手过程中使用的临时公私钥对，并将临时公钥放入握手message中-1" class="headerlink" title="3. 生成握手过程中使用的临时公私钥对，并将临时公钥放入握手message中"></a>3. 生成握手过程中使用的临时公私钥对，并将临时公钥放入握手message中</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">if (session-&gt;nextNonce == CryptoAuth_State_INIT ||</div><div class="line">    session-&gt;nextNonce == CryptoAuth_State_RECEIVED_HELLO)</div><div class="line">&#123;</div><div class="line">    // If we&apos;re sending a hello or a key</div><div class="line">    // Here we make up a temp keypair</div><div class="line">    Random_bytes(session-&gt;context-&gt;rand, session-&gt;ourTempPrivKey, 32);</div><div class="line">    crypto_scalarmult_curve25519_base(session-&gt;ourTempPubKey, session-&gt;ourTempPrivKey);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Bits_memcpy(header-&gt;encryptedTempKey, session-&gt;ourTempPubKey, 32);</div></pre></td></tr></table></figure>
<h5 id="4-生成握手过程中使用的加密密钥sharedSecret，修改nextNonce为SENT-KEY-3"><a href="#4-生成握手过程中使用的加密密钥sharedSecret，修改nextNonce为SENT-KEY-3" class="headerlink" title="4. 生成握手过程中使用的加密密钥sharedSecret，修改nextNonce为SENT_KEY = 3"></a>4. 生成握手过程中使用的加密密钥sharedSecret，修改nextNonce为SENT_KEY = 3</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">if (session-&gt;nextNonce &lt; CryptoAuth_State_RECEIVED_HELLO) &#123;</div><div class="line">        ......</div><div class="line">    &#125; else &#123;</div><div class="line">        // Handshake2</div><div class="line">        // herTempPubKey was set by decryptHandshake()</div><div class="line">        Assert_ifParanoid(!Bits_isZero(session-&gt;herTempPubKey, 32));</div><div class="line">        getSharedSecret(sharedSecret,</div><div class="line">                        session-&gt;context-&gt;privateKey,</div><div class="line">                        session-&gt;herTempPubKey,</div><div class="line">                        passwordHash,</div><div class="line">                        session-&gt;context-&gt;logger);</div><div class="line"></div><div class="line">        Assert_true(session-&gt;nextNonce &lt;= CryptoAuth_State_SENT_KEY);</div><div class="line">        session-&gt;nextNonce = CryptoAuth_State_SENT_KEY;</div><div class="line">        ......</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>要注意，这里getSharedSecret使用的是自己的稳定私钥和对方的临时公钥。我们要关注解密时使用的公私钥对是否匹配。</p>
<h5 id="5-使用sharedSecret加密握手message-1"><a href="#5-使用sharedSecret加密握手message-1" class="headerlink" title="5. 使用sharedSecret加密握手message"></a>5. 使用sharedSecret加密握手message</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">encryptRndNonce(header-&gt;handshakeNonce, message, sharedSecret);</div></pre></td></tr></table></figure>
<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>这是握手过程中的第二个包，由接入点发出。这个包发出后，接入点上关于普通点的两个caSession都发生了变化。</p>
<ol>
<li><p>对于代表邻居节点的caSession，目前的状态如下，其中黑体为本次发包过程中的改变</p>
<ul>
<li>邻居节点的稳定公钥herPublicKey</li>
<li>邻居节点的临时公钥herTempPubKey</li>
<li>自己的稳定公钥publicKey</li>
<li>自己的稳定私钥privateKey</li>
<li><strong>自己的临时公钥ourTempPubKey</strong></li>
<li><strong>自己的临时私钥ourTempPrivKey</strong></li>
<li><strong>密钥sharedSecret</strong></li>
<li><p><strong>nextNonce值为CryptoAuth_State_SENT_KEY = 3</strong></p>
<p>计算sharedSecret使用到</p>
</li>
<li>自己的稳定私钥privateKey</li>
<li><p>邻居节点的临时公钥herTempPubKey</p>
<p>在发出去的握手包中包括</p>
</li>
<li>值为CryptoAuth_State_RECEIVED_HELLO = 2的nonce字段</li>
<li>自己的稳定公钥publicKey</li>
<li>自己的临时公钥ourTempPubKey</li>
<li>使用sharedSecret加密过的message内容</li>
</ul>
</li>
<li><p>对于代表目标节点的caSession，目前的状态如下，其中黑体为本次发包过程中的改变</p>
<ul>
<li>目标节点的稳定公钥herPublicKey</li>
<li>目标节点的临时公钥herTempPubKey</li>
<li>自己的稳定公钥publicKey</li>
<li>自己的稳定私钥privateKey</li>
<li><strong>自己的临时公钥ourTempPubKey</strong></li>
<li><strong>自己的临时私钥ourTempPrivKey</strong></li>
<li><strong>密钥sharedSecret</strong></li>
<li><p><strong>nextNonce值为CryptoAuth_State_SENT_KEY = 3</strong></p>
<p>计算sharedSecret使用到</p>
</li>
<li>自己的稳定私钥privateKey</li>
<li><p>目标节点的临时公钥herTempPubKey</p>
<p>在发出去的握手包中包括</p>
</li>
<li>值为CryptoAuth_State_RECEIVED_HELLO = 2的nonce字段</li>
<li>自己的稳定公钥publicKey</li>
<li>自己的临时公钥ourTempPubKey</li>
<li>使用sharedSecret加密过的message内容</li>
</ul>
</li>
</ol>
<h3 id="收到第二个包：普通点收到接入点的回包"><a href="#收到第二个包：普通点收到接入点的回包" class="headerlink" title="收到第二个包：普通点收到接入点的回包"></a>收到第二个包：普通点收到接入点的回包</h3><p>当普通点收到接入点的回包后，会对这个包进行解密。解密过程同样有两次解密操作。</p>
<ol>
<li><p>首先解密针对peer节点的加密，使用自己和peer节点之间的公私钥对进行解密。调用点在InterfaceController.c中,有两处：</p>
<ul>
<li>handleIncomingFromWire函数中<code>if (CryptoAuth_decrypt(ep-&gt;caSession, msg))</code></li>
<li>handleUnexpectedIncoming函数中<code>if (CryptoAuth_decrypt(ep-&gt;caSession, msg))</code>。<br>这两处调用都在收到数据包后的处理逻辑线上，根据不同情况，调用到其中的一个。</li>
</ul>
</li>
<li><p>然后解密针对目标节点的加密，使用自己和目标节点之间的公私钥对进行解密。调用点在SessionManager.c中的incomingFromSwitchIf中,<code>enum CryptoAuth_DecryptErr ret = CryptoAuth_decrypt(session-&gt;pub.caSession, msg);</code>.<br>这三个解密调用的都是同一个解密函数，但是传入的第一个参数不同。第一次调用时，会传入peer节点的caSession。第二次调用时，会传入目标节点的caSession。<br>在接入点处理握手包的过程中，两次解密都使用了向他连接的普通点和它之间的公私钥对，但两个caSession是不同的。</p>
</li>
</ol>
<p>根据收到包后的处理逻辑，这个包首先会进入到InterfaceController.c的handleUnexpectedIncoming函数中</p>
<h4 id="handleIncomingFromWire-1"><a href="#handleIncomingFromWire-1" class="headerlink" title="handleIncomingFromWire"></a>handleIncomingFromWire</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">static Iface_DEFUN handleIncomingFromWire(struct Message* msg, struct Iface* addrIf)</div><div class="line">&#123;</div><div class="line">    ......</div><div class="line">    int epIndex = Map_EndpointsBySockaddr_indexForKey(&amp;lladdr, &amp;ici-&gt;peerMap);</div><div class="line">    ......</div><div class="line"></div><div class="line">    struct Peer* ep = Identity_check((struct Peer*) ici-&gt;peerMap.values[epIndex]);</div><div class="line">    ......</div><div class="line">    if (CryptoAuth_decrypt(ep-&gt;caSession, msg)) &#123;</div><div class="line">        return NULL;</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">    return receivedPostCryptoAuth(msg, ep, ici-&gt;ic);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="1-从ici-gt-peerMap中找到ep"><a href="#1-从ici-gt-peerMap中找到ep" class="headerlink" title="1. 从ici-&gt;peerMap中找到ep"></a>1. 从ici-&gt;peerMap中找到ep</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int epIndex = Map_EndpointsBySockaddr_indexForKey(&amp;lladdr, &amp;ici-&gt;peerMap);</div><div class="line">   ......</div><div class="line"></div><div class="line">   struct Peer* ep = Identity_check((struct Peer*) ici-&gt;peerMap.values[epIndex]);</div></pre></td></tr></table></figure>
<h5 id="2-调用CryptoAuth-decrypt进行解密"><a href="#2-调用CryptoAuth-decrypt进行解密" class="headerlink" title="2. 调用CryptoAuth_decrypt进行解密"></a>2. 调用CryptoAuth_decrypt进行解密</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">enum CryptoAuth_DecryptErr CryptoAuth_decrypt(struct CryptoAuth_Session* sessionPub,</div><div class="line">                                              struct Message* msg)</div><div class="line">&#123;</div><div class="line">    ......</div><div class="line">    uint32_t nonce = Endian_bigEndianToHost32(header-&gt;nonce);</div><div class="line"></div><div class="line">    if (!session-&gt;established) &#123;</div><div class="line">        if (nonce &gt;= Nonce_FIRST_TRAFFIC_PACKET) &#123;</div><div class="line">            ......</div><div class="line">        &#125;</div><div class="line">		......</div><div class="line">        return decryptHandshake(session, nonce, msg, header);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="3-decryptHandshake"><a href="#3-decryptHandshake" class="headerlink" title="3. decryptHandshake"></a>3. decryptHandshake</h5><p>先给出几个关键参数的值：</p>
<ul>
<li>nonce:从收到的包里取出，是发包者那边的nextNonce，值为CryptoAuth_State_RECEIVED_HELLO = 2</li>
<li>nextNonce:一个局部变量，随情况变化，最后会被设置到session-&gt;nextNonce</li>
<li>session-&gt;nextNonce:session中的nextNonce，真正标识这个session的状态。当前值为CryptoAuth_State_SENT_HELLO = 1</li>
</ul>
<p>对照一下Nonce和CryptoAuth_State<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">enum Nonce &#123;</div><div class="line">    Nonce_HELLO = 0,</div><div class="line">    Nonce_REPEAT_HELLO = 1,</div><div class="line">    Nonce_KEY = 2,</div><div class="line">    Nonce_REPEAT_KEY = 3,</div><div class="line">    Nonce_FIRST_TRAFFIC_PACKET = 4</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">enum CryptoAuth_State &#123;</div><div class="line">    // New CryptoAuth session, has not sent or received anything</div><div class="line">    CryptoAuth_State_INIT = 0,</div><div class="line"></div><div class="line">    // Sent a hello message, waiting for reply</div><div class="line">    CryptoAuth_State_SENT_HELLO = 1,</div><div class="line"></div><div class="line">    // Received a hello message, have not yet sent a reply</div><div class="line">    CryptoAuth_State_RECEIVED_HELLO = 2,</div><div class="line"></div><div class="line">    // Received a hello message, sent a key message, waiting for the session to complete</div><div class="line">    CryptoAuth_State_SENT_KEY = 3,</div><div class="line"></div><div class="line">    // Sent a hello message, received a key message, may or may not have sent some data traffic</div><div class="line">    // but no data traffic has yet been received</div><div class="line">    CryptoAuth_State_RECEIVED_KEY = 4,</div><div class="line"></div><div class="line">    // Received data traffic, session is in run state</div><div class="line">    CryptoAuth_State_ESTABLISHED = 100</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">static enum CryptoAuth_DecryptErr decryptHandshake(struct CryptoAuth_Session_pvt* session,</div><div class="line">                                                   const uint32_t nonce,</div><div class="line">                                                   struct Message* message,</div><div class="line">                                                   struct CryptoHeader* header)</div><div class="line">&#123;</div><div class="line">    ......</div><div class="line">    if (nonce &lt; Nonce_KEY) &#123; // HELLO or REPEAT_HELLO</div><div class="line">        ......</div><div class="line">    &#125; else &#123;</div><div class="line">        ......</div><div class="line">        // We sent the hello, this is a key</div><div class="line">        getSharedSecret(sharedSecret,</div><div class="line">                        session-&gt;ourTempPrivKey,</div><div class="line">                        session-&gt;pub.herPublicKey,</div><div class="line">                        passwordHash,</div><div class="line">                        session-&gt;context-&gt;logger);</div><div class="line">        nextNonce = CryptoAuth_State_RECEIVED_KEY;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ......</div><div class="line">    // Decrypt her temp public key and the message.</div><div class="line">    if (decryptRndNonce(header-&gt;handshakeNonce, message, sharedSecret)) &#123;</div><div class="line">        // just in case</div><div class="line">        Bits_memset(header, 0, CryptoHeader_SIZE);</div><div class="line">        cryptoAuthDebug(session, &quot;DROP message with nonce [%d], decryption failed&quot;, nonce);</div><div class="line">        return CryptoAuth_DecryptErr_HANDSHAKE_DECRYPT_FAILED;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ......</div><div class="line">    if (nextNonce == CryptoAuth_State_RECEIVED_KEY) &#123;</div><div class="line">        Assert_true(nonce == Nonce_KEY || nonce == Nonce_REPEAT_KEY);</div><div class="line">        switch (session-&gt;nextNonce) &#123;</div><div class="line">            ......</div><div class="line">            case CryptoAuth_State_SENT_HELLO: &#123;</div><div class="line">                Bits_memcpy(session-&gt;herTempPubKey, header-&gt;encryptedTempKey, 32);</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            ......</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">    session-&gt;nextNonce = nextNonce;</div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h6 id="3-1-计算SharedSecret-1"><a href="#3-1-计算SharedSecret-1" class="headerlink" title="3.1 计算SharedSecret"></a>3.1 计算SharedSecret</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">getSharedSecret(sharedSecret,</div><div class="line">                session-&gt;ourTempPrivKey,</div><div class="line">                session-&gt;pub.herPublicKey,</div><div class="line">                passwordHash,</div><div class="line">                session-&gt;context-&gt;logger);</div><div class="line">nextNonce = CryptoAuth_State_RECEIVED_KEY;</div></pre></td></tr></table></figure>
<p>关于这个函数的具体实现，在加密部分已经分析过。在接入点发包时，使用的是接入点的稳定私钥和普通点的临时公钥。而在这里，使用的是自己的临时私钥和接入点稳定公钥。公私钥对匹配，所以，计算出的SharedSecret是可以解密握手包的。</p>
<h6 id="3-2-解密message"><a href="#3-2-解密message" class="headerlink" title="3.2. 解密message"></a>3.2. 解密message</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// Decrypt her temp public key and the message.</div><div class="line">if (decryptRndNonce(header-&gt;handshakeNonce, message, sharedSecret)) &#123;</div><div class="line">    // just in case</div><div class="line">    Bits_memset(header, 0, CryptoHeader_SIZE);</div><div class="line">    cryptoAuthDebug(session, &quot;DROP message with nonce [%d], decryption failed&quot;, nonce);</div><div class="line">    return CryptoAuth_DecryptErr_HANDSHAKE_DECRYPT_FAILED;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不做具体分析</p>
<h6 id="3-3-将message中对方的临时公钥保存到herTempPubKey中-1"><a href="#3-3-将message中对方的临时公钥保存到herTempPubKey中-1" class="headerlink" title="3.3. 将message中对方的临时公钥保存到herTempPubKey中"></a>3.3. 将message中对方的临时公钥保存到herTempPubKey中</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">if (nextNonce == CryptoAuth_State_RECEIVED_KEY) &#123;</div><div class="line">       Assert_true(nonce == Nonce_KEY || nonce == Nonce_REPEAT_KEY);</div><div class="line">       switch (session-&gt;nextNonce) &#123;</div><div class="line">           ......</div><div class="line">           case CryptoAuth_State_SENT_HELLO: &#123;</div><div class="line">               Bits_memcpy(session-&gt;herTempPubKey, header-&gt;encryptedTempKey, 32);</div><div class="line">               break;</div><div class="line">           &#125;</div><div class="line">           ......</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h6 id="3-4-设置session-gt-nextNonce-1"><a href="#3-4-设置session-gt-nextNonce-1" class="headerlink" title="3.4 设置session-&gt;nextNonce"></a>3.4 设置session-&gt;nextNonce</h6><p>设为CryptoAuth_State_RECEIVED_KEY = 4<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">session-&gt;nextNonce = nextNonce;</div></pre></td></tr></table></figure></p>
<h5 id="4-调用receivedPostCryptoAuth-1"><a href="#4-调用receivedPostCryptoAuth-1" class="headerlink" title="4. 调用receivedPostCryptoAuth"></a>4. 调用receivedPostCryptoAuth</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">static Iface_DEFUN receivedPostCryptoAuth(struct Message* msg,</div><div class="line">                                          struct Peer* ep,</div><div class="line">                                          struct InterfaceController_pvt* ic)</div><div class="line">&#123;</div><div class="line">    ......</div><div class="line">    if (ep-&gt;state &lt; InterfaceController_PeerState_ESTABLISHED) &#123;</div><div class="line">   		......</div><div class="line">        if (caState == CryptoAuth_State_ESTABLISHED) &#123;</div><div class="line">            ......</div><div class="line">        &#125; else &#123;</div><div class="line">            ......</div><div class="line">            if (msg-&gt;length &lt; 8 || msg-&gt;bytes[7] != 1) &#123;</div><div class="line">                ......</div><div class="line">            &#125; else &#123;</div><div class="line">                ......</div><div class="line">                if ((ep-&gt;pingCount + 1) % 7) &#123;</div><div class="line">                    sendPing(ep);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">    return Iface_next(&amp;ep-&gt;switchIf, msg);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Iface_next(&amp;ep-&gt;switchIf, msg);会将message送去SessionManager.c，进行针对目标节点的解密操作，不做详细分析。<br>后面将直接进入回包分析，sendPing。</p>
<h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p>网络中的第二个包，是普通点收到接入点发出的回包，普通点会根据回包的内容，维护两个caSession的状态。</p>
<ol>
<li><p>对于代表邻居节点的caSession，目前的状态如下，其中黑体为本次收包过程中的改变</p>
<ul>
<li>邻居节点的稳定公钥herPublicKey</li>
<li><strong>邻居节点的临时公钥herTempPubKey</strong></li>
<li>自己的稳定公钥publicKey</li>
<li>自己的稳定私钥privateKey</li>
<li>自己的临时公钥ourTempPubKey</li>
<li>自己的临时私钥ourTempPrivKey</li>
<li><p><strong>nextNonce值为CryptoAuth_State_RECEIVED_KEY = 4。</strong></p>
<p>计算sharedSecret使用到</p>
</li>
<li>自己的临时私钥ourTempPrivKey</li>
<li>邻居节点的稳定公钥herPublicKey</li>
</ul>
</li>
<li><p>对于代表目标节点的caSession，目前的状态如下，其中黑体为本次收包过程中的改变</p>
<ul>
<li>目标节点的稳定公钥herPublicKey</li>
<li><strong>目标节点的临时公钥herTempPubKey</strong></li>
<li>自己的稳定公钥publicKey</li>
<li>自己的稳定私钥privateKey</li>
<li>自己的临时公钥ourTempPubKey</li>
<li>自己的临时私钥ourTempPrivKey</li>
<li><p><strong>nextNonce值为CryptoAuth_State_RECEIVED_KEY = 4 </strong></p>
<p>计算sharedSecret使用到</p>
</li>
<li>自己的临时私钥ourTempPrivKey</li>
<li>目标节点的稳定公钥herPublicKey</li>
</ul>
</li>
</ol>
<h3 id="发出第三个包：普通点向接入点回包"><a href="#发出第三个包：普通点向接入点回包" class="headerlink" title="发出第三个包：普通点向接入点回包"></a>发出第三个包：普通点向接入点回包</h3><p>普通点的回包操作，就是上面的sendPing。依然不详细分析具体调用流程，只关注对于加密部分的函数的调用，直接进入到CryptoAuth_encrypt方法。</p>
<h4 id="CryptoAuth-encrypt-2"><a href="#CryptoAuth-encrypt-2" class="headerlink" title="CryptoAuth_encrypt"></a>CryptoAuth_encrypt</h4><p>目前session-&gt;nextNonce为CryptoAuth_State_RECEIVED_KEY = 4<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">int CryptoAuth_encrypt(struct CryptoAuth_Session* sessionPub, struct Message* msg)</div><div class="line">&#123;</div><div class="line">    ......</div><div class="line">    if (session-&gt;nextNonce &lt;= CryptoAuth_State_RECEIVED_KEY) &#123;</div><div class="line">        if (session-&gt;nextNonce &lt; CryptoAuth_State_RECEIVED_KEY) &#123;</div><div class="line">            ......</div><div class="line">        &#125; else &#123;</div><div class="line">            ......</div><div class="line">            getSharedSecret(session-&gt;sharedSecret,</div><div class="line">                            session-&gt;ourTempPrivKey,</div><div class="line">                            session-&gt;herTempPubKey,</div><div class="line">                            NULL,</div><div class="line">                            session-&gt;context-&gt;logger);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    encrypt(session-&gt;nextNonce, msg, session-&gt;sharedSecret, session-&gt;isInitiator);</div><div class="line"></div><div class="line">    Message_push32(msg, session-&gt;nextNonce, NULL);</div><div class="line">    session-&gt;nextNonce++;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="getSharedSecret"><a href="#getSharedSecret" class="headerlink" title="getSharedSecret"></a>getSharedSecret</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">getSharedSecret(session-&gt;sharedSecret,</div><div class="line">                session-&gt;ourTempPrivKey,</div><div class="line">                session-&gt;herTempPubKey,</div><div class="line">                NULL,</div><div class="line">                session-&gt;context-&gt;logger);</div></pre></td></tr></table></figure>
<p>这里使用的是自己的临时私钥和接入点的临时公钥来计算SharedSecret</p>
<h4 id="encrypt加密message"><a href="#encrypt加密message" class="headerlink" title="encrypt加密message"></a>encrypt加密message</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">static inline void encrypt(uint32_t nonce,</div><div class="line">                           struct Message* msg,</div><div class="line">                           uint8_t secret[32],</div><div class="line">                           bool isInitiator)</div><div class="line">&#123;</div><div class="line">    union &#123;</div><div class="line">        uint32_t ints[2];</div><div class="line">        uint8_t bytes[24];</div><div class="line">    &#125; nonceAs = &#123; .ints = &#123;0, 0&#125; &#125;;</div><div class="line">    nonceAs.ints[isInitiator] = Endian_hostToLittleEndian32(nonce);</div><div class="line"></div><div class="line">    encryptRndNonce(nonceAs.bytes, msg, secret);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">static inline void encryptRndNonce(uint8_t nonce[24],</div><div class="line">                                   struct Message* msg,</div><div class="line">                                   uint8_t secret[32])</div><div class="line">&#123;</div><div class="line">    Assert_true(msg-&gt;padding &gt;= 32);</div><div class="line">    uint8_t* startAt = msg-&gt;bytes - 32;</div><div class="line">    // This function trashes 16 bytes of the padding so we will put it back</div><div class="line">    uint8_t paddingSpace[16];</div><div class="line">    Bits_memcpy(paddingSpace, startAt, 16);</div><div class="line">    Bits_memset(startAt, 0, 32);</div><div class="line">    if (!Defined(NSA_APPROVED)) &#123;</div><div class="line">        crypto_box_curve25519xsalsa20poly1305_afternm(</div><div class="line">            startAt, startAt, msg-&gt;length + 32, nonce, secret);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Bits_memcpy(startAt, paddingSpace, 16);</div><div class="line">    Message_shift(msg, 16, NULL);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="将session的next-gt-nextNonce放入message中"><a href="#将session的next-gt-nextNonce放入message中" class="headerlink" title="将session的next-&gt;nextNonce放入message中"></a>将session的next-&gt;nextNonce放入message中</h4><p>此时session-&gt;nextNonce为CryptoAuth_State_RECEIVED_KEY = 4<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Message_push32(msg, session-&gt;nextNonce, NULL);</div></pre></td></tr></table></figure></p>
<h4 id="维护session-gt-nextNonce"><a href="#维护session-gt-nextNonce" class="headerlink" title="维护session-&gt;nextNonce"></a>维护session-&gt;nextNonce</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">session-&gt;nextNonce++;</div></pre></td></tr></table></figure>
<p>此时session-&gt;nextNonce值为5</p>
<h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><p>网络中的第三个包，是普通点向接入点发出的包，此时两个caSession的状态。</p>
<ol>
<li><p>对于代表邻居节点的caSession，目前的状态如下，其中黑体为本次发包后的改变</p>
<ul>
<li>邻居节点的稳定公钥herPublicKey</li>
<li>邻居节点的临时公钥herTempPubKey</li>
<li>自己的稳定公钥publicKey</li>
<li>自己的稳定私钥privateKey</li>
<li>自己的临时公钥ourTempPubKey</li>
<li>自己的临时私钥ourTempPrivKey</li>
<li><p><strong>nextNonce值为5</strong></p>
<p>计算sharedSecret使用到</p>
</li>
<li>自己的临时私钥ourTempPrivKey</li>
<li><p>邻居节点的临时公钥herTempPubKey</p>
<p>在发出去的握手包中包括</p>
</li>
<li>值为CryptoAuth_State_RECEIVED_KEY = 4的nonce字段</li>
<li>使用sharedSecret加密过的message内容</li>
</ul>
</li>
<li><p>对于代表目标节点的caSession，目前的状态如下，其中黑体为本次发包后的改变</p>
<ul>
<li>目标节点的稳定公钥herPublicKey</li>
<li>目标节点的临时公钥herTempPubKey</li>
<li>自己的稳定公钥publicKey</li>
<li>自己的稳定私钥privateKey</li>
<li>自己的临时公钥ourTempPubKey</li>
<li>自己的临时私钥ourTempPrivKey</li>
<li><p><strong>nextNonce值为5</strong></p>
<p>计算sharedSecret使用到</p>
</li>
<li>自己的临时私钥ourTempPrivKey</li>
<li><p>目标节点的临时公钥herTempPubKey</p>
<p>在发出去的握手包中包括</p>
</li>
<li>值为CryptoAuth_State_RECEIVED_KEY = 4的nonce字段</li>
<li>使用sharedSecret加密过的message内容</li>
</ul>
</li>
</ol>
<h3 id="收到第三个包：接入点收到普通点发来的包"><a href="#收到第三个包：接入点收到普通点发来的包" class="headerlink" title="收到第三个包：接入点收到普通点发来的包"></a>收到第三个包：接入点收到普通点发来的包</h3><p>直接进入handleIncomingFromWire</p>
<h4 id="handleIncomingFromWire-2"><a href="#handleIncomingFromWire-2" class="headerlink" title="handleIncomingFromWire"></a>handleIncomingFromWire</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">static Iface_DEFUN handleIncomingFromWire(struct Message* msg, struct Iface* addrIf)</div><div class="line">&#123;</div><div class="line">    ......</div><div class="line">    int epIndex = Map_EndpointsBySockaddr_indexForKey(&amp;lladdr, &amp;ici-&gt;peerMap);</div><div class="line">    ......</div><div class="line">    struct Peer* ep = Identity_check((struct Peer*) ici-&gt;peerMap.values[epIndex]);</div><div class="line">    ......</div><div class="line">    if (CryptoAuth_decrypt(ep-&gt;caSession, msg)) &#123;</div><div class="line">        return NULL;</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">    return receivedPostCryptoAuth(msg, ep, ici-&gt;ic);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="1-CryptoAuth-decrypt"><a href="#1-CryptoAuth-decrypt" class="headerlink" title="1. CryptoAuth_decrypt"></a>1. CryptoAuth_decrypt</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">enum CryptoAuth_DecryptErr CryptoAuth_decrypt(struct CryptoAuth_Session* sessionPub,</div><div class="line">                                              struct Message* msg)</div><div class="line">&#123;</div><div class="line">    ......</div><div class="line">    uint32_t nonce = Endian_bigEndianToHost32(header-&gt;nonce);//nonce值为4</div><div class="line"></div><div class="line">    if (!session-&gt;established) &#123;</div><div class="line">        if (nonce &gt;= Nonce_FIRST_TRAFFIC_PACKET) &#123;//Nonce_FIRST_TRAFFIC_PACKET = 4</div><div class="line">            ......</div><div class="line">            getSharedSecret(secret,</div><div class="line">                            session-&gt;ourTempPrivKey,</div><div class="line">                            session-&gt;herTempPubKey,</div><div class="line">                            NULL,</div><div class="line">                            session-&gt;context-&gt;logger);</div><div class="line"></div><div class="line">            enum CryptoAuth_DecryptErr ret = decryptMessage(session, nonce, msg, secret);</div><div class="line">            if (!ret) &#123;</div><div class="line">                ......</div><div class="line">                Bits_memcpy(session-&gt;sharedSecret, secret, 32);</div><div class="line"></div><div class="line">                // Now we&apos;re in run mode, no more handshake packets will be accepted</div><div class="line">                session-&gt;established = true;</div><div class="line">                session-&gt;nextNonce += 3;</div><div class="line">                ......</div><div class="line">                return 0;</div><div class="line">            &#125;</div><div class="line">            ......</div><div class="line">        &#125;</div><div class="line">		......</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h6 id="1-1-getSharedSecret"><a href="#1-1-getSharedSecret" class="headerlink" title="1.1 getSharedSecret"></a>1.1 getSharedSecret</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">getSharedSecret(secret,</div><div class="line">                session-&gt;ourTempPrivKey,</div><div class="line">                session-&gt;herTempPubKey,</div><div class="line">                NULL,</div><div class="line">                session-&gt;context-&gt;logger);</div></pre></td></tr></table></figure>
<p>这里，使用了接入点的临时私钥和普通点的临时公钥来计算SharedSecret</p>
<p>####### 1.2 调用decryptMessage解密message ######<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">static inline enum CryptoAuth_DecryptErr decryptMessage(struct CryptoAuth_Session_pvt* session,</div><div class="line">                                                        uint32_t nonce,</div><div class="line">                                                        struct Message* content,</div><div class="line">                                                        uint8_t secret[32])</div><div class="line">&#123;</div><div class="line">    // Decrypt with authentication and replay prevention.</div><div class="line">    if (decrypt(nonce, content, secret, session-&gt;isInitiator)) &#123;</div><div class="line">        cryptoAuthDebug0(session, &quot;DROP authenticated decryption failed&quot;);</div><div class="line">        return CryptoAuth_DecryptErr_DECRYPT;</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h6 id="1-3-保存会话密钥"><a href="#1-3-保存会话密钥" class="headerlink" title="1.3 保存会话密钥"></a>1.3 保存会话密钥</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Bits_memcpy(session-&gt;sharedSecret, secret, 32);</div></pre></td></tr></table></figure>
<p>将使用接入点临时私钥和普通点临时公钥计算出的SharedSecret保存到session-&gt;sharedSecret中。<br>当握手过程完成后，节点间的交互都会使用这个SharedSecret来加密message。将这个值保存起来，方便后期的加密操作。</p>
<h6 id="1-4-维护session状态"><a href="#1-4-维护session状态" class="headerlink" title="1.4 维护session状态"></a>1.4 维护session状态</h6><p>这段代码执行之前，session-&gt;nextNonce的值为CryptoAuth_State_SENT_KEY = 3<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">session-&gt;established = true;</div><div class="line">session-&gt;nextNonce += 3;</div></pre></td></tr></table></figure></p>
<p>此时session-&gt;nextNonce的值为6。session状态为established</p>
<h5 id="2-调用receivedPostCryptoAuth"><a href="#2-调用receivedPostCryptoAuth" class="headerlink" title="2. 调用receivedPostCryptoAuth"></a>2. 调用receivedPostCryptoAuth</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">static Iface_DEFUN receivedPostCryptoAuth(struct Message* msg,</div><div class="line">                                          struct Peer* ep,</div><div class="line">                                          struct InterfaceController_pvt* ic)</div><div class="line">&#123;</div><div class="line">    ......</div><div class="line">    int caState = CryptoAuth_getState(ep-&gt;caSession);</div><div class="line"></div><div class="line">    if (ep-&gt;state &lt; InterfaceController_PeerState_ESTABLISHED) &#123;</div><div class="line">        // EP states track CryptoAuth states...</div><div class="line">        ep-&gt;state = caState;</div><div class="line">        ......</div><div class="line">        if (caState == CryptoAuth_State_ESTABLISHED) &#123;</div><div class="line">            moveEndpointIfNeeded(ep);</div><div class="line">            //sendPeer(0xffffffff, PFChan_Core_PEER, ep);// version is not known at this point.</div><div class="line">        &#125;</div><div class="line">        ......</div><div class="line">    &#125;</div><div class="line">	......</div><div class="line">	return Iface_next(&amp;ep-&gt;switchIf, msg);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h6 id="2-1-计算caState"><a href="#2-1-计算caState" class="headerlink" title="2.1 计算caState"></a>2.1 计算caState</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">enum CryptoAuth_State CryptoAuth_getState(struct CryptoAuth_Session* caSession)</div><div class="line">&#123;</div><div class="line">    struct CryptoAuth_Session_pvt* session =</div><div class="line">        Identity_check((struct CryptoAuth_Session_pvt*)caSession);</div><div class="line"></div><div class="line">    if (session-&gt;nextNonce &lt;= CryptoAuth_State_RECEIVED_KEY) &#123;</div><div class="line">        return session-&gt;nextNonce;</div><div class="line">    &#125;</div><div class="line">    return (session-&gt;established) ? CryptoAuth_State_ESTABLISHED : CryptoAuth_State_RECEIVED_KEY;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>之前都没有分析这个函数，原因是，在这个包之前，caState都和session-&gt;nextNonce一样。<br>而这一次，由于前面将session-&gt;established设为true，所以，这次，caState将会返回CryptoAuth_State_ESTABLISHED</p>
<h6 id="2-2-一些状态维护操作"><a href="#2-2-一些状态维护操作" class="headerlink" title="2.2 一些状态维护操作"></a>2.2 一些状态维护操作</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">if (ep-&gt;state &lt; InterfaceController_PeerState_ESTABLISHED) &#123;</div><div class="line">    // EP states track CryptoAuth states...</div><div class="line">    ep-&gt;state = caState;</div><div class="line">    ......</div><div class="line">    if (caState == CryptoAuth_State_ESTABLISHED) &#123;</div><div class="line">        moveEndpointIfNeeded(ep);</div><div class="line">        //sendPeer(0xffffffff, PFChan_Core_PEER, ep);// version is not known at this point.</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>主要是修改了ep-&gt;state</p>
<h6 id="2-3-将message送去下一站处理"><a href="#2-3-将message送去下一站处理" class="headerlink" title="2.3 将message送去下一站处理"></a>2.3 将message送去下一站处理</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">return Iface_next(&amp;ep-&gt;switchIf, msg);</div></pre></td></tr></table></figure>
<p>Iface_next(&amp;ep-&gt;switchIf, msg);会将message送去SessionManager.c，进行针对目标节点的解密操作，不做详细分析。</p>
<h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h4><p>网络中的第三个包，是接入点收到普通点发出的回包，接入点会根据回包的内容，维护两个caSession的状态。</p>
<ol>
<li><p>对于代表邻居节点的caSession，目前的状态如下，其中黑体为本次收包过程中的改变</p>
<ul>
<li>邻居节点的稳定公钥herPublicKey</li>
<li>邻居节点的临时公钥herTempPubKey</li>
<li>自己的稳定公钥publicKey</li>
<li>自己的稳定私钥privateKey</li>
<li>自己的临时公钥ourTempPubKey</li>
<li>自己的临时私钥ourTempPrivKey</li>
<li><strong>nextNonce值为6</strong></li>
<li><strong>caState为established</strong></li>
<li><p><strong>ep-&gt;state为established</strong></p>
<p>计算sharedSecret使用到</p>
</li>
<li>自己的临时私钥ourTempPrivKey</li>
<li>邻居节点的临时公钥herTempPubKey</li>
</ul>
</li>
<li><p>对于代表目标节点的caSession，目前的状态如下，其中黑体为本次收包过程中的改变</p>
<ul>
<li>目标节点的稳定公钥herPublicKey</li>
<li>目标节点的临时公钥herTempPubKey</li>
<li>自己的稳定公钥publicKey</li>
<li>自己的稳定私钥privateKey</li>
<li>自己的临时公钥ourTempPubKey</li>
<li>自己的临时私钥ourTempPrivKey</li>
<li><strong>nextNonce值为6</strong></li>
<li><strong>caState为established</strong></li>
<li><p><strong>ep-&gt;state为established</strong></p>
<p>计算sharedSecret使用到</p>
</li>
<li>自己的临时私钥ourTempPrivKey</li>
<li>目标节点的临时公钥herTempPubKey</li>
</ul>
</li>
</ol>
<p>到这里，接入点上关于普通点的两个caSession的状态都已经变成了established。握手过程结束，进入正常的会话过程。<br>然而，普通点怎么办？普通点上关于接入点的两个caSession的状态都还没有established，nextNonce值都是5.如何触发普通点上的caSession也变成established？这就需要用到cjdns中的一个关于节点保活的机制。<br>当接入点上表示普通点的那个ep的state变为established之后，接入点将会每隔固定时间，向普通点发送sendPing来维护普通点的状态。于是，在这个维护机制下，接入点向普通点发送了sendPing。</p>
<h3 id="第四个包：接入点发送ping包，触发普通点状态变化"><a href="#第四个包：接入点发送ping包，触发普通点状态变化" class="headerlink" title="第四个包：接入点发送ping包，触发普通点状态变化"></a>第四个包：接入点发送ping包，触发普通点状态变化</h3><p>关于sendPing。依然不详细分析具体调用流程，只关注对于加密部分的函数的调用，直接进入到CryptoAuth_encrypt方法。</p>
<h4 id="CryptoAuth-encrypt-3"><a href="#CryptoAuth-encrypt-3" class="headerlink" title="CryptoAuth_encrypt"></a>CryptoAuth_encrypt</h4><p>目前session-&gt;nextNonce为6<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">int CryptoAuth_encrypt(struct CryptoAuth_Session* sessionPub, struct Message* msg)</div><div class="line">&#123;</div><div class="line">    ......</div><div class="line">    encrypt(session-&gt;nextNonce, msg, session-&gt;sharedSecret, session-&gt;isInitiator);</div><div class="line"></div><div class="line">    Message_push32(msg, session-&gt;nextNonce, NULL);</div><div class="line">    session-&gt;nextNonce++;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里主要做了三个操作：</p>
<ol>
<li>调用encrypt加密message,使用的密钥是session-&gt;sharedSecret，这是使用接入点的临时私钥和普通点的临时公钥计算出来的</li>
<li>将nextNonce=6放入message中</li>
<li>修改nextNonce为7</li>
</ol>
<h3 id="收到第四个包：普通点收到接入点发来的ping包"><a href="#收到第四个包：普通点收到接入点发来的ping包" class="headerlink" title="收到第四个包：普通点收到接入点发来的ping包"></a>收到第四个包：普通点收到接入点发来的ping包</h3><p>普通点将在处理这个包的过程中完成握手阶段，进入稳定会话阶段。</p>
<h4 id="handleIncomingFromWire-3"><a href="#handleIncomingFromWire-3" class="headerlink" title="handleIncomingFromWire"></a>handleIncomingFromWire</h4><figure class="highlight plain"><figcaption><span>Iface_DEFUN handleIncomingFromWire(struct Message* msg, struct Iface* addrIf)</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    ......</div><div class="line">    int epIndex = Map_EndpointsBySockaddr_indexForKey(&amp;lladdr, &amp;ici-&gt;peerMap);</div><div class="line">    ......</div><div class="line">    struct Peer* ep = Identity_check((struct Peer*) ici-&gt;peerMap.values[epIndex]);</div><div class="line">    ......</div><div class="line">    if (CryptoAuth_decrypt(ep-&gt;caSession, msg)) &#123;</div><div class="line">        return NULL;</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">    if (ep-&gt;state == InterfaceController_PeerState_ESTABLISHED &amp;&amp;</div><div class="line">        CryptoAuth_getState(ep-&gt;caSession) != CryptoAuth_State_ESTABLISHED) &#123;</div><div class="line">        sendPeer(0xffffffff, PFChan_Core_PEER_GONE, ep);</div><div class="line">    &#125;</div><div class="line">    return receivedPostCryptoAuth(msg, ep, ici-&gt;ic);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="1-从ici-gt-peerMap中找到ep-1"><a href="#1-从ici-gt-peerMap中找到ep-1" class="headerlink" title="1. 从ici-&gt;peerMap中找到ep"></a>1. 从ici-&gt;peerMap中找到ep</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int epIndex = Map_EndpointsBySockaddr_indexForKey(&amp;lladdr, &amp;ici-&gt;peerMap);</div><div class="line">   ......</div><div class="line"></div><div class="line">   struct Peer* ep = Identity_check((struct Peer*) ici-&gt;peerMap.values[epIndex]);</div></pre></td></tr></table></figure>
<h5 id="2-调用CryptoAuth-decrypt进行解密-1"><a href="#2-调用CryptoAuth-decrypt进行解密-1" class="headerlink" title="2. 调用CryptoAuth_decrypt进行解密"></a>2. 调用CryptoAuth_decrypt进行解密</h5><p>nonce:6<br>session-&gt;nextNonce = 5<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">enum CryptoAuth_DecryptErr CryptoAuth_decrypt(struct CryptoAuth_Session* sessionPub,</div><div class="line">                                              struct Message* msg)</div><div class="line">&#123;</div><div class="line">    ......</div><div class="line">    uint32_t nonce = Endian_bigEndianToHost32(header-&gt;nonce);</div><div class="line"></div><div class="line">    if (!session-&gt;established) &#123;</div><div class="line">        if (nonce &gt;= Nonce_FIRST_TRAFFIC_PACKET) &#123;</div><div class="line">            ......</div><div class="line">            getSharedSecret(secret,</div><div class="line">                            session-&gt;ourTempPrivKey,</div><div class="line">                            session-&gt;herTempPubKey,</div><div class="line">                            NULL,</div><div class="line">                            session-&gt;context-&gt;logger);</div><div class="line"></div><div class="line">            enum CryptoAuth_DecryptErr ret = decryptMessage(session, nonce, msg, secret);</div><div class="line">            if (!ret) &#123;</div><div class="line">                cryptoAuthDebug0(session, &quot;Final handshake step succeeded&quot;);</div><div class="line">                Bits_memcpy(session-&gt;sharedSecret, secret, 32);</div><div class="line"></div><div class="line">                // Now we&apos;re in run mode, no more handshake packets will be accepted</div><div class="line">                session-&gt;established = true;</div><div class="line">                session-&gt;nextNonce += 3;</div><div class="line">                ......</div><div class="line">                return 0;</div><div class="line">            &#125;</div><div class="line">            ......</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ......</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h6 id="2-1-计算SharedSecret"><a href="#2-1-计算SharedSecret" class="headerlink" title="2.1 计算SharedSecret"></a>2.1 计算SharedSecret</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">getSharedSecret(secret,</div><div class="line">                session-&gt;ourTempPrivKey,</div><div class="line">                session-&gt;herTempPubKey,</div><div class="line">                NULL,</div><div class="line">                session-&gt;context-&gt;logger);</div></pre></td></tr></table></figure>
<p>使用了普通点的临时私钥和接入点的临时公钥来计算SharedSecret</p>
<h6 id="2-2-解密message"><a href="#2-2-解密message" class="headerlink" title="2.2 解密message"></a>2.2 解密message</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">enum CryptoAuth_DecryptErr ret = decryptMessage(session, nonce, msg, secret);</div></pre></td></tr></table></figure>
<h6 id="2-3-保存会话密钥"><a href="#2-3-保存会话密钥" class="headerlink" title="2.3 保存会话密钥"></a>2.3 保存会话密钥</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Bits_memcpy(session-&gt;sharedSecret, secret, 32);</div></pre></td></tr></table></figure>
<p>将使用普通点临时私钥和接入点临时公钥计算出的SharedSecret保存到session-&gt;sharedSecret中。<br>当握手过程完成后，节点间的交互都会使用这个SharedSecret来加密message。将这个值保存起来，方便后期的加密操作。</p>
<h6 id="2-4-维护session状态"><a href="#2-4-维护session状态" class="headerlink" title="2.4 维护session状态"></a>2.4 维护session状态</h6><p>这段代码执行之前，session-&gt;nextNonce的值为5<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">session-&gt;established = true;</div><div class="line">session-&gt;nextNonce += 3;</div></pre></td></tr></table></figure></p>
<p>此时session-&gt;nextNonce的值为8。session状态为established</p>
<h5 id="3-receivedPostCryptoAuth"><a href="#3-receivedPostCryptoAuth" class="headerlink" title="3. receivedPostCryptoAuth"></a>3. receivedPostCryptoAuth</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">static Iface_DEFUN receivedPostCryptoAuth(struct Message* msg,</div><div class="line">                                          struct Peer* ep,</div><div class="line">                                          struct InterfaceController_pvt* ic)</div><div class="line">&#123;</div><div class="line">    ......</div><div class="line">    int caState = CryptoAuth_getState(ep-&gt;caSession);</div><div class="line">    if (ep-&gt;state &lt; InterfaceController_PeerState_ESTABLISHED) &#123;</div><div class="line">        // EP states track CryptoAuth states...</div><div class="line">        ep-&gt;state = caState;</div><div class="line">        ......</div><div class="line">        if (caState == CryptoAuth_State_ESTABLISHED) &#123;</div><div class="line">            moveEndpointIfNeeded(ep);</div><div class="line">            //sendPeer(0xffffffff, PFChan_Core_PEER, ep);// version is not known at this point.</div><div class="line">        &#125; else &#123;</div><div class="line">            ......</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">    return Iface_next(&amp;ep-&gt;switchIf, msg);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>和前面接入点收到包后的处理一样，不再详细分析。<br>caSession和ep-&gt;state都是CryptoAuth_State_ESTABLISHED</p>
<h4 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h4><p>网络中的第四个包，是接入点执行保活操作时，发往普通点的包。普通点根据包的内容，维护两个caSession的状态。</p>
<ol>
<li><p>对于代表邻居节点的caSession，目前的状态如下，其中黑体为本次收包过程中的改变</p>
<ul>
<li>邻居节点的稳定公钥herPublicKey</li>
<li>邻居节点的临时公钥herTempPubKey</li>
<li>自己的稳定公钥publicKey</li>
<li>自己的稳定私钥privateKey</li>
<li>自己的临时公钥ourTempPubKey</li>
<li>自己的临时私钥ourTempPrivKey</li>
<li><strong>nextNonce值为8</strong></li>
<li><strong>caState为established</strong></li>
<li><strong>ep-&gt;state为established</strong></li>
</ul>
</li>
<li><p>对于代表目标节点的caSession，目前的状态如下，其中黑体为本次收包过程中的改变</p>
<ul>
<li>目标节点的稳定公钥herPublicKey</li>
<li>目标节点的临时公钥herTempPubKey</li>
<li>自己的稳定公钥publicKey</li>
<li>自己的稳定私钥privateKey</li>
<li>自己的临时公钥ourTempPubKey</li>
<li>自己的临时私钥ourTempPrivKey</li>
<li><strong>nextNonce值为8</strong></li>
<li><strong>caState为established</strong></li>
<li><strong>ep-&gt;state为established</strong></li>
</ul>
</li>
</ol>
<p>到这里，普通点上关于接入点的两个caSession的状态都已经变成了established。握手过程结束，进入正常的会话过程。</p>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="/assets/img/cjdns-asymmetric-cryptography/img.jpg" alt="image"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/29/cjnds-asymmetric-cryptography/" data-id="cje6pjw1z003yweyx7uz65gtj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C/">C/C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cjdns/">cjdns</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cjdns源码分析/">cjdns源码分析</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-how-to-fix-rebase-still-in-progress" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/04/how-to-fix-rebase-still-in-progress/" class="article-date">
  <time datetime="2017-12-04T05:19:46.000Z" itemprop="datePublished">2017-12-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/AndroidRom/">AndroidRom</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/04/how-to-fix-rebase-still-in-progress/">如何解决报错“prior sync failed; rebase still in progress”</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在android系统的源码中，有一些项目需要自己维护，所以添加了新的remote和branch。<br>但是在.repo中，这些项目的源还在原本的remote上，当执行repo sync时，会出现报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">prior sync failed; rebase still in progress</div></pre></td></tr></table></figure></p>
<p>通常情况下，网上能找到的解决方法是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git rebase --abort</div></pre></td></tr></table></figure></p>
<p>然而这并没有用<br>删除这个项目再执行repo sync有时是管用的。但是如果遇上例如frameworks/base这个巨大的项目，根本舍不得删除，再牵出一次耗时太久，成功率还低</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>在出问题的项目中，（比如frameworks/base，）新建一个符合repo中remote的branch<br>查看.repo/manifests/default.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;project path=&quot;frameworks/base&quot; name=&quot;MoKee/android_frameworks_base&quot; groups=&quot;pdk-cw-fs,pdk-fs&quot; /&gt;</div></pre></td></tr></table></figure></p>
<p>可见这是一个mokee的项目<br>进入frameworks/base项目下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">$ git branch -av</div><div class="line">* （非分支，正变基 dev）   bc9e0ec Merge branch &apos;remote&apos; into mkn-mr1</div><div class="line">  remotes/anrom/dev           fcff150 Merge branch &apos;dev&apos; of github.sbu:ROM/android_frameworks_base into dev</div><div class="line">  remotes/anrom/mkn-mr1       cc29ef0 [Xposed] Add XposedBridge.removeFinalFlagNative()</div><div class="line">  remotes/m/mkn-mr1           -&gt; mokee/mkn-mr1</div><div class="line">  remotes/mokee/jb-mr1_mkt    139c903 code cleanup and update license</div><div class="line">  remotes/mokee/jb-mr2_mkt    c72c0b3 Merge branch &apos;cm-10.2&apos; into martincz</div><div class="line">  remotes/mokee/jb_mkt        f6abc38 fix 24hours bind bug</div><div class="line">  remotes/mokee/kk_mkt        ea794d2 Merge branch into kk_mkt</div><div class="line">  remotes/mokee/mkl           1032156 Update Translations</div><div class="line">  remotes/mokee/mkl-mr1       2ab30d1 Merge branch &apos;remote&apos; into mkl-mr1</div><div class="line">  remotes/mokee/mkl-mr1-viper e833fe9 Merge branch &apos;remote&apos; into mkl-mr1</div><div class="line">  remotes/mokee/mkm           e52c73e Automatic translation import</div><div class="line">  remotes/mokee/mkn-mr1       35e8c9b Automatic translation import</div><div class="line">  remotes/mokee/mko           3bac848 base: mokee cloud interface</div></pre></td></tr></table></figure></p>
<p>可以看到，这个正变基就是出问题的branch。<br>解决问题需要做的操作是，新建一个mkn-mr1分支。upstream设置为mokee/mkn-mr1.这样，以后执行repo sync时，会往这个分支同步。至于自己使用的分支，后期再自行手动merge。</p>
<p>进入frameworks/base，执行以下操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git checkout -f remotes/mokee/mkn-mr1</div><div class="line">git branch -b mkn-mr1</div><div class="line">git branch --set-upstream-to=mokee/mkn-mr1</div></pre></td></tr></table></figure></p>
<p>之后，再执行repo sync时，不会再报错了</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/12/04/how-to-fix-rebase-still-in-progress/" data-id="cje6pjw1f002iweyxtt8fl9xo" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/git/">git</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rom/">rom</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-cjdns-3steps-lladdrsession" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/22/cjdns-3steps-lladdrsession/" class="article-date">
  <time datetime="2017-11-22T08:11:01.000Z" itemprop="datePublished">2017-11-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/cjdns/">cjdns</a>►<a class="article-category-link" href="/categories/cjdns/cjdns源码分析/">cjdns源码分析</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/22/cjdns-3steps-lladdrsession/">使用SocketAddress来维护的EndpointsBySockaddr map机制中EndpointsBySockaddr session的建立过程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>源码位置：net/InterfaceController.c<br>首先，一个点要连入网内，肯定是依靠连接到一个已知点，将这个已知点作为自己的inbound。体现在配置中，就是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&quot;interfaces&quot;:&#123;</div><div class="line">	&quot;UDPInterface&quot;:[</div><div class="line">		&#123;</div><div class="line">			&quot;bind&quot;:&quot;0.0.0.0:26808&quot;,</div><div class="line">			&quot;connectTo&quot;:&#123;</div><div class="line">               	&quot;192.168.2.82:29509&quot;:&#123;</div><div class="line">               	    &quot;password&quot;:&quot;GDY6nag7aI1ArqVK08Yr8hGRw2IDKB7&quot;,</div><div class="line">                       &quot;publicKey&quot;:&quot;n2q6nuf0d5jsw7108qg1sxkc2hjp702hwlt2g3q379u9x5tsnr70.k&quot;</div><div class="line">               	&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	],</div><div class="line">	&quot;ETHInterface&quot;:[</div><div class="line">		&#123;</div><div class="line">			&quot;bind&quot;:&quot;all&quot;,</div><div class="line">			&quot;beacon&quot;:0,</div><div class="line">			&quot;connectTo&quot;:&#123;&#125;</div><div class="line">		&#125;</div><div class="line">	]</div><div class="line">&#125;,</div></pre></td></tr></table></figure></p>
<p>比如这个192.168.2.82，就是inbound。<br>同样，网内的点也可能被别的点作为inbound，来主动连接。<br>无论是主动连接，还是被动连接，所有直接连接到我的点，都是我的peer。</p>
<h2 id="EndpointsBySockaddr的结构"><a href="#EndpointsBySockaddr的结构" class="headerlink" title="EndpointsBySockaddr的结构"></a>EndpointsBySockaddr的结构</h2><p>当前网内用来维护peer状态的，就是这个EndpointsBySockaddr map，首先看一下，这个map的结构定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// ---------------- Map ----------------</div><div class="line">#define Map_NAME EndpointsBySockaddr</div><div class="line">#define Map_ENABLE_HANDLES</div><div class="line">#define Map_KEY_TYPE struct Sockaddr*</div><div class="line">#define Map_VALUE_TYPE struct Peer*</div><div class="line">#define Map_USE_HASH</div><div class="line">#define Map_USE_COMPARATOR</div><div class="line">#include &quot;util/Map.h&quot;</div><div class="line">static inline uint32_t Map_EndpointsBySockaddr_hash(struct Sockaddr** key)</div><div class="line">&#123;</div><div class="line">    return Sockaddr_hash(*key);</div><div class="line">&#125;</div><div class="line">static inline int Map_EndpointsBySockaddr_compare(struct Sockaddr** keyA, struct Sockaddr** keyB)</div><div class="line">&#123;</div><div class="line">    return Sockaddr_compare(*keyA, *keyB);</div><div class="line">&#125;</div><div class="line">// ---------------- EndMap ----------------</div></pre></td></tr></table></figure></p>
<p>用Sockaddr*作为key，支持handles。所谓支持handles，其实就是增加了一种在map中寻找条目的方法。除了使用key来寻找对应条目，还可以使用handle来寻找条目。<br>handle是一个uint32_t类型的值，非常便于存储和传递。</p>
<h2 id="建立过程"><a href="#建立过程" class="headerlink" title="建立过程"></a>建立过程</h2><p>依照点连入网内的过程，来分析session建立的过程。</p>
<h3 id="连接inbound"><a href="#连接inbound" class="headerlink" title="连接inbound"></a>连接inbound</h3><p>调用过程：<br>client/Configurator.c:udpInterface<br>-&gt;  interface/UDPInterface_admin.c:beginConnection<br>-&gt;  net/InterfaceController.c:InterfaceController_bootstrapPeer<br>这里只分析InterfaceController.c文件中的内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">int InterfaceController_bootstrapPeer(struct InterfaceController* ifc,</div><div class="line">                                      int interfaceNumber,</div><div class="line">                                      uint8_t* herPublicKey,</div><div class="line">                                      const struct Sockaddr* lladdrParm,</div><div class="line">                                      String* password,</div><div class="line">                                      String* login,</div><div class="line">                                      String* user,</div><div class="line">                                      struct Allocator* alloc)</div><div class="line">&#123;</div><div class="line">    ......</div><div class="line">    //这里新建一个Peer</div><div class="line">    struct Peer* ep = Allocator_calloc(epAlloc, sizeof(struct Peer), 1);</div><div class="line">    ep-&gt;addrAlloc = Allocator_child(epAlloc);</div><div class="line">    //作为key的Sockaddr</div><div class="line">    struct Sockaddr* lladdr = Sockaddr_clone(lladdrParm, ep-&gt;addrAlloc);</div><div class="line">    //加入到map当中</div><div class="line">    int index = Map_EndpointsBySockaddr_put(&amp;lladdr, &amp;ep, &amp;ici-&gt;peerMap);</div><div class="line">    Assert_true(index &gt;= 0);</div><div class="line">    ep-&gt;alloc = epAlloc;</div><div class="line">    //handle字段就是map中的handler</div><div class="line">    ep-&gt;handle = ici-&gt;peerMap.handles[index];</div><div class="line">    ......</div><div class="line">    //向这个peer（也就是inbound）发送ping</div><div class="line">    sendPing(ep);</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="inbound收到这个ping"><a href="#inbound收到这个ping" class="headerlink" title="inbound收到这个ping"></a>inbound收到这个ping</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">static Iface_DEFUN handleIncomingFromWire(struct Message* msg, struct Iface* addrIf)</div><div class="line">&#123;</div><div class="line">    ......</div><div class="line">	//拿到Sockaddr</div><div class="line">    struct Sockaddr* lladdr = (struct Sockaddr*) msg-&gt;bytes;</div><div class="line">    ......</div><div class="line">    epIndex = Map_EndpointsBySockaddr_indexForKey(&amp;lladdr, &amp;ici-&gt;peerMap);</div><div class="line">    ......</div><div class="line">    if (epIndex == -1) &#123;</div><div class="line">        return handleUnexpectedIncoming(msg, ici);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为是第一个包，所以会进入到handleUnexpectedIncoming<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">static Iface_DEFUN handleUnexpectedIncoming(struct Message* msg,</div><div class="line">                                            struct InterfaceController_Iface_pvt* ici)</div><div class="line">&#123;</div><div class="line">    ......</div><div class="line">    //拿到Socketaddr</div><div class="line">    struct Sockaddr* lladdr = (struct Sockaddr*) msg-&gt;bytes;</div><div class="line">    //新建一个peer</div><div class="line">    ......</div><div class="line">    struct Peer* ep = Allocator_calloc(epAlloc, sizeof(struct Peer), 1);</div><div class="line">	......</div><div class="line">    //加入到map</div><div class="line">    Assert_true(Map_EndpointsBySockaddr_indexForKey(&amp;lladdr, &amp;ici-&gt;peerMap) == -1);</div><div class="line">    int index = Map_EndpointsBySockaddr_put(&amp;lladdr, &amp;ep, &amp;ici-&gt;peerMap);</div><div class="line">    Assert_true(index &gt;= 0);</div><div class="line">    ep-&gt;handle = ici-&gt;peerMap.handles[index];</div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/11/22/cjdns-3steps-lladdrsession/" data-id="cje6pjw16001yweyx6oim5asw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C/">C/C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cjdns/">cjdns</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cjdns源码分析/">cjdns源码分析</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-cjdns-cryptoauth" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/05/cjdns-cryptoauth/" class="article-date">
  <time datetime="2017-09-05T04:48:21.000Z" itemprop="datePublished">2017-09-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/cjdns/">cjdns</a>►<a class="article-category-link" href="/categories/cjdns/cjdns源码分析/">cjdns源码分析</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/05/cjdns-cryptoauth/">cjdns源码分析--CryptoAuth</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="接入点conf分析"><a href="#接入点conf分析" class="headerlink" title="接入点conf分析"></a>接入点conf分析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">&quot;authorizedPasswords&quot;:[</div><div class="line">	&#123;</div><div class="line">		&quot;user&quot;:&quot;a&quot;,</div><div class="line">		&quot;password&quot;:&quot;R9q7eEn3i9YTOB0zITKLMBpwEghxPH6&quot;,</div><div class="line">           &quot;ipv6&quot;:&quot;fbdb:b56d:fdcf:c2ae:5f0b:0cdd:67b4:8f8b&quot;</div><div class="line">	&#125;,</div><div class="line">	&#123;</div><div class="line">		&quot;user&quot;:&quot;a&quot;,</div><div class="line">		&quot;password&quot;:&quot;R9q7eEn3i9YTOB0zITKLMBpwEghxPH7&quot;</div><div class="line">	&#125;,</div><div class="line">	&#123;</div><div class="line">		&quot;user&quot;:&quot;b&quot;,</div><div class="line">		&quot;password&quot;:&quot;R9q7eEn3i9YTOB0zITKLMBpwEghxPH7&quot;</div><div class="line">	&#125;,</div><div class="line">	&#123;</div><div class="line">		&quot;user&quot;:&quot;c&quot;,</div><div class="line">		&quot;password&quot;:&quot;R9q7eEn3i9YTOB0zITKLMBpwEghxPH8&quot;</div><div class="line">	&#125;,</div><div class="line">	&#123;</div><div class="line">		&quot;password&quot;:&quot;R9q7eEn3i9YTOB0zITKLMBpwEghxPH9&quot;</div><div class="line">	&#125;,</div><div class="line">	&#123;</div><div class="line">		&quot;user&quot;:&quot;a&quot;,</div><div class="line">		&quot;password&quot;:&quot;R9q7eEn3i9YTOB0zITKLMBpwEghxPHa&quot;</div><div class="line">	&#125;,</div><div class="line">],</div></pre></td></tr></table></figure>
<p>接入点的conf中可以多个authorizedPasswords，每个authorizedPasswords必须有password,可以有user和ipv6.其中，password和user都是其他点连接过来时，用来验证身份的。ipv6是允许来连接我的点的ipv6.<br>从这个conf中可以看出，user，password，ipv6都是可以重复的。</p>
<h2 id="对conf的解析"><a href="#对conf的解析" class="headerlink" title="对conf的解析"></a>对conf的解析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">static void authorizedPasswords(List* list, struct Context* ctx)</div><div class="line">&#123;</div><div class="line">    uint32_t count = List_size(list);</div><div class="line">    for (uint32_t i = 0; i &lt; count; i++) &#123;</div><div class="line">        Dict* d = List_getDict(list, i);</div><div class="line">        Log_info(ctx-&gt;logger, &quot;Checking authorized password %d.&quot;, i);</div><div class="line">        if (!d) &#123;</div><div class="line">            Log_critical(ctx-&gt;logger, &quot;Not a dictionary type %d.&quot;, i);</div><div class="line">            exit(-1);</div><div class="line">        &#125;</div><div class="line">        String* passwd = Dict_getStringC(d, &quot;password&quot;);</div><div class="line">        if (!passwd) &#123;</div><div class="line">            Log_critical(ctx-&gt;logger, &quot;Must specify a password %d.&quot;, i);</div><div class="line">            exit(-1);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for (uint32_t i = 0; i &lt; count; i++) &#123;</div><div class="line">        struct Allocator* child = Allocator_child(ctx-&gt;alloc);</div><div class="line">        Dict* d = List_getDict(list, i);</div><div class="line">        String* passwd = Dict_getStringC(d, &quot;password&quot;);</div><div class="line">        String* user = Dict_getStringC(d, &quot;user&quot;);</div><div class="line">        String* displayName = user;</div><div class="line">        if (!displayName) &#123;</div><div class="line">            displayName = String_printf(child, &quot;password [%d]&quot;, i);</div><div class="line">        &#125;</div><div class="line">        //String* publicKey = Dict_getStringC(d, &quot;publicKey&quot;);</div><div class="line">        String* ipv6 = Dict_getStringC(d, &quot;ipv6&quot;);</div><div class="line">        Log_info(ctx-&gt;logger, &quot;Adding authorized password #[%d] for user [%s].&quot;,</div><div class="line">            i, displayName-&gt;bytes);</div><div class="line">        Dict *args = Dict_new(child);</div><div class="line">        uint32_t i = 1;</div><div class="line">        Dict_putIntC(args, &quot;authType&quot;, i, child);</div><div class="line">        Dict_putStringC(args, &quot;password&quot;, passwd, child);</div><div class="line">        if (user) &#123;</div><div class="line">            Dict_putStringC(args, &quot;user&quot;, user, child);</div><div class="line">        &#125;</div><div class="line">        Dict_putStringC(args, &quot;displayName&quot;, displayName, child);</div><div class="line">        if (ipv6) &#123;</div><div class="line">            Log_info(ctx-&gt;logger,</div><div class="line">                &quot;  This connection password restricted to [%s] only.&quot;, ipv6-&gt;bytes);</div><div class="line">            Dict_putStringC(args, &quot;ipv6&quot;, ipv6, child);</div><div class="line">        &#125;</div><div class="line">        rpcCall(String_CONST(&quot;add_pass&quot;), args, ctx, child);</div><div class="line">        Allocator_free(child);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>第一个for循环中，检查了一下格式，以及必须有password。</li>
<li>第二个for循环中，获取各项参数，然后put到Dict中，并通过rpcCall调用add_pass。<br>  可以看到，put的参数除了从conf中取到的password,user,ipv6之外，还有authType,displayName,不过没什么用，因为add_pass中并没有处理这些值。</li>
</ul>
<h2 id="add-pass方法的分析"><a href="#add-pass方法的分析" class="headerlink" title="add_pass方法的分析"></a>add_pass方法的分析</h2><p>admin/AuthorizedPasswords.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">void AuthorizedPasswords_init(struct Admin* admin,</div><div class="line">                              struct CryptoAuth* ca,</div><div class="line">                              struct Allocator* allocator)</div><div class="line">&#123;</div><div class="line">...</div><div class="line">    Admin_registerFunction(&quot;add_pass&quot;, add, context, true,</div><div class="line">        ((struct Admin_FunctionArg[])&#123;</div><div class="line">            &#123; .name = &quot;password&quot;, .required = 1, .type = &quot;String&quot; &#125;,</div><div class="line">            &#123; .name = &quot;ipv6&quot;, .required = 0, .type = &quot;String&quot; &#125;,</div><div class="line">            &#123; .name = &quot;user&quot;, .required = 0, .type = &quot;String&quot; &#125;</div><div class="line">        &#125;), admin);</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从requited的值可以看出，只有password是必须的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">static void add(Dict* args, void* vcontext, String* txid, struct Allocator* alloc)</div><div class="line">&#123;</div><div class="line">    struct Context* context = Identity_check((struct Context*) vcontext);</div><div class="line"></div><div class="line">    String* passwd = Dict_getStringC(args, &quot;password&quot;);</div><div class="line">    String* user = Dict_getStringC(args, &quot;user&quot;);</div><div class="line">    String* ipv6 = Dict_getStringC(args, &quot;ipv6&quot;);</div><div class="line"></div><div class="line">    uint8_t ipv6Bytes[16];</div><div class="line">    uint8_t* ipv6Arg;</div><div class="line">    if (!ipv6) &#123;</div><div class="line">        ipv6Arg = NULL;</div><div class="line">    &#125; else if (AddrTools_parseIp(ipv6Bytes, ipv6-&gt;bytes)) &#123;</div><div class="line">        sendResponse(String_CONST(&quot;Invalid IPv6 Address&quot;), context-&gt;admin, txid, alloc);</div><div class="line">        return;</div><div class="line">    &#125; else &#123;</div><div class="line">        ipv6Arg = ipv6Bytes;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    int32_t ret = CryptoAuth_addUser_ipv6(passwd, user, ipv6Arg, context-&gt;ca);</div><div class="line"></div><div class="line">    switch (ret) &#123;</div><div class="line">        case 0:</div><div class="line">            sendResponse(String_CONST(&quot;none&quot;), context-&gt;admin, txid, alloc);</div><div class="line">            break;</div><div class="line">        case CryptoAuth_addUser_DUPLICATE:</div><div class="line">            sendResponse(String_CONST(&quot;Password already added.&quot;), context-&gt;admin, txid, alloc);</div><div class="line">            break;</div><div class="line">        default:</div><div class="line">            sendResponse(String_CONST(&quot;Unknown error.&quot;), context-&gt;admin, txid, alloc);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>调用CryptoAuth_addUser_ipv6,在CryptoAuth.c中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">int CryptoAuth_addUser_ipv6(String* password,</div><div class="line">                            String* login,</div><div class="line">                            uint8_t ipv6[16],</div><div class="line">                            struct CryptoAuth* cryptoAuth)</div><div class="line">&#123;</div><div class="line">    struct CryptoAuth_pvt* ca = Identity_check((struct CryptoAuth_pvt*) cryptoAuth);</div><div class="line"></div><div class="line">    struct Allocator* alloc = Allocator_child(ca-&gt;allocator);</div><div class="line">    struct CryptoAuth_User* user = Allocator_calloc(alloc, sizeof(struct CryptoAuth_User), 1);</div><div class="line">    user-&gt;alloc = alloc;</div><div class="line">    Identity_set(user);</div><div class="line"></div><div class="line">    if (!login) &#123;</div><div class="line">        int i = 0;</div><div class="line">        for (struct CryptoAuth_User* u = ca-&gt;users; u; u = u-&gt;next) &#123; i++; &#125;</div><div class="line">        user-&gt;login = login = String_printf(alloc, &quot;Anon #%d&quot;, i);</div><div class="line">    &#125; else &#123;</div><div class="line">        user-&gt;login = String_clone(login, alloc);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    struct CryptoHeader_Challenge ac;</div><div class="line">    // Users specified with a login field might want to use authType 1 still.</div><div class="line">    hashPassword(user-&gt;secret, &amp;ac, login, password, 2);</div><div class="line">    Bits_memcpy(user-&gt;userNameHash, &amp;ac, CryptoHeader_Challenge_KEYSIZE);</div><div class="line">    hashPassword(user-&gt;secret, &amp;ac, NULL, password, 1);</div><div class="line">    Bits_memcpy(user-&gt;passwordHash, &amp;ac, CryptoHeader_Challenge_KEYSIZE);</div><div class="line"></div><div class="line">    for (struct CryptoAuth_User* u = ca-&gt;users; u; u = u-&gt;next) &#123;</div><div class="line">        if (Bits_memcmp(user-&gt;secret, u-&gt;secret, 32)) &#123;</div><div class="line">        &#125; else if (!login) &#123;</div><div class="line">        &#125; else if (String_equals(login, u-&gt;login)) &#123;</div><div class="line">            Allocator_free(alloc);</div><div class="line">            return CryptoAuth_addUser_DUPLICATE;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (ipv6) &#123;</div><div class="line">        Bits_memcpy(user-&gt;restrictedToip6, ipv6, 16);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Add the user to the *end* of the list</div><div class="line">    for (struct CryptoAuth_User** up = &amp;ca-&gt;users; ; up = &amp;(*up)-&gt;next) &#123;</div><div class="line">        if (!*up) &#123;</div><div class="line">            *up = user;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>按照空行分成六块，逐块分析：</p>
<ol>
<li><p>结构体CryptoAuth_User的初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">struct CryptoAuth_pvt* ca = Identity_check((struct CryptoAuth_pvt*) cryptoAuth);</div><div class="line"></div><div class="line">struct Allocator* alloc = Allocator_child(ca-&gt;allocator);</div><div class="line">struct CryptoAuth_User* user = Allocator_calloc(alloc, sizeof(struct CryptoAuth_User), 1);</div><div class="line">user-&gt;alloc = alloc;</div><div class="line">Identity_set(user);</div></pre></td></tr></table></figure>
</li>
<li><p>设置login</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">if (!login) &#123;</div><div class="line">    int i = 0;</div><div class="line">    for (struct CryptoAuth_User* u = ca-&gt;users; u; u = u-&gt;next) &#123; i++; &#125;</div><div class="line">    user-&gt;login = login = String_printf(alloc, &quot;Anon #%d&quot;, i);</div><div class="line">&#125; else &#123;</div><div class="line">    user-&gt;login = String_clone(login, alloc);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>如果conf中有user，使用它当作login，否则自动生成一个“Anon”开头的login</p>
<ol>
<li><p>计算secret,userNameHash,passwordHash,并赋值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">struct CryptoHeader_Challenge ac;</div><div class="line">// Users specified with a login field might want to use authType 1 still.</div><div class="line">hashPassword(user-&gt;secret, &amp;ac, login, password, 2);</div><div class="line">Bits_memcpy(user-&gt;userNameHash, &amp;ac, CryptoHeader_Challenge_KEYSIZE);</div><div class="line">hashPassword(user-&gt;secret, &amp;ac, NULL, password, 1);</div><div class="line">Bits_memcpy(user-&gt;passwordHash, &amp;ac, CryptoHeader_Challenge_KEYSIZE);</div></pre></td></tr></table></figure>
</li>
<li><p>检查合法性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">for (struct CryptoAuth_User* u = ca-&gt;users; u; u = u-&gt;next) &#123;</div><div class="line">       if (Bits_memcmp(user-&gt;secret, u-&gt;secret, 32)) &#123;</div><div class="line">       &#125; else if (!login) &#123;</div><div class="line">       &#125; else if (String_equals(login, u-&gt;login)) &#123;</div><div class="line">           Allocator_free(alloc);</div><div class="line">           return CryptoAuth_addUser_DUPLICATE;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>当user和password同时与已有的某个user相同时，会报错：CryptoAuth_addUser_DUPLICATE</p>
<ol>
<li>如果有ipv6，设置到restrictedToip6中<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (ipv6) &#123;</div><div class="line">    Bits_memcpy(user-&gt;restrictedToip6, ipv6, 16);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这个设置可以限制只有某个ipv6才能使用这个user进行验证。也就是说，这个ipv6是连接过来的普通点的ipv6。</p>
<ol>
<li>把这个CryptoAuth_User加到列表的最后<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// Add the user to the *end* of the list</div><div class="line">for (struct CryptoAuth_User** up = &amp;ca-&gt;users; ; up = &amp;(*up)-&gt;next) &#123;</div><div class="line">    if (!*up) &#123;</div><div class="line">        *up = user;</div><div class="line">        break;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="普通点conf分析"><a href="#普通点conf分析" class="headerlink" title="普通点conf分析"></a>普通点conf分析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&quot;connectTo&quot;:&#123;</div><div class="line">	&quot;192.168.2.43:26808&quot;:&#123;</div><div class="line">    	&quot;login&quot;:&quot;c&quot;,</div><div class="line">        &quot;password&quot;:&quot;R9q7eEn3i9YTOB0zITKLMBpwEghxPH6&quot;,</div><div class="line">        &quot;publicKey&quot;:&quot;cy4cmzzry3yykwblnh402vmyt328pu9nm58rx4cbgnqllv6hvv70.k&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>“192.168.2.43:26808”:要连接的点的ipv4地址和端口</li>
<li>“publicKey”:要连接的点的publickey</li>
<li>“password”:要连接的点配置的password</li>
<li>“login”：要连接的点配置的login，在连接点的conf中，是user字段</li>
</ul>
<h2 id="普通点配置连接点的分析"><a href="#普通点配置连接点的分析" class="headerlink" title="普通点配置连接点的分析"></a>普通点配置连接点的分析</h2><p>从Configurator.c中通过rpcCall调用udp_conn。<br>直接从udp_conn开始分析<br>interface/UDPInterface_admin.c中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Admin_registerFunction(&quot;udp_conn&quot;, beginConnection, ctx, true,</div><div class="line">    ((struct Admin_FunctionArg[]) &#123;</div><div class="line">        &#123; .name = &quot;interfaceNumber&quot;, .required = 0, .type = &quot;Int&quot; &#125;,</div><div class="line">        &#123; .name = &quot;password&quot;, .required = 0, .type = &quot;String&quot; &#125;,</div><div class="line">        &#123; .name = &quot;publicKey&quot;, .required = 1, .type = &quot;String&quot; &#125;,</div><div class="line">        &#123; .name = &quot;address&quot;, .required = 1, .type = &quot;String&quot; &#125;,</div><div class="line">        &#123; .name = &quot;login&quot;, .required = 0, .type = &quot;String&quot; &#125;</div><div class="line">    &#125;), admin);</div></pre></td></tr></table></figure></p>
<p>interfaceNumber并未在conf中出现<br>password是conf中的password<br>publicKey是conf中的publicKey<br>address是conf中的”192.168.2.43:26808”<br>login是conf中的login<br>可以看出，只有publicKey和address是必须的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line">static void beginConnection(Dict* args,</div><div class="line">                            void* vcontext,</div><div class="line">                            String* txid,</div><div class="line">                            struct Allocator* requestAlloc)</div><div class="line">&#123;</div><div class="line">    struct Context* ctx = vcontext;</div><div class="line"></div><div class="line">    String* password = Dict_getStringC(args, &quot;password&quot;);</div><div class="line">    String* login = Dict_getStringC(args, &quot;login&quot;);</div><div class="line">    String* publicKey = Dict_getStringC(args, &quot;publicKey&quot;);</div><div class="line">    String* address = Dict_getStringC(args, &quot;address&quot;);</div><div class="line">    int64_t* interfaceNumber = Dict_getIntC(args, &quot;interfaceNumber&quot;);</div><div class="line">    uint32_t ifNum = (interfaceNumber) ? ((uint32_t) *interfaceNumber) : 0;</div><div class="line">    String* peerName = Dict_getStringC(args, &quot;peerName&quot;);</div><div class="line">    String* error = NULL;</div><div class="line"></div><div class="line">    Log_debug(ctx-&gt;logger, &quot;Peering with [%s]&quot;, publicKey-&gt;bytes);</div><div class="line"></div><div class="line">    struct Sockaddr_storage ss;</div><div class="line">    uint8_t pkBytes[32];</div><div class="line">    int ret;</div><div class="line">    if (interfaceNumber &amp;&amp; *interfaceNumber &lt; 0) &#123;</div><div class="line">        error = String_CONST(&quot;negative interfaceNumber&quot;);</div><div class="line"></div><div class="line">    &#125; else if ((ret = Key_parse(publicKey, pkBytes, NULL))) &#123;</div><div class="line">        error = String_CONST(Key_parse_strerror(ret));</div><div class="line"></div><div class="line">    &#125; else if (Sockaddr_parse(address-&gt;bytes, &amp;ss)) &#123;</div><div class="line">        error = String_CONST(&quot;unable to parse ip address and port.&quot;);</div><div class="line"></div><div class="line">    &#125; else if (Sockaddr_getFamily(&amp;ss.addr) != Sockaddr_getFamily(ctx-&gt;udpIf-&gt;addr)) &#123;</div><div class="line">        error = String_CONST(&quot;different address type than this socket is bound to.&quot;);</div><div class="line"></div><div class="line">    &#125; else &#123;</div><div class="line"></div><div class="line">        struct Sockaddr* addr = &amp;ss.addr;</div><div class="line">        char* addrPtr = NULL;</div><div class="line">        int addrLen = Sockaddr_getAddress(&amp;ss.addr, &amp;addrPtr);</div><div class="line">        Assert_true(addrLen &gt; 0);</div><div class="line">        struct Allocator* tempAlloc = Allocator_child(ctx-&gt;alloc);</div><div class="line">        if (Bits_isZero(addrPtr, addrLen)) &#123;</div><div class="line">            // unspec&apos;d address, convert to loopback</div><div class="line">            if (Sockaddr_getFamily(addr) == Sockaddr_AF_INET) &#123;</div><div class="line">                addr = Sockaddr_clone(Sockaddr_LOOPBACK, tempAlloc);</div><div class="line">            &#125; else if (Sockaddr_getFamily(addr) == Sockaddr_AF_INET6) &#123;</div><div class="line">                addr = Sockaddr_clone(Sockaddr_LOOPBACK6, tempAlloc);</div><div class="line">            &#125; else &#123;</div><div class="line">                Assert_failure(&quot;Sockaddr which is not AF_INET nor AF_INET6&quot;);</div><div class="line">            &#125;</div><div class="line">            Sockaddr_setPort(addr, Sockaddr_getPort(&amp;ss.addr));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        int ret = InterfaceController_bootstrapPeer(</div><div class="line">            ctx-&gt;ic, ifNum, pkBytes, addr, password, login, peerName, ctx-&gt;alloc);</div><div class="line"></div><div class="line">        Allocator_free(tempAlloc);</div><div class="line"></div><div class="line">        if (ret) &#123;</div><div class="line">            switch(ret) &#123;</div><div class="line">                case InterfaceController_bootstrapPeer_BAD_IFNUM:</div><div class="line">                    error = String_CONST(&quot;no such interface for interfaceNumber&quot;);</div><div class="line">                    break;</div><div class="line"></div><div class="line">                case InterfaceController_bootstrapPeer_BAD_KEY:</div><div class="line">                    error = String_CONST(&quot;invalid public key.&quot;);</div><div class="line">                    break;</div><div class="line"></div><div class="line">                case InterfaceController_bootstrapPeer_OUT_OF_SPACE:</div><div class="line">                    error = String_CONST(&quot;no more space to register with the switch.&quot;);</div><div class="line">                    break;</div><div class="line"></div><div class="line">                default:</div><div class="line">                    error = String_CONST(&quot;unknown error&quot;);</div><div class="line">                    break;</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            error = String_CONST(&quot;none&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Dict out = Dict_CONST(String_CONST(&quot;error&quot;), String_OBJ(error), NULL);</div><div class="line">    Admin_sendMessage(&amp;out, txid, ctx-&gt;admin);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先看从dict中取出的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">String* password = Dict_getStringC(args, &quot;password&quot;);</div><div class="line">String* login = Dict_getStringC(args, &quot;login&quot;);</div><div class="line">String* publicKey = Dict_getStringC(args, &quot;publicKey&quot;);</div><div class="line">String* address = Dict_getStringC(args, &quot;address&quot;);</div><div class="line">int64_t* interfaceNumber = Dict_getIntC(args, &quot;interfaceNumber&quot;);</div><div class="line">uint32_t ifNum = (interfaceNumber) ? ((uint32_t) *interfaceNumber) : 0;</div><div class="line">String* peerName = Dict_getStringC(args, &quot;peerName&quot;);</div></pre></td></tr></table></figure></p>
<p>password,login,publicKey,address是conf里面写了的<br>interfaceNumber,peerName根本没有，也就是为空。</p>
<p>之后用if else做了一些参数合法性检查。<br>最有一个else开始配置连接点的操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">    struct Sockaddr* addr = &amp;ss.addr;</div><div class="line">    char* addrPtr = NULL;</div><div class="line">    int addrLen = Sockaddr_getAddress(&amp;ss.addr, &amp;addrPtr);</div><div class="line">    Assert_true(addrLen &gt; 0);</div><div class="line">    struct Allocator* tempAlloc = Allocator_child(ctx-&gt;alloc);</div><div class="line">    if (Bits_isZero(addrPtr, addrLen)) &#123;</div><div class="line">        // unspec&apos;d address, convert to loopback</div><div class="line">        if (Sockaddr_getFamily(addr) == Sockaddr_AF_INET) &#123;</div><div class="line">            addr = Sockaddr_clone(Sockaddr_LOOPBACK, tempAlloc);</div><div class="line">        &#125; else if (Sockaddr_getFamily(addr) == Sockaddr_AF_INET6) &#123;</div><div class="line">            addr = Sockaddr_clone(Sockaddr_LOOPBACK6, tempAlloc);</div><div class="line">        &#125; else &#123;</div><div class="line">            Assert_failure(&quot;Sockaddr which is not AF_INET nor AF_INET6&quot;);</div><div class="line">        &#125;</div><div class="line">        Sockaddr_setPort(addr, Sockaddr_getPort(&amp;ss.addr));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    int ret = InterfaceController_bootstrapPeer(</div><div class="line">        ctx-&gt;ic, ifNum, pkBytes, addr, password, login, peerName, ctx-&gt;alloc);</div><div class="line"></div><div class="line">    Allocator_free(tempAlloc);</div><div class="line"></div><div class="line">    if (ret) &#123;</div><div class="line">        switch(ret) &#123;</div><div class="line">            case InterfaceController_bootstrapPeer_BAD_IFNUM:</div><div class="line">                error = String_CONST(&quot;no such interface for interfaceNumber&quot;);</div><div class="line">                break;</div><div class="line"></div><div class="line">            case InterfaceController_bootstrapPeer_BAD_KEY:</div><div class="line">                error = String_CONST(&quot;invalid public key.&quot;);</div><div class="line">                break;</div><div class="line"></div><div class="line">            case InterfaceController_bootstrapPeer_OUT_OF_SPACE:</div><div class="line">                error = String_CONST(&quot;no more space to register with the switch.&quot;);</div><div class="line">                break;</div><div class="line"></div><div class="line">            default:</div><div class="line">                error = String_CONST(&quot;unknown error&quot;);</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        error = String_CONST(&quot;none&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>核心代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int ret = InterfaceController_bootstrapPeer(</div><div class="line">    ctx-&gt;ic, ifNum, pkBytes, addr, password, login, peerName, ctx-&gt;alloc);</div></pre></td></tr></table></figure></p>
<p>查看这个方法,在net/InterfaceController.c,只看和CryptoAuth相关的部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">int InterfaceController_bootstrapPeer(struct InterfaceController* ifc,</div><div class="line">                                      int interfaceNumber,</div><div class="line">                                      uint8_t* herPublicKey,</div><div class="line">                                      const struct Sockaddr* lladdrParm,</div><div class="line">                                      String* password,</div><div class="line">                                      String* login,</div><div class="line">                                      String* user,</div><div class="line">                                      struct Allocator* alloc)</div><div class="line">&#123;</div><div class="line">......</div><div class="line">    ep-&gt;caSession = CryptoAuth_newSession(ic-&gt;ca, epAlloc, herPublicKey, false, &quot;outer&quot;);</div><div class="line">    CryptoAuth_setAuth(password, login, ep-&gt;caSession);</div><div class="line">    if (user) &#123;</div><div class="line">        ep-&gt;caSession-&gt;displayName = String_clone(user, epAlloc);</div><div class="line">    &#125;</div><div class="line">......</div><div class="line"></div><div class="line">    // We can&apos;t just add the node directly to the routing table because we do not know</div><div class="line">    // the version. We&apos;ll send it a switch ping and when it responds, we will know it&apos;s</div><div class="line">    // key (if we don&apos;t already) and version number.</div><div class="line">    sendPing(ep);</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>CryptoAuth_newSession并没有设置password</li>
<li>调用了CryptoAuth_setAuth</li>
<li>user为空，所以没有设置ep-&gt;caSession-&gt;displayName</li>
<li>最后sendPing连接点。<br>主要看一下CryptoAuth_setAuth,在crypto/CryptoAuth.c<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">void CryptoAuth_setAuth(const String* password,</div><div class="line">                        const String* login,</div><div class="line">                        struct CryptoAuth_Session* caSession)</div><div class="line">&#123;</div><div class="line">    struct CryptoAuth_Session_pvt* session =</div><div class="line">        Identity_check((struct CryptoAuth_Session_pvt*)caSession);</div><div class="line"></div><div class="line">    if (!password &amp;&amp; (session-&gt;password || session-&gt;authType)) &#123;</div><div class="line">        session-&gt;password = NULL;</div><div class="line">        session-&gt;authType = 0;</div><div class="line">    &#125; else if (!session-&gt;password || !String_equals(session-&gt;password, password)) &#123;</div><div class="line">        session-&gt;password = String_clone(password, session-&gt;alloc);</div><div class="line">        session-&gt;authType = 1;</div><div class="line">        if (login) &#123;</div><div class="line">            session-&gt;authType = 2;</div><div class="line">            session-&gt;login = String_clone(login, session-&gt;alloc);</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    reset(session);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>会进入到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">else if (!session-&gt;password || !String_equals(session-&gt;password, password)) &#123;</div><div class="line">       session-&gt;password = String_clone(password, session-&gt;alloc);</div><div class="line">       session-&gt;authType = 1;</div><div class="line">       if (login) &#123;</div><div class="line">           session-&gt;authType = 2;</div><div class="line">           session-&gt;login = String_clone(login, session-&gt;alloc);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>将password设置到session-&gt;password</li>
<li>如果有login，authType为2，否则为1.也就是说，如果conf中有login（对应着连接点conf中的user字段），使用验证login的方法，否则使用验证password的方法。这个区分，在后面会具体分析。</li>
<li>如果有login，login设置到session-&gt;login</li>
</ol>
<h2 id="连接点验证一个新来的点的身份是否合格"><a href="#连接点验证一个新来的点的身份是否合格" class="headerlink" title="连接点验证一个新来的点的身份是否合格"></a>连接点验证一个新来的点的身份是否合格</h2><p>验证的核心方法是crypto/AryptoAuth.c中的一个内部方法getAuth.<br>调用链为：net/InterfaceController.c的handleUnexpectedIncoming<br>–&gt; net/InterfaceController.c的CADecryptAndNotify<br>–&gt; crypto/AryptoAuth.c的CryptoAuth_getAuth<br>–&gt; crypto/AryptoAuth.c的getAuth<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">static inline struct CryptoAuth_User* getAuth(struct CryptoHeader_Challenge* auth,</div><div class="line">                                              struct CryptoAuth_pvt* ca)</div><div class="line">&#123;</div><div class="line">    if (auth-&gt;type == 0) &#123;</div><div class="line">        return NULL;</div><div class="line">    &#125;</div><div class="line">    int count = 0;</div><div class="line"></div><div class="line">    for (struct CryptoAuth_User* u = ca-&gt;users; u; u = u-&gt;next) &#123;</div><div class="line">        count++;</div><div class="line">        if (auth-&gt;type == 1 &amp;&amp;</div><div class="line">            !Bits_memcmp(auth, u-&gt;passwordHash, CryptoHeader_Challenge_KEYSIZE))</div><div class="line">        &#123;</div><div class="line">            return u;</div><div class="line">        &#125; else if (auth-&gt;type == 2 &amp;&amp;</div><div class="line">            !Bits_memcmp(auth, u-&gt;userNameHash, CryptoHeader_Challenge_KEYSIZE))</div><div class="line">        &#123;</div><div class="line">            return u;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    Log_debug(ca-&gt;logger, &quot;Got unrecognized auth, password count = [%d]&quot;, count);</div><div class="line">    return NULL;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>根据auth-&gt;type来决定验证username（login）还是验证password</p>
<h2 id="API分析"><a href="#API分析" class="headerlink" title="API分析"></a>API分析</h2><p>admin/AuthorizedPasswords.c，四个API，因branch不同，API名称可能有不同。</p>
<h3 id="AuthorizedPasswords-add-或-add-pass"><a href="#AuthorizedPasswords-add-或-add-pass" class="headerlink" title="AuthorizedPasswords_add 或 add_pass"></a>AuthorizedPasswords_add 或 add_pass</h3><p>已经在上面分析过</p>
<h3 id="AuthorizedPasswords-remove-或-rm-pass"><a href="#AuthorizedPasswords-remove-或-rm-pass" class="headerlink" title="AuthorizedPasswords_remove 或 rm_pass"></a>AuthorizedPasswords_remove 或 rm_pass</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Admin_registerFunction(&quot;AuthorizedPasswords_remove&quot;, remove, context, true,</div><div class="line">    ((struct Admin_FunctionArg[])&#123;</div><div class="line">        &#123; .name = &quot;user&quot;, .required = 1, .type = &quot;String&quot; &#125;</div><div class="line">    &#125;), admin);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">static void remove(Dict* args, void* vcontext, String* txid, struct Allocator* requestAlloc)</div><div class="line">&#123;</div><div class="line">    struct Context* context = Identity_check((struct Context*) vcontext);</div><div class="line">    String* user = Dict_getStringC(args, &quot;user&quot;);</div><div class="line"></div><div class="line">    int32_t ret = CryptoAuth_removeUsers(context-&gt;ca, user);</div><div class="line">    if (ret) &#123;</div><div class="line">        sendResponse(String_CONST(&quot;none&quot;), context-&gt;admin, txid, requestAlloc);</div><div class="line">    &#125; else &#123;</div><div class="line">        sendResponse(String_CONST(&quot;Unknown error.&quot;), context-&gt;admin, txid, requestAlloc);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>CryptoAuth.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">int CryptoAuth_removeUsers(struct CryptoAuth* context, String* login)</div><div class="line">&#123;</div><div class="line">    struct CryptoAuth_pvt* ca = Identity_check((struct CryptoAuth_pvt*) context);</div><div class="line"></div><div class="line">    int count = 0;</div><div class="line">    struct CryptoAuth_User** up = &amp;ca-&gt;users;</div><div class="line">    struct CryptoAuth_User* u = *up;</div><div class="line">    while ((u = *up)) &#123;</div><div class="line">        if (!login || String_equals(login, u-&gt;login)) &#123;</div><div class="line">            *up = u-&gt;next;</div><div class="line">            Allocator_free(u-&gt;alloc);</div><div class="line">            count++;</div><div class="line">        &#125; else &#123;</div><div class="line">            up = &amp;u-&gt;next;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (!login) &#123;</div><div class="line">        Log_debug(ca-&gt;logger, &quot;Flushing [%d] users&quot;, count);</div><div class="line">    &#125; else &#123;</div><div class="line">        Log_debug(ca-&gt;logger, &quot;Removing [%d] user(s) identified by [%s]&quot;, count, login-&gt;bytes);</div><div class="line">    &#125;</div><div class="line">    return count;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意两点：</p>
<ol>
<li>while循环很好的在删除的同时维护好了list链表的结构</li>
<li>当login为空时，也就意味着将所有user都删除了</li>
</ol>
<h3 id="AuthorizedPasswords-remove-或-rm-pass-1"><a href="#AuthorizedPasswords-remove-或-rm-pass-1" class="headerlink" title="AuthorizedPasswords_remove 或 rm_pass"></a>AuthorizedPasswords_remove 或 rm_pass</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Admin_registerFunction(&quot;AuthorizedPasswords_remove_by_pwd&quot;, removeByPwd, context, true,</div><div class="line">    ((struct Admin_FunctionArg[])&#123;</div><div class="line">        &#123; .name = &quot;password&quot;, .required = 1, .type = &quot;String&quot; &#125;</div><div class="line">    &#125;), admin);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">static void removeByPwd(Dict* args, void* vcontext, String* txid, struct Allocator* requestAlloc)</div><div class="line">&#123;</div><div class="line">    struct Context* context = Identity_check((struct Context*) vcontext);</div><div class="line">    String* password = Dict_getStringC(args, &quot;password&quot;);</div><div class="line"></div><div class="line">    int32_t ret = CryptoAuth_removeUsers_pwd(context-&gt;ca, password);</div><div class="line">    if (ret) &#123;</div><div class="line">        sendResponse(String_CONST(&quot;none&quot;), context-&gt;admin, txid, requestAlloc);</div><div class="line">    &#125; else &#123;</div><div class="line">        sendResponse(String_CONST(&quot;Unknown error.&quot;), context-&gt;admin, txid, requestAlloc);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>CryptoAuth.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">static bool secretEquals(String* password, uint8_t userSecret[32])</div><div class="line">&#123;</div><div class="line">    uint8_t pwdSecret[32];</div><div class="line">    crypto_hash_sha256(pwdSecret, (uint8_t*) password-&gt;bytes, password-&gt;len);</div><div class="line">    return !(Bits_memcmp(pwdSecret, userSecret, 32));</div><div class="line">&#125;</div><div class="line"></div><div class="line">int CryptoAuth_removeUsers_pwd(struct CryptoAuth* context, String* password)</div><div class="line">&#123;</div><div class="line">    struct CryptoAuth_pvt* ca = Identity_check((struct CryptoAuth_pvt*) context);</div><div class="line"></div><div class="line">    int count = 0;</div><div class="line">    struct CryptoAuth_User** up = &amp;ca-&gt;users;</div><div class="line">    struct CryptoAuth_User* u = *up;</div><div class="line">    while ((u = *up)) &#123;</div><div class="line">        if (!password || secretEquals(password, u-&gt;secret)) &#123;</div><div class="line">            *up = u-&gt;next;</div><div class="line">            Allocator_free(u-&gt;alloc);</div><div class="line">            count++;</div><div class="line">        &#125; else &#123;</div><div class="line">            up = &amp;u-&gt;next;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (!password) &#123;</div><div class="line">        Log_debug(ca-&gt;logger, &quot;Flushing [%d] users&quot;, count);</div><div class="line">    &#125; else &#123;</div><div class="line">        Log_debug(ca-&gt;logger, &quot;Removing [%d] user(s) identified by [%s]&quot;, count, password-&gt;bytes);</div><div class="line">    &#125;</div><div class="line">    return count;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>比上一个多了一个根据password计算secret的过程，其他并无差别。</p>
<h2 id="AuthorizedPasswords-list-或-ls-pass"><a href="#AuthorizedPasswords-list-或-ls-pass" class="headerlink" title="AuthorizedPasswords_list 或 ls_pass"></a>AuthorizedPasswords_list 或 ls_pass</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Admin_registerFunction(&quot;AuthorizedPasswords_list&quot;, list, context, true, NULL, admin);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">static void list(Dict* args, void* vcontext, String* txid, struct Allocator* requestAlloc)</div><div class="line">&#123;</div><div class="line">    struct Context* context = Identity_check((struct Context*) vcontext);</div><div class="line">    struct Allocator* child = Allocator_child(context-&gt;allocator);</div><div class="line"></div><div class="line">    List* users = CryptoAuth_getUsers(context-&gt;ca, child);</div><div class="line">    uint32_t count = List_size(users);</div><div class="line"></div><div class="line">    Dict response = Dict_CONST(</div><div class="line">        String_CONST(&quot;total&quot;), Int_OBJ(count), Dict_CONST(</div><div class="line">        String_CONST(&quot;users&quot;), List_OBJ(users), NULL</div><div class="line">    ));</div><div class="line"></div><div class="line">    Admin_sendMessage(&amp;response, txid, context-&gt;admin);</div><div class="line"></div><div class="line">    Allocator_free(child);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>CryptoAuth.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">List* CryptoAuth_getUsers(struct CryptoAuth* context, struct Allocator* alloc)</div><div class="line">&#123;</div><div class="line">    struct CryptoAuth_pvt* ca = Identity_check((struct CryptoAuth_pvt*) context);</div><div class="line"></div><div class="line">    List* users = List_new(alloc);</div><div class="line">    for (struct CryptoAuth_User* u = ca-&gt;users; u; u = u-&gt;next) &#123;</div><div class="line">        List_addString(users, String_clone(u-&gt;login, alloc), alloc);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return users;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>返回结果仅列出users的name和users的数量，下面是一个执行结果示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;total&quot;: &quot;5&quot;,</div><div class="line">  &quot;txid&quot;: &quot;3333180639&quot;,</div><div class="line">  &quot;users&quot;: [</div><div class="line">    &quot;a&quot;,</div><div class="line">    &quot;d&quot;,</div><div class="line">    &quot;c&quot;,</div><div class="line">    &quot;a&quot;,</div><div class="line">    &quot;Local Peers&quot;</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/09/05/cjdns-cryptoauth/" data-id="cje6pjw180022weyxjt05eq1r" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C/">C/C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cjdns/">cjdns</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cjdns源码分析/">cjdns源码分析</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-how-to-read-staff" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/04/how-to-read-staff/" class="article-date">
  <time datetime="2017-09-04T13:03:25.000Z" itemprop="datePublished">2017-09-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/music/">music</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/04/how-to-read-staff/">如何看懂五线谱</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="他们长这样"><a href="#他们长这样" class="headerlink" title="他们长这样"></a>他们长这样</h2><p>选择送别这首歌，是因为它旋律简单，同时具有很多典型的乐理知识，适合初级分析。</p>
<h3 id="五线谱"><a href="#五线谱" class="headerlink" title="五线谱"></a>五线谱</h3><p><img src="/assets/img/how-to-read-staff/sbstaff.png" alt="image"></p>
<h3 id="简谱"><a href="#简谱" class="headerlink" title="简谱"></a>简谱</h3><p><img src="/assets/img/how-to-read-staff/sbeasy.jpg" alt="image"></p>
<h2 id="先看简谱"><a href="#先看简谱" class="headerlink" title="先看简谱"></a>先看简谱</h2><p><img src="/assets/img/how-to-read-staff/sbeasy_log.jpg" alt="image"><br>其中包含以下乐理知识：</p>
<h3 id="1-C"><a href="#1-C" class="headerlink" title="1 = C"></a>1 = C</h3><p><img src="/assets/img/how-to-read-staff/gq.jpg" alt="image"><br>乐曲中的基准音1（do）按照中央C的音高演奏和演唱。其他音高依此类推。<br>同样一首曲子，小萌P和小帅T唱出来的音高，常常有差别。就是基准音1（do）的音高不同。<br>曲子想让你把它唱多高，就是靠这个来指示的。</p>
<h3 id="4-4"><a href="#4-4" class="headerlink" title="4/4"></a>4/4</h3><p>这个简称“四四拍”，全称“以四分音符为一拍，每小节四拍”。这是用来表示音乐的相对快慢速度的，（现在不懂这一句没关系）。四分音符表示一个时间长度，我们给它起个代号，叫“一拍”。</p>
<h3 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h3><p>简谱中，每两条竖线之间，是一个小节。在四四拍的乐曲中，每个小节中的音符的时间长度加在一起，是四个一拍，也就是四拍。这就是“每小节四拍”。</p>
<h3 id="音符"><a href="#音符" class="headerlink" title="音符"></a>音符</h3><p>简谱中的音符同时代表着两层意思。</p>
<ul>
<li>音符的音高</li>
<li>音符的时间长度</li>
</ul>
<h4 id="音符的音高"><a href="#音符的音高" class="headerlink" title="音符的音高"></a>音符的音高</h4><p>音符的音高由数字的值和数字头顶或脚下的点（可能不存在点）来决定。<br>举三个例子：</p>
<h5 id="1-只有数字"><a href="#1-只有数字" class="headerlink" title="1. 只有数字"></a>1. 只有数字</h5><p>长亭外的“长”，只有一个数字“5”<br><img src="/assets/img/how-to-read-staff/jtw.jpg" alt="image"><br>这代表中音5（so）</p>
<h5 id="2-数字上方有点"><a href="#2-数字上方有点" class="headerlink" title="2. 数字上方有点"></a>2. 数字上方有点</h5><p>古道边的“道”，有一个数字1，1上面有一个点<br><img src="/assets/img/how-to-read-staff/gdb.jpg" alt="image"><br>这代表高八度的1（do）</p>
<h5 id="3-数字下方有点"><a href="#3-数字下方有点" class="headerlink" title="3. 数字下方有点"></a>3. 数字下方有点</h5><p>山外山的“外”，有一个数字7，7下方有一个点<br><img src="/assets/img/how-to-read-staff/sws.jpg" alt="image"><br>这代表低八度的7（xi）</p>
<h4 id="音符的时间长度"><a href="#音符的时间长度" class="headerlink" title="音符的时间长度"></a>音符的时间长度</h4><p>音符的时间长度，由数字和数字下方的线（可能没有），或者数字右边的点（可能没有），或者数字右边的横线（可能没有）来决定。<br>举四个例子：</p>
<h5 id="1-只有数字-1"><a href="#1-只有数字-1" class="headerlink" title="1. 只有数字"></a>1. 只有数字</h5><p>长亭外的“长”，只有一个数字“5”<br><img src="/assets/img/how-to-read-staff/jtw.jpg" alt="image"><br>这表示，这个音的时间长度是“一拍”。</p>
<h5 id="2-数字下方有线"><a href="#2-数字下方有线" class="headerlink" title="2. 数字下方有线"></a>2. 数字下方有线</h5><p>山外山的“外”，有一个数字7，7下方有一条线<br><img src="/assets/img/how-to-read-staff/sws.jpg" alt="image"><br>数字下方的线表示时间长度除以2，所以，“外”的时间长度是半拍。<br>此外，每条线都代表一次除以2，所以如果一个数字下面有两条线，那么就是两次除以2，时间长度为四分之一拍。<br>以此类推。</p>
<h5 id="3-数字右边有点"><a href="#3-数字右边有点" class="headerlink" title="3. 数字右边有点"></a>3. 数字右边有点</h5><p>夕阳山外山的第一个“山”，有一个数字4，后面有一个点，这个点叫做附点<br><img src="/assets/img/how-to-read-staff/xys.jpg" alt="image"><br>数字右边的点，代表延长数字时间长度的一半，也就是乘以1.5，所以，“山”的时间长度是1.5拍。</p>
<h5 id="4-数字右边有横线"><a href="#4-数字右边有横线" class="headerlink" title="4. 数字右边有横线"></a>4. 数字右边有横线</h5><p>芳草碧连天的“天”，有一个数字2，右边有一条横线<br><img src="/assets/img/how-to-read-staff/t.jpg" alt="image"><br>数字右边的横线，表示延长数字时间长度加一倍，所以，“天“的时间长度是2拍。</p>
<h3 id="一小节内所有音符的时间长度的总和"><a href="#一小节内所有音符的时间长度的总和" class="headerlink" title="一小节内所有音符的时间长度的总和"></a>一小节内所有音符的时间长度的总和</h3><p>还记得四四拍的定义么？“以四分音符为一拍，每小节四拍”<br>在四四拍的乐曲中，一小节内所有音符的时间长度的总和，就是四拍。<br>以下图的四小节为例：<br><img src="/assets/img/how-to-read-staff/xjsjcd.jpg" alt="image"></p>
<ul>
<li>第一小节：1+0.5+0.5+1.5+0.5 = 4</li>
<li>第二小节：1+1+2 = 4</li>
<li>第三小节：1+0.5+0.5+1.5+0.5 = 4</li>
<li>第四小节：3+1 = 4</li>
</ul>
<h3 id="休止符"><a href="#休止符" class="headerlink" title="休止符"></a>休止符</h3><p>数字0表示休止符，在简谱中只有这一种休止符。表示在这一拍中不弹琴，不唱歌，啥都不干。<br><img src="/assets/img/how-to-read-staff/xzf.jpg" alt="image"></p>
<h3 id="再看一遍简谱"><a href="#再看一遍简谱" class="headerlink" title="再看一遍简谱"></a>再看一遍简谱</h3><p><img src="/assets/img/how-to-read-staff/sbeasy.jpg" alt="image"><br>看懂了吧</p>
<h2 id="五线谱-1"><a href="#五线谱-1" class="headerlink" title="五线谱"></a>五线谱</h2><h3 id="五线谱的五条线"><a href="#五线谱的五条线" class="headerlink" title="五线谱的五条线"></a>五线谱的五条线</h3><p>先来看看五线谱本身的样子<br><img src="/assets/img/how-to-read-staff/wxp.jpg" alt="image"><br>五线，四间，九个位置，都可以放音符。当然不止这些，我们还可以在上面下面多画几条线<br><img src="/assets/img/how-to-read-staff/wxp-add.jpg" alt="image"><br>这些加线和加间，也可以放音符。</p>
<h3 id="五线谱的音符"><a href="#五线谱的音符" class="headerlink" title="五线谱的音符"></a>五线谱的音符</h3><p><img src="/assets/img/how-to-read-staff/yf.jpg" alt="image"><br>分为符头，符干，符尾</p>
<ul>
<li>符头是个圆圈，他可能是实心圆圈，也可能是空心圆圈。</li>
<li>符干是条直线，他可能在符头的左边并朝下，也可能在符头的右边并朝上。</li>
<li>符尾是条弯曲的线，符尾可能有多条，也可能一条都没有。符尾在符干的右边，朝上还是朝下，取决于符干的位置。</li>
</ul>
<h3 id="五线谱的谱号"><a href="#五线谱的谱号" class="headerlink" title="五线谱的谱号"></a>五线谱的谱号</h3><p>常见的谱号有</p>
<ul>
<li>高音谱号<br><img src="/assets/img/how-to-read-staff/gyph.jpg" alt="image"><br>使用高音谱号的五线谱，最下面一线的音高是中音3（mi），往上依次升高。</li>
<li>低音谱号<br><img src="/assets/img/how-to-read-staff/dyph.jpg" alt="image"><br>使用低音谱号的五线谱，最上面一线的音高是低音6（la），往下依次降低。</li>
</ul>
<p>具体的音高对应，后面再讲。</p>
<h2 id="简谱和五线谱的对应关系"><a href="#简谱和五线谱的对应关系" class="headerlink" title="简谱和五线谱的对应关系"></a>简谱和五线谱的对应关系</h2><p>熟悉五线谱的基本元素后，来看看简谱与五线谱的对应。依然从音符的音高和时间长度两方面来分析。</p>
<h3 id="音符的音高-1"><a href="#音符的音高-1" class="headerlink" title="音符的音高"></a>音符的音高</h3><p>简谱与五线谱的音高对应关系如下：<br><img src="/assets/img/how-to-read-staff/yg.jpg" alt="image"><br>五线谱的每一线和每一间都代表一个音高。<br>音符的符头在哪里，音符的音高就是哪里。<br>音符的符头在哪里，音符的音高就是哪里。<br>音符的符头在哪里，音符的音高就是哪里。</p>
<h3 id="音符的时间长度-1"><a href="#音符的时间长度-1" class="headerlink" title="音符的时间长度"></a>音符的时间长度</h3><p>不同于简谱中数字加点或者加线的处理方式，五线谱几乎给每种长度的音符都设计了独特的符号。<br><img src="/assets/img/how-to-read-staff/yfall.png" alt="image"><br>以上依次为：<br><img src="/assets/img/how-to-read-staff/yfscb.png" alt="image"></p>
<p>接下来，来看一下不同音符在简谱和五线谱中的不同表示方式：</p>
<h4 id="简谱-1"><a href="#简谱-1" class="headerlink" title="简谱"></a>简谱</h4><p><img src="/assets/img/how-to-read-staff/jpyf.jpg" alt="image"></p>
<h4 id="五线谱-2"><a href="#五线谱-2" class="headerlink" title="五线谱"></a>五线谱</h4><p><img src="/assets/img/how-to-read-staff/wxpyf.jpg" alt="image"><br>还是五线谱音符和休止符好看吧，艺术阿。</p>
<h4 id="休止符-1"><a href="#休止符-1" class="headerlink" title="休止符"></a>休止符</h4><p>鉴于上图中的休止符讲解不清楚，增加一张休止符的具体图片<br><img src="/assets/img/how-to-read-staff/xzfdb.jpg" alt="image"></p>
<h2 id="现在来看看五线谱"><a href="#现在来看看五线谱" class="headerlink" title="现在来看看五线谱"></a>现在来看看五线谱</h2><p><img src="/assets/img/how-to-read-staff/sbstaff.png" alt="image"></p>
<h3 id="第一行"><a href="#第一行" class="headerlink" title="第一行"></a>第一行</h3><p><img src="/assets/img/how-to-read-staff/dyh.jpg" alt="image"></p>
<ul>
<li>第一小节：四分音符5（so）+ 八分音符3（mi）+ 八分音符5（so）+ 二分音符高音1（do）<br>  时间长度：1+0.5+0.5+2 = 4</li>
<li>第二小节：四分音符6（la）+ 四分音符高音1（do）+ 二分音符5（so）<br>  时间长度：1+1+2 = 4</li>
<li>第三小节：四分音符5（so）+ 八分音符1（do）+ 八分音符2（re）+ 四分音符3（mi）+ 八分音符2（re）+ 八分音符1（do）<br>  时间长度：1+0.5+0.5+1+0.5+0.5 = 4</li>
<li>第四小节：全音符2（re）<br>  时间长度：4 = 4<h3 id="第二行"><a href="#第二行" class="headerlink" title="第二行"></a>第二行</h3><img src="/assets/img/how-to-read-staff/deh.jpg" alt="image"></li>
<li>第一小节：四分音符5（so）+ 八分音符3（mi）+ 八分音符5（so）+ 附点四分音符高音1（do）+ 八分音符7（xi）<br>  时间长度：1+0.5+0.5+1.5+0.5 = 4</li>
<li>第二小节：四分音符6（la）+ 四分音符高音1（do）+ 二分音符5（so）<br>  时间长度：1+1+2 = 4</li>
<li>第三小节：四分音符5（so）+ 八分音符2（re）+ 八分音符3（mi）+ 附点四分音符4（fa）+ 八分音符低音7（xi）<br>  时间长度：1+0.5+0.5+1.5+0.5 = 4</li>
<li>第四小节：全音符1（do）<br>  时间长度：4 = 4<h3 id="第三行"><a href="#第三行" class="headerlink" title="第三行"></a>第三行</h3><img src="/assets/img/how-to-read-staff/dsh.jpg" alt="image"></li>
<li>第一小节：四分音符6（la）+ 四分音符高音1（do）+ 二分音符高音1（do）<br>  时间长度：1+1+2 = 4</li>
<li>第二小节：四分音符7（xi）+ 八分音符6（la）+ 八分音符7（xi）+ 二分音符高音1（do）<br>  时间长度：1+0.5+0.5+2 = 4</li>
<li>第三小节：八分音符6（la）+ 八分音符7（xi）+ 八分音符高音1（do）+ 八分音符6（la）+ 八分音符6（la）+ 八分音符5（so）+ 八分音符3（mi）+ 八分音符1（do）<br>  时间长度：0.5+0.5+0.5+0.5+0.5+0.5+0.5+0.5 = 4</li>
<li>第四小节：全音符2（re）<br>  时间长度：4 = 4<h3 id="第四行"><a href="#第四行" class="headerlink" title="第四行"></a>第四行</h3><img src="/assets/img/how-to-read-staff/dsih.jpg" alt="image"></li>
<li>第一小节：四分音符5（so）+ 八分音符3（mi）+ 八分音符5（so）+ 附点四分音符高音1（do）+ 八分音符7（xi）<br>  时间长度：1+0.5+0.5+1.5+0.5 = 4</li>
<li>第二小节：四分音符6（la）+ 四分音符高音1（do）+ 二分音符5（so）<br>  时间长度：1+1+2 = 4</li>
<li>第三小节：四分音符5（so）+ 八分音符2（re）+ 八分音符3（mi）+ 附点四分音符4（fa）+ 八分音符低音7（xi）<br>  时间长度：1+0.5+0.5+1.5+0.5 = 4</li>
<li>第四小节：全音符1（do）<br>  时间长度：4 = 4</li>
</ul>
<p><strong>如果仔细看的话，可以发现前面的简谱和五线谱其实并不完全一样。比如简谱中有休止符，而五线谱中没有。这不重要，下面有个又不太一样的对照版</strong></p>
<h2 id="一个简谱和五线谱的对照版"><a href="#一个简谱和五线谱的对照版" class="headerlink" title="一个简谱和五线谱的对照版"></a>一个简谱和五线谱的对照版</h2><p><img src="/assets/img/how-to-read-staff/sball.jpg" alt="image"></p>
<h2 id="一个复杂的五线谱版"><a href="#一个复杂的五线谱版" class="headerlink" title="一个复杂的五线谱版"></a>一个复杂的五线谱版</h2><p><img src="/assets/img/how-to-read-staff/sbstaff.jpg" alt="image"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/09/04/how-to-read-staff/" data-id="cje6pjw1j002uweyxvxkdm9hg" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/music/">music</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-rom7-0-phone" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/30/rom7-0-phone/" class="article-date">
  <time datetime="2017-08-30T08:40:17.000Z" itemprop="datePublished">2017-08-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Anrom/">Anrom</a>►<a class="article-category-link" href="/categories/Anrom/rom7-0/">rom7.0</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/30/rom7-0-phone/">rom7.0-phone 电话相关</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="自动录音状态"><a href="#自动录音状态" class="headerlink" title="自动录音状态"></a>自动录音状态</h2><ol>
<li><p>我方和a通话，b来电，我方接听，没有让a加入通话过程。<br>当我方和a通话时，我方收到一个b来电，在我方接听b来电之前，和a之间的录音都是保持的。<br>接听b来电后，录音结束。<br>挂断b来电，恢复和a通话时，重新建立一个新的录音文件，并录下此后的电话。</p>
</li>
<li><p>我方和a通话，a接到b来电，a接听了，并将我方加入通话中<br>全程都有录音，包括“您好请不要挂机，对方正在通话中”这样的提示。也包括后来的三方通话录音。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">frameworks/opt/telephone/src/java/com/android/internal/telephony/CallManager.java</div><div class="line">frameworks/opt/telephone/src/java/com/android/internal/telephony/Phone.java</div><div class="line"></div><div class="line">packages/services/Telephony/src/com/android/phone/PhoneGlobals.java</div></pre></td></tr></table></figure>
<p>EVENT_CALL_WAITING<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">jinwh@jinwh-office ~/rom7.0/anrom7.0/frameworks $ grep -r &quot;EVENT_CALL_WAITING&quot;</div><div class="line">opt/telephony/src/java/com/android/internal/telephony/CallTracker.java:    protected static final int EVENT_CALL_WAITING_INFO_CDMA        = 15;</div><div class="line">opt/telephony/src/java/com/android/internal/telephony/GsmCdmaCallTracker.java:            mCi.registerForCallWaitingInfo(this, EVENT_CALL_WAITING_INFO_CDMA, null);</div><div class="line">opt/telephony/src/java/com/android/internal/telephony/GsmCdmaCallTracker.java:            case EVENT_CALL_WAITING_INFO_CDMA:</div><div class="line">opt/telephony/src/java/com/android/internal/telephony/GsmCdmaCallTracker.java:                        Rlog.d(LOG_TAG, &quot;Event EVENT_CALL_WAITING_INFO_CDMA Received&quot;);</div><div class="line">opt/telephony/src/java/com/android/internal/telephony/CallManager.java:    private static final int EVENT_CALL_WAITING = 108;</div><div class="line">opt/telephony/src/java/com/android/internal/telephony/CallManager.java:        phone.registerForCallWaiting(handler, EVENT_CALL_WAITING, null);</div><div class="line">opt/telephony/src/java/com/android/internal/telephony/CallManager.java:                case EVENT_CALL_WAITING:</div><div class="line">opt/telephony/src/java/com/android/internal/telephony/CallManager.java:                    if (VDBG) Rlog.d(LOG_TAG, &quot; handleMessage (EVENT_CALL_WAITING)&quot;);</div><div class="line">opt/telephony/tests/telephonytests/src/com/android/internal/telephony/CallManagerTest.java:        Field field = CallManager.class.getDeclaredField(&quot;EVENT_CALL_WAITING&quot;);</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">jinwh@jinwh-office ~/rom7.0/anrom7.0/packages $ grep -r &quot;EVENT_CALL_&quot;</div><div class="line">services/Telecomm/src/com/android/server/telecom/ConnectionServiceWrapper.java:                        call.onConnectionEvent(Connection.EVENT_CALL_MERGE_FAILED, null);</div><div class="line">services/Telecomm/tests/src/com/android/server/telecom/tests/BasicCallTests.java:                eq(testCall2.mCallId), eq(Connection.EVENT_CALL_MERGE_FAILED), any(Bundle.class));</div><div class="line">services/Telecomm/tests/src/com/android/server/telecom/tests/BasicCallTests.java:                eq(testCall2.mCallId), eq(Connection.EVENT_CALL_MERGE_FAILED), any(Bundle.class));</div><div class="line">services/Telephony/src/com/android/services/telephony/TelephonyConnection.java:            sendConnectionEvent(Connection.EVENT_CALL_PULL_FAILED, null);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://blog.csdn.net/l173864930/article/details/12235513</div></pre></td></tr></table></figure>
<h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><h3 id="frameworks-base-telecomm-java-android-telecom-Call-java"><a href="#frameworks-base-telecomm-java-android-telecom-Call-java" class="headerlink" title="frameworks/base/telecomm/java/android/telecom/Call.java"></a>frameworks/base/telecomm/java/android/telecom/Call.java</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * The state of a &#123;@code Call&#125; when newly created.</div><div class="line"> */</div><div class="line">public static final int STATE_NEW = 0;</div><div class="line"></div><div class="line">/**</div><div class="line"> * The state of an outgoing &#123;@code Call&#125; when dialing the remote number, but not yet connected.</div><div class="line"> */</div><div class="line">public static final int STATE_DIALING = 1;</div><div class="line"></div><div class="line">/**</div><div class="line"> * The state of an incoming &#123;@code Call&#125; when ringing locally, but not yet connected.</div><div class="line"> */</div><div class="line">public static final int STATE_RINGING = 2;</div><div class="line"></div><div class="line">/**</div><div class="line"> * The state of a &#123;@code Call&#125; when in a holding state.</div><div class="line"> */</div><div class="line">public static final int STATE_HOLDING = 3;</div><div class="line"></div><div class="line">/**</div><div class="line"> * The state of a &#123;@code Call&#125; when actively supporting conversation.</div><div class="line"> */</div><div class="line">public static final int STATE_ACTIVE = 4;</div><div class="line"></div><div class="line">/**</div><div class="line"> * The state of a &#123;@code Call&#125; when no further voice or other communication is being</div><div class="line"> * transmitted, the remote side has been or will inevitably be informed that the &#123;@code Call&#125;</div><div class="line"> * is no longer active, and the local data transport has or inevitably will release resources</div><div class="line"> * associated with this &#123;@code Call&#125;.</div><div class="line"> */</div><div class="line">public static final int STATE_DISCONNECTED = 7;</div><div class="line"></div><div class="line">/**</div><div class="line"> * The state of an outgoing &#123;@code Call&#125; when waiting on user to select a</div><div class="line"> * &#123;@link PhoneAccount&#125; through which to place the call.</div><div class="line"> */</div><div class="line">public static final int STATE_SELECT_PHONE_ACCOUNT = 8;</div><div class="line"></div><div class="line">/**</div><div class="line"> * @hide</div><div class="line"> * @deprecated use STATE_SELECT_PHONE_ACCOUNT.</div><div class="line"> */</div><div class="line">@Deprecated</div><div class="line">@SystemApi</div><div class="line">public static final int STATE_PRE_DIAL_WAIT = STATE_SELECT_PHONE_ACCOUNT;</div><div class="line"></div><div class="line">/**</div><div class="line"> * The initial state of an outgoing &#123;@code Call&#125;.</div><div class="line"> * Common transitions are to &#123;@link #STATE_DIALING&#125; state for a successful call or</div><div class="line"> * &#123;@link #STATE_DISCONNECTED&#125; if it failed.</div><div class="line"> */</div><div class="line">public static final int STATE_CONNECTING = 9;</div><div class="line"></div><div class="line">/**</div><div class="line"> * The state of a &#123;@code Call&#125; when the user has initiated a disconnection of the call, but the</div><div class="line"> * call has not yet been disconnected by the underlying &#123;@code ConnectionService&#125;.  The next</div><div class="line"> * state of the call is (potentially) &#123;@link #STATE_DISCONNECTED&#125;.</div><div class="line"> */</div><div class="line">public static final int STATE_DISCONNECTING = 10;</div><div class="line"></div><div class="line">/**</div><div class="line"> * The state of an external call which is in the process of being pulled from a remote device to</div><div class="line"> * the local device.</div><div class="line"> * &lt;p&gt;</div><div class="line"> * A call can only be in this state if the &#123;@link Details#PROPERTY_IS_EXTERNAL_CALL&#125; property</div><div class="line"> * and &#123;@link Details#CAPABILITY_CAN_PULL_CALL&#125; capability are set on the call.</div><div class="line"> * &lt;p&gt;</div><div class="line"> * An &#123;@link InCallService&#125; will only see this state if it has the</div><div class="line"> * &#123;@link TelecomManager#METADATA_INCLUDE_EXTERNAL_CALLS&#125; metadata set to &#123;@code true&#125; in its</div><div class="line"> * manifest.</div><div class="line"> */</div><div class="line">public static final int STATE_PULLING_CALL = 11;</div></pre></td></tr></table></figure>
<h3 id="packages-services-Telecomm-src-com-android-server-telecom-CallState-java"><a href="#packages-services-Telecomm-src-com-android-server-telecom-CallState-java" class="headerlink" title="packages/services/Telecomm/src/com/android/server/telecom/CallState.java"></a>packages/services/Telecomm/src/com/android/server/telecom/CallState.java</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Indicates that a call is new and not connected. This is used as the default state internally</div><div class="line"> * within Telecom and should not be used between Telecom and call services. Call services are</div><div class="line"> * not expected to ever interact with NEW calls, but &#123;@link android.telecom.InCallService&#125;s will</div><div class="line"> * see calls in this state.</div><div class="line"> */</div><div class="line">public static final int NEW = 0;</div><div class="line"></div><div class="line">/**</div><div class="line"> * The initial state of an outgoing &#123;@code Call&#125;.</div><div class="line"> * Common transitions are to &#123;@link #DIALING&#125; state for a successful call or</div><div class="line"> * &#123;@link #DISCONNECTED&#125; if it failed.</div><div class="line"> */</div><div class="line">public static final int CONNECTING = 1;</div><div class="line"></div><div class="line">/**</div><div class="line"> * The state of an outgoing &#123;@code Call&#125; when waiting on user to select a</div><div class="line"> * &#123;@link android.telecom.PhoneAccount&#125; through which to place the call.</div><div class="line"> */</div><div class="line">public static final int SELECT_PHONE_ACCOUNT = 2;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Indicates that a call is outgoing and in the dialing state. A call transitions to this state</div><div class="line"> * once an outgoing call has begun (e.g., user presses the dial button in Dialer). Calls in this</div><div class="line"> * state usually transition to &#123;@link #ACTIVE&#125; if the call was answered or &#123;@link #DISCONNECTED&#125;</div><div class="line"> * if the call was disconnected somehow (e.g., failure or cancellation of the call by the user).</div><div class="line"> */</div><div class="line">public static final int DIALING = 3;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Indicates that a call is incoming and the user still has the option of answering, rejecting,</div><div class="line"> * or doing nothing with the call. This state is usually associated with some type of audible</div><div class="line"> * ringtone. Normal transitions are to &#123;@link #ACTIVE&#125; if answered or &#123;@link #DISCONNECTED&#125;</div><div class="line"> * otherwise.</div><div class="line"> */</div><div class="line">public static final int RINGING = 4;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Indicates that a call is currently connected to another party and a communication channel is</div><div class="line"> * open between them. The normal transition to this state is by the user answering a</div><div class="line"> * &#123;@link #DIALING&#125; call or a &#123;@link #RINGING&#125; call being answered by the other party.</div><div class="line"> */</div><div class="line">public static final int ACTIVE = 5;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Indicates that the call is currently on hold. In this state, the call is not terminated</div><div class="line"> * but no communication is allowed until the call is no longer on hold. The typical transition</div><div class="line"> * to this state is by the user putting an &#123;@link #ACTIVE&#125; call on hold by explicitly performing</div><div class="line"> * an action, such as clicking the hold button.</div><div class="line"> */</div><div class="line">public static final int ON_HOLD = 6;</div><div class="line">/**</div><div class="line"> * Indicates that a call is currently disconnected. All states can transition to this state</div><div class="line"> * by the call service giving notice that the connection has been severed. When the user</div><div class="line"> * explicitly ends a call, it will not transition to this state until the call service confirms</div><div class="line"> * the disconnection or communication was lost to the call service currently responsible for</div><div class="line"> * this call (e.g., call service crashes).</div><div class="line"> */</div><div class="line">public static final int DISCONNECTED = 7;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Indicates that the call was attempted (mostly in the context of outgoing, at least at the</div><div class="line"> * time of writing) but cancelled before it was successfully connected.</div><div class="line"> */</div><div class="line">public static final int ABORTED = 8;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Indicates that the call is in the process of being disconnected and will transition next</div><div class="line"> * to a &#123;@link #DISCONNECTED&#125; state.</div><div class="line"> * &lt;p&gt;</div><div class="line"> * This state is not expected to be communicated from the Telephony layer, but will be reported</div><div class="line"> * to the InCall UI for calls where disconnection has been initiated by the user but the</div><div class="line"> * ConnectionService has confirmed the call as disconnected.</div><div class="line"> */</div><div class="line">public static final int DISCONNECTING = 9;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Indicates that the call is in the process of being pulled to the local device.</div><div class="line"> * &lt;p&gt;</div><div class="line"> * This state should only be set on a call with</div><div class="line"> * &#123;@link android.telecom.Connection#PROPERTY_IS_EXTERNAL_CALL&#125; and</div><div class="line"> * &#123;@link android.telecom.Connection#CAPABILITY_CAN_PULL_CALL&#125;.</div><div class="line"> */</div><div class="line">public static final int PULLING = 10;</div></pre></td></tr></table></figure>
<h3 id="packages-apps-Dialer-InCallUI-src-com-android-incallui-Call-java"><a href="#packages-apps-Dialer-InCallUI-src-com-android-incallui-Call-java" class="headerlink" title="packages/apps/Dialer/InCallUI/src/com/android/incallui/Call.java"></a>packages/apps/Dialer/InCallUI/src/com/android/incallui/Call.java</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class Call &#123;</div><div class="line">    /* Defines different states of this call */</div><div class="line">    public static class State &#123;</div><div class="line">        public static final int INVALID = 0;</div><div class="line">        public static final int NEW = 1;            /* The call is new. */</div><div class="line">        public static final int IDLE = 2;           /* The call is idle.  Nothing active */</div><div class="line">        public static final int ACTIVE = 3;         /* There is an active call */</div><div class="line">        public static final int INCOMING = 4;       /* A normal incoming phone call */</div><div class="line">        public static final int CALL_WAITING = 5;   /* Incoming call while another is active */</div><div class="line">        public static final int DIALING = 6;        /* An outgoing call during dial phase */</div><div class="line">        public static final int REDIALING = 7;      /* Subsequent dialing attempt after a failure */</div><div class="line">        public static final int ONHOLD = 8;         /* An active phone call placed on hold */</div><div class="line">        public static final int DISCONNECTING = 9;  /* A call is being ended. */</div><div class="line">        public static final int DISCONNECTED = 10;  /* State after a call disconnects */</div><div class="line">        public static final int CONFERENCED = 11;   /* Call part of a conference call */</div><div class="line">        public static final int SELECT_PHONE_ACCOUNT = 12; /* Waiting for account selection */</div><div class="line">        public static final int CONNECTING = 13;    /* Waiting for Telecom broadcast to finish */</div><div class="line">        public static final int BLOCKED = 14;       /* The number was found on the block list */</div></pre></td></tr></table></figure>
<h3 id="packages-apps-Dialer-InCallUI-src-com-android-incallui-InCallPresenter-java"><a href="#packages-apps-Dialer-InCallUI-src-com-android-incallui-InCallPresenter-java" class="headerlink" title="packages/apps/Dialer/InCallUI/src/com/android/incallui/InCallPresenter.java"></a>packages/apps/Dialer/InCallUI/src/com/android/incallui/InCallPresenter.java</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public enum InCallState &#123;</div><div class="line">    // InCall Screen is off and there are no calls</div><div class="line">    NO_CALLS,</div><div class="line"></div><div class="line">    // Incoming-call screen is up</div><div class="line">    INCOMING,</div><div class="line"></div><div class="line">    // In-call experience is showing</div><div class="line">    INCALL,</div><div class="line"></div><div class="line">    // Waiting for user input before placing outgoing call</div><div class="line">    WAITING_FOR_ACCOUNT,</div><div class="line"></div><div class="line">    // UI is starting up but no call has been initiated yet.</div><div class="line">    // The UI is waiting for Telecom to respond.</div><div class="line">    PENDING_OUTGOING,</div><div class="line"></div><div class="line">    // User is dialing out</div><div class="line">    OUTGOING;</div><div class="line"></div><div class="line">    public boolean isIncoming() &#123;</div><div class="line">        return (this == INCOMING);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public boolean isConnectingOrConnected() &#123;</div><div class="line">        return (this == INCOMING ||</div><div class="line">                this == OUTGOING ||</div><div class="line">                this == INCALL);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="调用路线"><a href="#调用路线" class="headerlink" title="调用路线"></a>调用路线</h2><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">base/telecomm/java/android/telecom/Call.java:1368     private static String stateToString(int state) &#123;    &lt;-</div><div class="line">base/telecomm/java/android/telecom/Call.java:1353     public String toString() &#123;    &lt;-</div></pre></td></tr></table></figure>
<h3 id="mState"><a href="#mState" class="headerlink" title="mState"></a>mState</h3><p><strong> 写入： </strong></p>
<h4 id="1-base-telecomm-java-android-telecom-Call-java-1433"><a href="#1-base-telecomm-java-android-telecom-Call-java-1433" class="headerlink" title="1. base/telecomm/java/android/telecom/Call.java:1433"></a>1. base/telecomm/java/android/telecom/Call.java:1433</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Call(Phone phone, String telecomCallId, InCallAdapter inCallAdapter, int state) &#123;</div><div class="line">    mPhone = phone;</div><div class="line">    mTelecomCallId = telecomCallId;</div><div class="line">    mInCallAdapter = inCallAdapter;</div><div class="line">    mState = state;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-base-telecomm-java-android-telecom-Call-java-1471"><a href="#2-base-telecomm-java-android-telecom-Call-java-1471" class="headerlink" title="2. base/telecomm/java/android/telecom/Call.java:1471"></a>2. base/telecomm/java/android/telecom/Call.java:1471</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">final void internalUpdate(ParcelableCall parcelableCall, Map&lt;String, Call&gt; callIdMap) &#123;</div><div class="line">.....</div><div class="line">        if (stateChanged) &#123;</div><div class="line">            mState = state;</div><div class="line">        &#125;</div><div class="line">......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>2.1 framework/base/telecomm/java/android/telecom/Phone.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">final void internalAddCall(ParcelableCall parcelableCall)</div><div class="line">和</div><div class="line">final void internalUpdateCall(ParcelableCall parcelableCall) &#123;</div></pre></td></tr></table></figure>
</li>
<li><p>2.1.1 base/telecomm/java/android/telecom/InCallService.java:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> mPhone.internalAddCall((ParcelableCall) msg.obj);</div><div class="line">和</div><div class="line"> mPhone.internalUpdateCall((ParcelableCall) msg.obj);</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="状态码转换"><a href="#状态码转换" class="headerlink" title="状态码转换"></a>状态码转换</h2><p>packages/services/Telecomm/src/com/android/server/telecom/CallState.java</p>
<h3 id="packages-apps-Dialer-InCallUI-src-com-android-incallui-Call-java-1"><a href="#packages-apps-Dialer-InCallUI-src-com-android-incallui-Call-java-1" class="headerlink" title="packages/apps/Dialer/InCallUI/src/com/android/incallui/Call.java"></a>packages/apps/Dialer/InCallUI/src/com/android/incallui/Call.java</h3><p>从 frameworks/base/telecomm/java/android/telecom/Call.java<br>向 packages/apps/Dialer/InCallUI/src/com/android/incallui/Call.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">private static int translateState(int state) &#123;</div><div class="line">    switch (state) &#123;</div><div class="line">        case android.telecom.Call.STATE_NEW:</div><div class="line">        case android.telecom.Call.STATE_CONNECTING:</div><div class="line">            return Call.State.CONNECTING;</div><div class="line">        case android.telecom.Call.STATE_SELECT_PHONE_ACCOUNT:</div><div class="line">            return Call.State.SELECT_PHONE_ACCOUNT;</div><div class="line">        case android.telecom.Call.STATE_DIALING:</div><div class="line">            return Call.State.DIALING;</div><div class="line">        case android.telecom.Call.STATE_RINGING:</div><div class="line">            return Call.State.INCOMING;</div><div class="line">        case android.telecom.Call.STATE_ACTIVE:</div><div class="line">            return Call.State.ACTIVE;</div><div class="line">        case android.telecom.Call.STATE_HOLDING:</div><div class="line">            return Call.State.ONHOLD;</div><div class="line">        case android.telecom.Call.STATE_DISCONNECTED:</div><div class="line">            return Call.State.DISCONNECTED;</div><div class="line">        case android.telecom.Call.STATE_DISCONNECTING:</div><div class="line">            return Call.State.DISCONNECTING;</div><div class="line">        default:</div><div class="line">            return Call.State.INVALID;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>frameworks/base/telecomm/java/android/telecom/Call.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">private void fireStateChanged(final int newState) &#123;</div><div class="line">        for (CallbackRecord&lt;Callback&gt; record : mCallbackRecords) &#123;</div><div class="line">            final Call call = this;</div><div class="line">            final Callback callback = record.getCallback();</div><div class="line">            record.getHandler().post(new Runnable() &#123;</div><div class="line">                @Override</div><div class="line">                public void run() &#123;</div><div class="line">                    callback.onStateChanged(call, newState);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>创造一个CallbackRecord,并且注册到这里？？？？<br>注册函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public void registerCallback(Callback callback) &#123;</div><div class="line">        registerCallback(callback, new Handler());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Registers a callback to this &#123;@code Call&#125;.</div><div class="line">     *</div><div class="line">     * @param callback A &#123;@code Callback&#125;.</div><div class="line">     * @param handler A handler which command and status changes will be delivered to.</div><div class="line">     */</div><div class="line">    public void registerCallback(Callback callback, Handler handler) &#123;</div><div class="line">        unregisterCallback(callback);</div><div class="line">        // Don&apos;t allow new callback registration if the call is already being destroyed.</div><div class="line">        if (callback != null &amp;&amp; handler != null &amp;&amp; mState != STATE_DISCONNECTED) &#123;</div><div class="line">            mCallbackRecords.add(new CallbackRecord&lt;Callback&gt;(callback, handler));</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>调用他的地方：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public void addListener(Listener listener) &#123;</div><div class="line">    registerCallback(listener);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="电话状态调用流程"><a href="#电话状态调用流程" class="headerlink" title="电话状态调用流程"></a>电话状态调用流程</h2><h3 id="packages-services-Telecomm-src-con-android-server-telecom-InCallController-java"><a href="#packages-services-Telecomm-src-con-android-server-telecom-InCallController-java" class="headerlink" title="packages/services/Telecomm/src/con/android/server/telecom/InCallController.java"></a>packages/services/Telecomm/src/con/android/server/telecom/InCallController.java</h3><ol>
<li>在这里打印的电话状态，可以用<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">private void updateCall(Call call, boolean videoProviderChanged) &#123;</div><div class="line">        if (!mInCallServices.isEmpty()) &#123;</div><div class="line">            Log.i(this, &quot;jin InCallController.java updateCall &#123;Call: %s&#125;&quot;,</div><div class="line">                        (call != null ? call.toString() :&quot;null&quot;));</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="录音"><a href="#录音" class="headerlink" title="录音"></a>录音</h2><h3 id="代码位置"><a href="#代码位置" class="headerlink" title="代码位置"></a>代码位置</h3><p>packages/apps/Dialer/InCallUI/src/com/android/incallui/CallButtonPresesnter.java<br>packages/apps/Dialer/InCallUI/src/com/android/incallui/CallRecorder.java<br>packages/apps/Dialer/src/com/android/services/callrecorder/CallRecorderService.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">http://www.jizhuomi.com/android/example/354.html</div><div class="line">http://blog.sina.com.cn/s/blog_89429f6d0100yald.html</div><div class="line">http://blog.csdn.net/wonengxing/article/details/42488433</div><div class="line">http://blog.csdn.net/cjh_android/article/details/51341004</div></pre></td></tr></table></figure>
<h3 id="0916"><a href="#0916" class="headerlink" title="0916"></a>0916</h3><p>目前看来，打log出现需求的状态的地方是可以拿到所有需要的状态的。<br>log：<br>packages/services/Telecomm/src/con/android/server/telecom/InCallController.java ###<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">private void updateCall(Call call, boolean videoProviderChanged) &#123;</div><div class="line">        if (!mInCallServices.isEmpty()) &#123;</div><div class="line">            Log.i(this, &quot;jin InCallController.java updateCall &#123;Call: %s&#125;&quot;,</div><div class="line">                        (call != null ? call.toString() :&quot;null&quot;));</div></pre></td></tr></table></figure></p>
<p>调用它的位置应该是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public void onCallStateChanged(Call call, int oldState, int newState) &#123;</div><div class="line">    Log.d(&quot;jin&quot;,&quot;jin InCallController.java onCallStateChanged &quot;</div><div class="line">            &quot;calling function updateCall&quot;);</div><div class="line">    updateCall(call);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个调用在class InCallController当中，这个类 extends CallsManagerListenerBase.<br>再看CallsManagerListenerBase.java  这个类implements CallsManager.CallsManagerListener<br>再看CallsManagerListener，在CallsManager.java文件中，是一个interface类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public interface CallsManagerListener &#123;</div><div class="line">    void onCallAdded(Call call);</div><div class="line">    void onCallRemoved(Call call);</div><div class="line">    void onCallStateChanged(Call call, int oldState, int newState);</div><div class="line">    void onConnectionServiceChanged(</div><div class="line">            Call call,</div><div class="line">            ConnectionServiceWrapper oldService,</div><div class="line">            ConnectionServiceWrapper newService);</div><div class="line">    void onIncomingCallAnswered(Call call);</div><div class="line">    void onIncomingCallRejected(Call call, boolean rejectWithMessage, String textMessage);</div><div class="line">    void onCallAudioStateChanged(CallAudioState oldAudioState, CallAudioState newAudioState);</div><div class="line">    void onRingbackRequested(Call call, boolean ringback);</div><div class="line">    void onIsConferencedChanged(Call call);</div><div class="line">    void onIsVoipAudioModeChanged(Call call);</div><div class="line">    void onVideoStateChanged(Call call, int previousVideoState, int newVideoState);</div><div class="line">    void onCanAddCallChanged(boolean canAddCall);</div><div class="line">    void onSessionModifyRequestReceived(Call call, VideoProfile videoProfile);</div><div class="line">    void onHoldToneRequested(Call call);</div><div class="line">    void onExternalCallChanged(Call call, boolean isExternalCall);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>所以，下一步，看看Dialer中有没有其他CallsManagerListener，模仿写法，把romrecorder做成CallsManagerListener,就可以直接判断state，然后录音。</p>
<p>另一种方法，看能不能在service/telecomm中调用到romrecorder，所以，就是看app/Dialer和service/telecomm谁能调用谁。</p>
<h3 id="CallList的调用流程"><a href="#CallList的调用流程" class="headerlink" title="CallList的调用流程"></a>CallList的调用流程</h3><p>packages/apps/Dialer/InCallUI/src/com/android/incallui/CallList.java</p>
<h4 id="打入电话"><a href="#打入电话" class="headerlink" title="打入电话"></a>打入电话</h4><ol>
<li><p>log打印<br>‘public void onIncoming(Call call, List<string> textMessages)’<br>这个方法是来电时的log打印。</string></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">09-16 16:19:23.611  3914  3914 I InCall  : CallList - onIncoming - [Call_14, INCOMING, [Capabilities: CAPABILITY_SUPPORT_HOLD CAPABILITY_RESPOND_VIA_TEXT CAPABILITY_MUTE CAPABILITY_CANNOT_DOWNGRADE_VIDEO_TO_AUDIO], [Properties:], children:[], parent:null, conferenceable:[], videoState:Audio Only, mSessionModificationState:0, VideoSettings:(CameraDir:-1), mIsActivSub:false]</div></pre></td></tr></table></figure>
</li>
<li><p>调用<br>它由public void (final android.telecom.Call telecomCall)</p>
</li>
</ol>
<h4 id="打出电话"><a href="#打出电话" class="headerlink" title="打出电话"></a>打出电话</h4><p>private void (Call call)<br>这个方法是打出的时候的log打印<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">09-16 15:19:11.039  3914  3914 I InCall  : CallList - onUpdate - [Call_8, ACTIVE, [Capabilities: CAPABILITY_HOLD CAPABILITY_SUPPORT_HOLD CAPABILITY_MUTE CAPABILITY_CANNOT_DOWNGRADE_VIDEO_TO_AUDIO], [Properties:], children:[], parent:null, conferenceable:[], videoState:Audio Only, mSessionModificationState:0, VideoSettings:(CameraDir:-1), mIsActivSub:false]</div></pre></td></tr></table></figure></p>
<p>frameworks/base/telecomm/java/android/telecom/Call.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">private void fireStateChanged(final int newState) &#123;</div><div class="line">        for (CallbackRecord&lt;Callback&gt; record : mCallbackRecords) &#123;</div><div class="line">            final Call call = this;</div><div class="line">            final Callback callback = record.getCallback();</div><div class="line">            record.getHandler().post(new Runnable() &#123;</div><div class="line">                @Override</div><div class="line">                public void run() &#123;</div><div class="line">                    callback.onStateChanged(call, newState);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>创造一个CallbackRecord,并且注册到这里？？？？<br>注册函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public void registerCallback(Callback callback) &#123;</div><div class="line">        registerCallback(callback, new Handler());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Registers a callback to this &#123;@code Call&#125;.</div><div class="line">     *</div><div class="line">     * @param callback A &#123;@code Callback&#125;.</div><div class="line">     * @param handler A handler which command and status changes will be delivered to.</div><div class="line">     */</div><div class="line">    public void registerCallback(Callback callback, Handler handler) &#123;</div><div class="line">        unregisterCallback(callback);</div><div class="line">        // Don&apos;t allow new callback registration if the call is already being destroyed.</div><div class="line">        if (callback != null &amp;&amp; handler != null &amp;&amp; mState != STATE_DISCONNECTED) &#123;</div><div class="line">            mCallbackRecords.add(new CallbackRecord&lt;Callback&gt;(callback, handler));</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>调用他的地方：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public void addListener(Listener listener) &#123;</div><div class="line">    registerCallback(listener);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>调用<br>它由public void onUpdate(Call call)调用</li>
</ol>
<h3 id="要解决的问题"><a href="#要解决的问题" class="headerlink" title="要解决的问题"></a>要解决的问题</h3><p><strong>要解决申请权限的问题</strong><br><strong>要屏蔽掉原本电话中的录音功能</strong><br><strong>怎么通知app各种电话事件</strong></p>
<h2 id="0917"><a href="#0917" class="headerlink" title="0917"></a>0917</h2><p>notify的处理方法</p>
<h3 id="通知调用路径"><a href="#通知调用路径" class="headerlink" title="通知调用路径"></a>通知调用路径</h3><p>应用层<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">package com.pocketdigi.phonelistener;   </div><div class="line">import android.app.Service;   </div><div class="line">import android.content.BroadcastReceiver;   </div><div class="line">import android.content.Context;   </div><div class="line">import android.content.Intent;   </div><div class="line">import android.telephony.PhoneStateListener;   </div><div class="line">import android.telephony.TelephonyManager;   </div><div class="line">public class PhoneReceiver extends BroadcastReceiver &#123;   </div><div class="line">@Override   </div><div class="line">public void onReceive(Context context, Intent intent) &#123;   </div><div class="line">System.out.println(&quot;action&quot;+intent.getAction());   </div><div class="line">//如果是去电   </div><div class="line">if(intent.getAction().equals(Intent.ACTION_NEW_OUTGOING_CALL))&#123;   </div><div class="line">String phoneNumber = intent   </div><div class="line">.getStringExtra(Intent.EXTRA_PHONE_NUMBER);   </div><div class="line">Log.d(TAG, &quot;call OUT:&quot; + phoneNumber);   </div><div class="line">&#125;else&#123;   </div><div class="line">//查了下android文档，貌似没有专门用于接收来电的action,所以，非去电即来电.   </div><div class="line">//如果我们想要监听电话的拨打状况，需要这么几步 :   </div><div class="line">* 第一：获取电话服务管理器TelephonyManager manager = this.getSystemService(TELEPHONY_SERVICE);   </div><div class="line">* 第二：通过TelephonyManager注册我们要监听的电话状态改变事件。manager.listen(new MyPhoneStateListener(),   </div><div class="line">* PhoneStateListener.LISTEN_CALL_STATE);这里的PhoneStateListener.LISTEN_CALL_STATE就是我们想要   </div><div class="line">* 监听的状态改变事件，初次之外，还有很多其他事件哦。   </div><div class="line">* 第三步：通过extends PhoneStateListener来定制自己的规则。将其对象传递给第二步作为参数。   </div><div class="line">* 第四步：这一步很重要，那就是给应用添加权限。android.permission.READ_PHONE_STATE   </div><div class="line">TelephonyManager tm = (TelephonyManager)context.getSystemService(Service.TELEPHONY_SERVICE);   </div><div class="line">tm.listen(listener, PhoneStateListener.LISTEN_CALL_STATE);   </div><div class="line">//设置一个监听器   </div><div class="line">&#125;   </div><div class="line">&#125;   </div><div class="line"> listener=new PhoneStateListener()&#123;   </div><div class="line">@Override   </div><div class="line">public void onCallStateChanged(int state, String incomingNumber) &#123;   </div><div class="line">//注意，方法必须写在super方法后面，否则incomingNumber无法获取到值。   </div><div class="line">super.(state, incomingNumber);   </div><div class="line">switch(state)&#123;   </div><div class="line">case TelephonyManager.CALL_STATE_IDLE:   </div><div class="line">System.out.println(&quot;挂断&quot;);   </div><div class="line">break;   </div><div class="line">case TelephonyManager.CALL_STATE_OFFHOOK:   </div><div class="line">System.out.println(&quot;接听&quot;);   </div><div class="line">break;   </div><div class="line">case TelephonyManager.CALL_STATE_RINGING:   </div><div class="line">System.out.println(&quot;响铃:来电号码&quot;+incomingNumber);   </div><div class="line">//输出来电号码   </div><div class="line">break;   </div><div class="line">&#125;   </div><div class="line">&#125;   </div><div class="line">&#125;;   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>尝试在PhoneStateListener中添加一个新方法，来获取真正的state。<br>/frameworks/base/telephony/java/android/telephony/PhoneStateListener.java</p>
<p>发出广播的地方<br>packages/services/Telecomm/src/com/android/server/telecom/PhoneStateBroadcaster.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void onCallStateChanged(Call call, int oldState, int newState) &#123;</div><div class="line">    if (call.isExternalCall()) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    updateStates(call);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">private void updateStates(Call call) &#123;</div><div class="line">    // Recalculate the current phone state based on the consolidated state of the remaining</div><div class="line">    // calls in the call list.</div><div class="line">    // Note: CallsManager#hasRingingCall() and CallsManager#getFirstCallWithState(..) do not</div><div class="line">    // consider external calls, so an external call is going to cause the state to be idle.</div><div class="line">    int callState = TelephonyManager.CALL_STATE_IDLE;</div><div class="line">    if (mCallsManager.hasRingingCall()) &#123;</div><div class="line">        callState = TelephonyManager.CALL_STATE_RINGING;</div><div class="line">    &#125; else if (mCallsManager.getFirstCallWithState(CallState.DIALING, CallState.PULLING,</div><div class="line">            CallState.ACTIVE, CallState.ON_HOLD) != null) &#123;</div><div class="line">        callState = TelephonyManager.CALL_STATE_OFFHOOK;</div><div class="line">    &#125;</div><div class="line">    sendPhoneStateChangedBroadcast(call, callState);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里已经有Call,可以通过它取到CallState,文件位置：<br>packages/services/Telecomm/src/com/android/server/telecom/Call.java<br>packages/services/Telecomm/src/com/android/server/telecom/CallState.java</p>
<h2 id="notify收到的倒推调用"><a href="#notify收到的倒推调用" class="headerlink" title="notify收到的倒推调用"></a>notify收到的倒推调用</h2><ul>
<li><p>packages/services/Telecomm/src/com/android/server/telecom/TelecomServiceImpl.java<br>getCallState()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @see TelecomManager#getCallState</div><div class="line"> */</div><div class="line">@Override</div><div class="line">public int getCallState() &#123;</div><div class="line">    try &#123;</div><div class="line">        Log.startSession(&quot;TSI.getCallState&quot;);</div><div class="line">        synchronized (mLock) &#123;</div><div class="line">            return mCallsManager.getCallState();</div><div class="line">        &#125;</div><div class="line">    &#125; finally &#123;</div><div class="line">        Log.endSession();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>packages/services/Telecomm/src/com/android/server/telecom/CallsManager.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @return the call state currently tracked by &#123;@link PhoneStateBroadcaster&#125;</div><div class="line"> */</div><div class="line">int getCallState() &#123;</div><div class="line">    return mPhoneStateBroadcaster.getCallState();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>package/services/Telecomm/src/com/android/server/telecom/PhoneStateBroadcaster.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int getCallState() &#123;</div><div class="line">    return mCurrentState;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>既然return mCurrentState,那么就找找哪里set了mCurrentState,只有一处。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">private void sendPhoneStateChangedBroadcast(Call call, int phoneState) &#123;</div><div class="line">    if (phoneState == mCurrentState) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mCurrentState = phoneState;</div><div class="line"></div><div class="line">    String callHandle = null;</div><div class="line">    if (call.getHandle() != null) &#123;</div><div class="line">        callHandle = call.getHandle().getSchemeSpecificPart();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    try &#123;</div><div class="line">        if (mRegistry != null) &#123;</div><div class="line">            mRegistry.notifyCallState(phoneState, callHandle);</div><div class="line">            Log.i(this, &quot;Broadcasted state change: %s&quot;, mCurrentState);</div><div class="line">        &#125;</div><div class="line">    &#125; catch (RemoteException e) &#123;</div><div class="line">        Log.w(this, &quot;RemoteException when notifying TelephonyRegistry of call state change.&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来，看看set过程的调用。就从这个sendPhoneStateChangedBroadcast开始倒推。<br>updateStates是唯一调用sendPhoneStateChangedBroadcast的地方，并且<br><strong>这就是把完整的state的转成只有三种state的地方</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">private void updateStates(Call call) &#123;</div><div class="line">    // Recalculate the current phone state based on the consolidated state of the remaining</div><div class="line">    // calls in the call list.</div><div class="line">    // Note: CallsManager#hasRingingCall() and CallsManager#getFirstCallWithState(..) do not</div><div class="line">    // consider external calls, so an external call is going to cause the state to be idle.</div><div class="line">    int callState = TelephonyManager.CALL_STATE_IDLE;</div><div class="line">    if (mCallsManager.hasRingingCall()) &#123;</div><div class="line">        callState = TelephonyManager.CALL_STATE_RINGING;</div><div class="line">    &#125; else if (mCallsManager.getFirstCallWithState(CallState.DIALING, CallState.PULLING,</div><div class="line">            CallState.ACTIVE, CallState.ON_HOLD) != null) &#123;</div><div class="line">        callState = TelephonyManager.CALL_STATE_OFFHOOK;</div><div class="line">    &#125;</div><div class="line">    sendPhoneStateChangedBroadcast(call, callState);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>调用updateStates就比较多了，不好下手，还是考虑在sendPhoneStateChangedBroadcast中下手。<br>再回头看sendPhoneStateChangedBroadcast<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">private void sendPhoneStateChangedBroadcast(Call call, int phoneState) &#123;</div><div class="line">    if (phoneState == mCurrentState) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mCurrentState = phoneState;</div><div class="line"></div><div class="line">    String callHandle = null;</div><div class="line">    if (call.getHandle() != null) &#123;</div><div class="line">        callHandle = call.getHandle().getSchemeSpecificPart();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    try &#123;</div><div class="line">        if (mRegistry != null) &#123;</div><div class="line">            mRegistry.notifyCallState(phoneState, callHandle);</div><div class="line">            Log.i(this, &quot;Broadcasted state change: %s&quot;, mCurrentState);</div><div class="line">        &#125;</div><div class="line">    &#125; catch (RemoteException e) &#123;</div><div class="line">        Log.w(this, &quot;RemoteException when notifying TelephonyRegistry of call state change.&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中有<code>mRegistry.notifyCallState(phoneState, callHandle);</code><br>这个mRegistry的原型在frameworks/base/service/core/java/com/android/server/TelephonyRegistry.java<br>看看他的notifyCallState<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public void notifyCallState(int state, String incomingNumber) &#123;</div><div class="line">    if (!checkNotifyPermission(&quot;notifyCallState()&quot;)) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (VDBG) &#123;</div><div class="line">        log(&quot;notifyCallState: state=&quot; + state + &quot; incomingNumber=&quot; + incomingNumber);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    synchronized (mRecords) &#123;</div><div class="line">        for (Record r : mRecords) &#123;</div><div class="line">            if (r.matchPhoneStateListenerEvent(PhoneStateListener.LISTEN_CALL_STATE) &amp;&amp;</div><div class="line">                    (r.subId == SubscriptionManager.DEFAULT_SUBSCRIPTION_ID)) &#123;</div><div class="line">                try &#123;</div><div class="line">                    String incomingNumberOrEmpty = r.canReadPhoneState ? incomingNumber : &quot;&quot;;</div><div class="line">                    r.callback.onCallStateChanged(state, incomingNumberOrEmpty);</div><div class="line">                &#125; catch (RemoteException ex) &#123;</div><div class="line">                    mRemoveList.add(r.binder);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        handleRemoveListLocked();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Called only by Telecomm to communicate call state across different phone accounts. So</div><div class="line">    // there is no need to add a valid subId or slotId.</div><div class="line">    broadcastCallStateChanged(state, incomingNumber,</div><div class="line">            SubscriptionManager.INVALID_PHONE_INDEX,</div><div class="line">            SubscriptionManager.INVALID_SUBSCRIPTION_ID);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中有<code>r.callback.onCallStateChanged(state, incomingNumberOrEmpty);</code><br>依样画葫芦，做一个notifyRealCallState，从sendPhoneStateChangedBroadcast中，把真实的state，给做一个notifyRealCallState,<br><strong>其中有一个checkNotifyPermission方法，考虑能不能用来做未来的应用验证</strong></p>
<h2 id="notify修改了"><a href="#notify修改了" class="headerlink" title="notify修改了"></a>notify修改了</h2><p>frameworks/base/services/core/java/com/android/server/TelephonyRegistry.java</p>
<p>frameworks/base/telecomm/java/com/android/interrnal/telecom/ITelecomService.aidl</p>
<p>frameworks/base/telephony/java/android/telephony/PhoneStateListener.java<br>frameworks/base/telephony/java/android/telephony/TelephoneManager.java</p>
<p>frameworks/base/telephony/java/com/android/internal/telephony/ITelephonyRegistry.aidl<br>frameworks/base/telephony/java/com/android/internal/telephony/PhoneConstants.java</p>
<p>frameworks/opt/telephony/src/com/android/internal/telephony/Call.java<br>frameworks/opt/telephony/src/com/android/internal/telephony/DefaultPhoneNotifier.java<br>frameworks/opt/telephony/src/com/android/internal/telephony/Phone.java<br>frameworks/opt/telephony/src/com/android/internal/telephony/.java</p>
<p>package/service/Telecomm/src/com/android/server/telecom/TelecomServiceImpl.java<br>package/service/Telecomm/src/com/android/server/telecom/Call.java<br>package/service/Telecomm/src/com/android/server/telecom/CallsManager.java<br>package/service/Telecomm/src/com/android/server/telecom/CallsManagerListenerBase.java<br>package/service/Telecomm/src/com/android/server/telecom/CallState.java<br>package/service/Telecomm/src/com/android/server/telecom/PhoneStateBroadcaster.java</p>
<p>framewords/opt/telephony/src/java/com/android/internal/talephony/TelecomService.java</p>
<p>services/core/java/com/android/server/notification/NotificationManagerService.java</p>
<p>base/services/core/java/com/android/server/pm/DefaultPermissionGrantPolicy.java</p>
<p>data-binding/compiler/src/main/resources/api-versions.xml</p>
<p>frameworks/opt/telephony/src/java/com/android/internal/telephony/GsmCdmaPhone.java</p>
<h2 id="notify调用过程"><a href="#notify调用过程" class="headerlink" title="notify调用过程"></a>notify调用过程</h2><p>首先明确，<br>录音方法中的callstate，是packages/apps/Dialer/InCallUI/src/com/android/incallui/Call.java中的State。<br>而我们需要的notify的callstate只能自己造了。因为涉及到状态通知的两个地方能够拿到的是两种不同的state组合。</p>
<ol>
<li><p>packages/services/Telecomm/src/com/android/server/telecom/CallState.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public static final int NEW = 0;</div><div class="line">public static final int CONNECTING = 1;</div><div class="line">public static final int SELECT_PHONE_ACCOUNT = 2;</div><div class="line">public static final int DIALING = 3;</div><div class="line">public static final int RINGING = 4;</div><div class="line">public static final int ACTIVE = 5;</div><div class="line">public static final int ON_HOLD = 6;</div><div class="line">public static final int DISCONNECTED = 7;</div><div class="line">public static final int ABORTED = 8;</div><div class="line">public static final int DISCONNECTING = 9;</div><div class="line">public static final int PULLING = 10;</div></pre></td></tr></table></figure>
</li>
<li><p>framewords/opt/telephony/src/java/com/android/internal/telephony/Call.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public enum State &#123;</div><div class="line">        IDLE, ACTIVE, HOLDING, DIALING, ALERTING, INCOMING, WAITING, DISCONNECTED, DISCONNECTING;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>在packages/services/Telecomm/src/com/android/server/telecom/PhoneStateBroadcaster.java中，有一个把完整的CallState转成只有三种状态的方法。<br>在framewords/opt/telephony/src/java/com/android/internal/telephony/Call.java中，有把Call.State简单转成其他类型的启示代码。</p>
<p><strong>自己造的callstate</strong><br>在frameworks/base/telephony/java/android/telephony/TelephoyManager.java中创造以下callstate<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public static final int REAL_CALL_STATE_IDLE = 0;</div><div class="line">public static final int REAL_CALL_STATE_ACTIVE = 1;</div><div class="line">public static final int REAL_CALL_STATE_HOLDING = 3;</div><div class="line">public static final int REAL_CALL_STATE_RINGING = 4;</div><div class="line">public static final int REAL_CALL_STATE_DIALING = 5;</div><div class="line">//~ public static final int REAL_CALL_STATE_ALERTING = 5;</div><div class="line">//~ public static final int REAL_CALL_STATE_INCOMING = 6;</div><div class="line">//~ public static final int REAL_CALL_STATE_WAITING = 7;</div><div class="line">public static final int REAL_CALL_STATE_DISCONNECTED = 6;</div><div class="line">public static final int REAL_CALL_STATE_DISCONNECTING = 7;</div></pre></td></tr></table></figure></p>
<ol>
<li><p>在frameworks/opt/telephony/src/java/com/android/internal/telephony/Call.java中写转换函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public int getRealState() &#123;</div><div class="line">    State state = getState();</div><div class="line"></div><div class="line">    switch (state) &#123;</div><div class="line">        case IDLE:</div><div class="line">            return TelephonyManager.REAL_CALL_STATE_IDLE;</div><div class="line">        case ACTIVE:</div><div class="line">            return TelephonyManager.REAL_CALL_STATE_ACTIVE;</div><div class="line">        case HOLDING:</div><div class="line">            return TelephonyManager.REAL_CALL_STATE_HOLDING;</div><div class="line">        case INCOMING:</div><div class="line">        case WAITING:</div><div class="line">            return TelephonyManager.REAL_CALL_STATE_RINGING;</div><div class="line">        case DIALING:</div><div class="line">        case ALERTING:</div><div class="line">            return TelephonyManager.REAL_CALL_STATE_DIALING;</div><div class="line">        case DISCONNECTED:</div><div class="line">            return TelephonyManager.REAL_CALL_STATE_DISCONNECTED;</div><div class="line">        case DISCONNECTING:</div><div class="line">            return TelephonyManager.REAL_CALL_STATE_DISCONNECTING;</div><div class="line">        default:</div><div class="line">            return TelephonyManager.REAL_CALL_STATE_IDLE;</div><div class="line">    &#125;</div><div class="line">    return TelephonyManager.REAL_CALL_STATE_IDLE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>在packages/services/Telecomm/src/com/android/server/telecom/Call.java中写转换函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public int getRealState() &#123;</div><div class="line">        int state = getState();</div><div class="line"></div><div class="line">        switch (state) &#123;</div><div class="line">            case NEW:</div><div class="line">            case CONNECTING:</div><div class="line">            case SELECT_PHONE_ACCOUNT:</div><div class="line">            case ABORTED:</div><div class="line">            case PULLING:</div><div class="line">                Log.i(LOG_TAG,&quot;jin noti pacCall state:&quot; + TelephonyManager.REAL_CALL_STATE_IDLE);</div><div class="line">                return TelephonyManager.REAL_CALL_STATE_IDLE;</div><div class="line">            case DIALING:</div><div class="line">            Log.i(LOG_TAG,&quot;jin noti pacCall state:&quot; + TelephonyManager.REAL_CALL_STATE_DIALING);</div><div class="line">                return TelephonyManager.REAL_CALL_STATE_DIALING</div><div class="line">            case RINGING:</div><div class="line">            Log.i(LOG_TAG,&quot;jin noti pacCall state:&quot; + TelephonyManager.REAL_CALL_STATE_RINGING);</div><div class="line">                return TelephonyManager.REAL_CALL_STATE_RINGING;</div><div class="line">            case ACTIVE:</div><div class="line">            Log.i(LOG_TAG,&quot;jin noti pacCall state:&quot; + TelephonyManager.REAL_CALL_STATE_ACTIVE);</div><div class="line">                return TelephonyManager.REAL_CALL_STATE_ACTIVE;</div><div class="line">            case ON_HOLD:</div><div class="line">            Log.i(LOG_TAG,&quot;jin noti pacCall state:&quot; + TelephonyManager.REAL_CALL_STATE_HOLDING);</div><div class="line">                return TelephonyManager.REAL_CALL_STATE_HOLDING;</div><div class="line">            case DISCONNECTED:</div><div class="line">            Log.i(LOG_TAG,&quot;jin noti pacCall state:&quot; + TelephonyManager.REAL_CALL_STATE_DISCONNECTED);</div><div class="line">                return TelephonyManager.REAL_CALL_STATE_DISCONNECTED;</div><div class="line">            case DISCONNECTING:</div><div class="line">            Log.i(LOG_TAG,&quot;jin noti pacCall state:&quot; + TelephonyManager.REAL_CALL_STATE_DISCONNECTING);</div><div class="line">                return TelephonyManager.REAL_CALL_STATE_DISCONNECTING;</div><div class="line">            default:</div><div class="line">            Log.i(LOG_TAG,&quot;jin noti pacCall state:default&quot;);</div><div class="line">                return TelephonyManager.REAL_CALL_STATE_IDLE;</div><div class="line">        &#125;</div><div class="line">        Log.i(LOG_TAG,&quot;jin noti pacCall state:nomatch&quot;);</div><div class="line">        return TelephonyManager.REAL_CALL_STATE_IDLE;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="调用过程-修改路径"><a href="#调用过程-修改路径" class="headerlink" title="调用过程/修改路径"></a>调用过程/修改路径</h3><ol>
<li>frameworks/base/telephony/java/android/telephony/PhoneStateListener.java<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public void onRealCallStateChanged(int state, String incomingNumber) &#123;</div><div class="line">    log(&quot;jin PhoneStateListener onRealCallStateChanged&quot;);</div><div class="line">    send(LISTEN_REAL_CALL_STATE, state, 0, incomingNumber);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>来自于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">    public PhoneStateListener(int subId, Looper looper) &#123;</div><div class="line">        if (DBG) log(&quot;ctor: subId=&quot; + subId + &quot; looper=&quot; + looper);</div><div class="line">        mSubId = subId;</div><div class="line">        mHandler = new Handler(looper) &#123;</div><div class="line">            public void handleMessage(Message msg) &#123;</div><div class="line">                if (DBG) &#123;</div><div class="line">                    log(&quot;mSubId=&quot; + mSubId + &quot; what=0x&quot; + Integer.toHexString(msg.what)</div><div class="line">                            + &quot; msg=&quot; + msg);</div><div class="line">                &#125;</div><div class="line">                switch (msg.what) &#123;</div><div class="line">.......................</div><div class="line">                    case LISTEN_CALL_STATE:</div><div class="line">                        log(&quot;jin PhoneStateListener case LISTEN_CALL_STATE&quot;);</div><div class="line">                        PhoneStateListener.this.onCallStateChanged(msg.arg1, (String)msg.obj);</div><div class="line">                        break;</div><div class="line">                    //add by rom - jin</div><div class="line">                    case LISTEN_REAL_CALL_STATE:</div><div class="line">                        log(&quot;jin PhoneStateListener case LISTEN_REAL_CALL_STATE&quot;);</div><div class="line">                        PhoneStateListener.this.onRealCallStateChanged(msg.arg1, (String)msg.obj);</div><div class="line">                        break;</div></pre></td></tr></table></figure></p>
<p>查找一下LISTEN_CALL_STATE，后续到</p>
<ol>
<li><p>frameworks/base/services/core/java/com/android/server/TelephonyRegistry.java<br>LISTEN_CALL_STATE主要用在了权限判断和条件筛选<br>抄了notifyCallState 和 notifyCallStateForPhoneId 为 notifyRealCallState 和 notifyRealCallStateForPhoneId<br>同时，在frameworks/base/telephony/java/com/android/internal/telephony/ITelephonyRegistry.aidl中也要作相应修改<br>这里面的incomingNumber直接给了真实的incomingNumber，要注意，这里传入的state会被送去给r.callback.onRealCallStateChanged(state, incomingNumberOrEmpty);所以，要确保，调用这个函数的时候，给的state就是真实的state</p>
</li>
<li><p>先看notifyCallState的调用</p>
<ol>
<li>packages/services/Telecomm/src/com/android/server/telecom/PhoneStateBroadcaster.java:114: mRegistry.notifyCallState(phoneState, callHandle);<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">private void sendPhoneStateChangedBroadcast(Call call, int phoneState) &#123;</div><div class="line">    if (phoneState == mCurrentState) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mCurrentState = phoneState;</div><div class="line"></div><div class="line">    String callHandle = null;</div><div class="line">    if (call.getHandle() != null) &#123;</div><div class="line">        callHandle = call.getHandle().getSchemeSpecificPart();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    try &#123;</div><div class="line">        if (mRegistry != null) &#123;</div><div class="line">    //在这里</div><div class="line">            mRegistry.(phoneState, callHandle);</div><div class="line">    //增加notifyRealCallState</div><div class="line">    		mRegistry.notifyRealCallState(call.getState(), callHandle);</div><div class="line">            </div><div class="line">            Log.i(this, &quot;Broadcasted state change: %s&quot;, mCurrentState);</div><div class="line">        &#125;</div><div class="line">    &#125; catch (RemoteException e) &#123;</div><div class="line">        Log.w(this, &quot;RemoteException when notifying TelephonyRegistry of call state change.&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<p>在这里已经有Call了，可以直接使用Call.getRealState()来获取转换好的状态<br>所以，直接增加mRegistry.notifyRealCallState(call.getRealState(), callHandle);</p>
<ol>
<li>再看notifyCallStateForPhoneId的调用<ol>
<li>framewords/opt/telephony/src/java/com/android/internal/telephony/DefaultPhoneNotifier.java:66: mRegistry.notifyCallStateForPhoneId(phoneId, subId,<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void notifyPhoneState(Phone sender) &#123;</div><div class="line">    Rlog.d(LOG_TAG, &quot;jin DefaultPhoneNotifier notifyPhoneState&quot;)</div><div class="line">    Call ringingCall = sender.getRingingCall();</div><div class="line">    int subId = sender.getSubId();</div><div class="line">    int phoneId = sender.getPhoneId();</div><div class="line">    String incomingNumber = &quot;&quot;;</div><div class="line">    if (ringingCall != null &amp;&amp; ringingCall.getEarliestConnection() != null) &#123;</div><div class="line">        incomingNumber = ringingCall.getEarliestConnection().getAddress();</div><div class="line">    &#125;</div><div class="line">    try &#123;</div><div class="line">        if (mRegistry != null) &#123;</div><div class="line">            Rlog.d(LOG_TAG, &quot;jin noti DefaultPhoneNotifier notifyPhoneState: mRegistry=&quot;</div><div class="line">                + mRegistry + &quot; ss=&quot; + sender.getSignalStrength() + &quot; sender=&quot; + sender</div><div class="line">                + &quot; phoneId&quot; + phoneId + &quot; subId&quot; + subId + &quot; sender.getsate()&quot;</div><div class="line">                + sender.getState() + &quot; incomingNumber&quot; + incomingNumber);</div><div class="line">            //在这里</div><div class="line">            mRegistry.notifyCallStateForPhoneId(phoneId, subId,</div><div class="line">                    convertCallState(sender.getState()), incomingNumber);</div><div class="line">            Rlog.d(LOG_TAG, &quot;jin noti DefaultPhoneNotifier notifyRealCallStateForPhoneId: mRegistry=&quot;</div><div class="line">                + mRegistry + &quot; ss=&quot; + sender.getSignalStrength() + &quot; sender=&quot; + sender</div><div class="line">                + &quot; phoneId&quot; + phoneId + &quot; subId&quot; + subId + &quot; ringingCall.getState()&quot;</div><div class="line">                + ringingCall.getState() + &quot; incomingNumber&quot; + incomingNumber);</div><div class="line">            //加上这个</div><div class="line">            mRegistry.notifyRealCallStateForPhoneId(phoneId, subId,</div><div class="line">                    ringingCall.getRealState(), incomingNumber);</div><div class="line">        &#125;</div><div class="line">    &#125; catch (RemoteException ex) &#123;</div><div class="line">        // system process is dead</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<p>同样增加notifyRealCallStateForPhoneId,使用getRealState()</p>
<p><strong>修改permission</strong><br>frameworks/base/core/res/AndroidManifest.xml</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/08/30/rom7-0-phone/" data-id="cje6pjw32006xweyxzuyf9nhg" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Anrom/">Anrom</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-cjdns-SuperNodeHunter" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/28/cjdns-SuperNodeHunter/" class="article-date">
  <time datetime="2017-08-28T07:24:44.000Z" itemprop="datePublished">2017-08-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/cjdns/">cjdns</a>►<a class="article-category-link" href="/categories/cjdns/cjdns源码分析/">cjdns源码分析</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/28/cjdns-SuperNodeHunter/">初探Supernode</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="supernode相关API"><a href="#supernode相关API" class="headerlink" title="supernode相关API"></a>supernode相关API</h2><h3 id="Snodes系列"><a href="#Snodes系列" class="headerlink" title="Snodes系列"></a>Snodes系列</h3><p>这一系列有三个API：</p>
<ul>
<li>SupernodeHunter_addSnode</li>
<li>SupernodeHunter_removeSnode</li>
<li>SupernodeHunter_listSnodes</li>
</ul>
<p>他们都对snp-&gt;authorizedSnodes进行操作，增加/删除/列出snp-&gt;authorizedSnodes中的地址。<br>目前，这三个API都是没有用到的。<br>如果在conf文件中配置了supernodes，则会调用到SupernodeHunter_addSnode，增加一个snode</p>
<p>authorizedSnodes的定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">struct SupernodeHunter_pvt</div><div class="line">&#123;</div><div class="line">    struct SupernodeHunter pub;</div><div class="line"></div><div class="line">    /** Nodes which are authorized to be our supernode. */</div><div class="line">    struct AddrSet* authorizedSnodes;</div><div class="line"></div><div class="line">    /** Our peers, DO NOT TOUCH, changed from in SubnodePathfinder. */</div><div class="line">    struct AddrSet* peers;</div><div class="line"></div><div class="line">    // Number of the next peer to ping in the peers AddrSet</div><div class="line">    int nextPeer;</div><div class="line"></div><div class="line">    // Will be set to the best known supernode possibility</div><div class="line">    struct Address snodeCandidate;</div><div class="line"></div><div class="line">    bool snodePathUpdated;</div><div class="line"></div><div class="line">    struct Allocator* alloc;</div><div class="line"></div><div class="line">    struct Log* log;</div><div class="line"></div><div class="line">    struct MsgCore* msgCore;</div><div class="line"></div><div class="line">    struct EventBase* base;</div><div class="line"></div><div class="line">    struct SwitchPinger* sp;</div><div class="line"></div><div class="line">    struct Address* myAddress;</div><div class="line">    String* selfAddrStr;</div><div class="line"></div><div class="line">    Identity</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct AddrSet_pvt</div><div class="line">&#123;</div><div class="line">    struct AddrSet pub;</div><div class="line">    struct ArrayList_OfAddrs* addrList;</div><div class="line">    struct Allocator* alloc;</div><div class="line">    Identity</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>可见，authorizedSnodes最核心的内容，是一个ArrayList。</p>
<p>列出三个API的具体代码：</p>
<ol>
<li>SupernodeHunter_addSnode<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">static void addSnode(Dict* args, void* vcontext, String* txid, struct Allocator* requestAlloc)</div><div class="line">&#123;</div><div class="line">    struct Context* ctx = Identity_check((struct Context*) vcontext);</div><div class="line">    struct Address* addr = getAddr(args, requestAlloc);</div><div class="line">    if (!addr) &#123;</div><div class="line">        sendError(ctx, txid, requestAlloc, &quot;parse_error&quot;);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    int ret = SupernodeHunter_addSnode(ctx-&gt;snh, addr);</div><div class="line">    char* err;</div><div class="line">    switch (ret) &#123;</div><div class="line">        case SupernodeHunter_addSnode_EXISTS: &#123;</div><div class="line">            err = &quot;SupernodeHunter_addSnode_EXISTS&quot;;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">        case 0: &#123;</div><div class="line">            err = &quot;none&quot;;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">        default: &#123;</div><div class="line">            err = &quot;UNKNOWN&quot;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    sendError(ctx, txid, requestAlloc, err);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">int SupernodeHunter_addSnode(struct SupernodeHunter* snh, struct Address* snodeAddr)</div><div class="line">&#123;</div><div class="line">    struct SupernodeHunter_pvt* snp = Identity_check((struct SupernodeHunter_pvt*) snh);</div><div class="line">    int length0 = snp-&gt;authorizedSnodes-&gt;length;</div><div class="line">    AddrSet_add(snp-&gt;authorizedSnodes, snodeAddr);</div><div class="line">    if (snp-&gt;authorizedSnodes-&gt;length == length0) &#123;</div><div class="line">        return SupernodeHunter_addSnode_EXISTS;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>SupernodeHunter_removeSnode<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">static void removeSnode(Dict* args, void* vcontext, String* txid, struct Allocator* requestAlloc)</div><div class="line">&#123;</div><div class="line">    struct Context* ctx = Identity_check((struct Context*) vcontext);</div><div class="line">    struct Address* addr = getAddr(args, requestAlloc);</div><div class="line">    if (!addr) &#123;</div><div class="line">        sendError(ctx, txid, requestAlloc, &quot;parse_error&quot;);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    int ret = SupernodeHunter_removeSnode(ctx-&gt;snh, addr);</div><div class="line">    char* err;</div><div class="line">    switch (ret) &#123;</div><div class="line">        case SupernodeHunter_removeSnode_NONEXISTANT: &#123;</div><div class="line">            err = &quot;SupernodeHunter_removeSnode_NONEXISTANT&quot;;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">        case 0: &#123;</div><div class="line">            err = &quot;none&quot;;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">        default: &#123;</div><div class="line">            err = &quot;UNKNOWN&quot;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    sendError(ctx, txid, requestAlloc, err);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">int SupernodeHunter_removeSnode(struct SupernodeHunter* snh, struct Address* toRemove)</div><div class="line">&#123;</div><div class="line">    struct SupernodeHunter_pvt* snp = Identity_check((struct SupernodeHunter_pvt*) snh);</div><div class="line">    int length0 = snp-&gt;authorizedSnodes-&gt;length;</div><div class="line">    AddrSet_remove(snp-&gt;authorizedSnodes, toRemove);</div><div class="line">    if (snp-&gt;authorizedSnodes-&gt;length == length0) &#123;</div><div class="line">        return SupernodeHunter_removeSnode_NONEXISTANT;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>SupernodeHunter_listSnodes<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">static void listSnodes(Dict* args, void* vcontext, String* txid, struct Allocator* requestAlloc)</div><div class="line">&#123;</div><div class="line">    struct Context* ctx = Identity_check((struct Context*) vcontext);</div><div class="line">    int page = 0;</div><div class="line">    int64_t* pageP = Dict_getIntC(args, &quot;page&quot;);</div><div class="line">    if (pageP &amp;&amp; *pageP &gt; 0) &#123; page = *pageP; &#125;</div><div class="line"></div><div class="line">    struct Address** snodes;</div><div class="line">    int count = SupernodeHunter_listSnodes(ctx-&gt;snh, &amp;snodes, requestAlloc);</div><div class="line">    List* snodeList = List_new(requestAlloc);</div><div class="line">    for (int i = page * NODES_PER_PAGE, j = 0; i &lt; count &amp;&amp; j &lt; NODES_PER_PAGE; i++, j++) &#123;</div><div class="line">        List_addString(snodeList, Key_stringify(snodes[i]-&gt;key, requestAlloc), requestAlloc);</div><div class="line">    &#125;</div><div class="line">    Dict* out = Dict_new(requestAlloc);</div><div class="line">    Dict_putListC(out, &quot;snodes&quot;, snodeList, requestAlloc);</div><div class="line">    Dict_putStringCC(out, &quot;error&quot;, &quot;none&quot;, requestAlloc);</div><div class="line">    Admin_sendMessage(out, txid, ctx-&gt;admin);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">int SupernodeHunter_listSnodes(struct SupernodeHunter* snh,</div><div class="line">                               struct Address*** outP,</div><div class="line">                               struct Allocator* alloc)</div><div class="line">&#123;</div><div class="line">    struct SupernodeHunter_pvt* snp = Identity_check((struct SupernodeHunter_pvt*) snh);</div><div class="line">    struct Address** out = Allocator_calloc(alloc, sizeof(char*), snp-&gt;authorizedSnodes-&gt;length);</div><div class="line">    for (int i = 0; i &lt; snp-&gt;authorizedSnodes-&gt;length; i++) &#123;</div><div class="line">        out[i] = AddrSet_get(snp-&gt;authorizedSnodes, i);</div><div class="line">    &#125;</div><div class="line">    *outP = out;</div><div class="line">    return snp-&gt;authorizedSnodes-&gt;length;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当运行./cexec  “SupernodeHunter_listSnodes()”时，返回结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;error&quot;: &quot;none&quot;,</div><div class="line">  &quot;snodes&quot;: [],</div><div class="line">  &quot;txid&quot;: &quot;2764470409&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在当前的系统中，snp-&gt;authorizedSnodes其实是空的。也就是说，普通点使用的snode，不是通过addSnode加进来的，也没有通过其他方法加入到snp-&gt;authorizedSnodes中。</p>
<h3 id="snode状态查看"><a href="#snode状态查看" class="headerlink" title="snode状态查看"></a>snode状态查看</h3><p>SupernodeHunter_status<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">static void status(Dict* args, void* vcontext, String* txid, struct Allocator* requestAlloc)</div><div class="line">&#123;</div><div class="line">    struct Context* ctx = Identity_check((struct Context*) vcontext);</div><div class="line">    char* activeSnode = &quot;NONE&quot;;</div><div class="line">    Dict* out = Dict_new(requestAlloc);</div><div class="line">    if (ctx-&gt;snh-&gt;snodeIsReachable) &#123;</div><div class="line">        String* as = Address_toString(&amp;ctx-&gt;snh-&gt;snodeAddr, requestAlloc);</div><div class="line">        activeSnode = as-&gt;bytes;</div><div class="line">    &#125;</div><div class="line">    Dict_putStringCC(out, &quot;state&quot;,</div><div class="line">        (ctx-&gt;snh-&gt;snodeIsReachable&gt;0)? &quot;REACHABLE&quot;:&quot;UNREACHABLE&quot;, requestAlloc);</div><div class="line">    Dict_putIntC(out, &quot;usingAuthorizedSnode&quot;, ctx-&gt;snh-&gt;snodeIsReachable &gt; 1, requestAlloc);</div><div class="line">    Dict_putStringCC(out, &quot;activeSnode&quot;, activeSnode, requestAlloc);</div><div class="line">    Dict_putStringCC(out, &quot;error&quot;, &quot;none&quot;, requestAlloc);</div><div class="line">    Admin_sendMessage(out, txid, ctx-&gt;admin);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当运行./cexec   “SupernodeHunter_status()”时，返回结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;activeSnode&quot;: &quot;v20.0000.0000.0000.0153.r3919swdqt8022xwf3dq8y4uwn8t87f38qsw7fkjzl7x6h358s20.k&quot;,</div><div class="line">  &quot;error&quot;: &quot;none&quot;,</div><div class="line">  &quot;state&quot;: &quot;REACHABLE&quot;,</div><div class="line">  &quot;txid&quot;: &quot;589537837&quot;,</div><div class="line">  &quot;usingAuthorizedSnode&quot;: &quot;0&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>需要特别注意的是state字段和usingAuthorizedSnode字段，他们都是由ctx-&gt;snh-&gt;snodeIsReachable获得的，代码中有两个地方对他赋值：一个是从peer得到snode路径；一个是从snode处获得最佳路径。这两个得方的赋值方法都一样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">snp-&gt;pub.snodeIsReachable = (AddrSet_indexOf(snp-&gt;authorizedSnodes, src) != -1) ? 2 : 1;</div></pre></td></tr></table></figure></p>
<p>snp-&gt;pub.snodeIsReachable的值取决于snp-&gt;authorizedSnodes中是否有src，src是snode的地址。前面提到过，snp-&gt;authorizedSnodes是空的，所以，snp-&gt;pub.snodeIsReachable的值是1.也就决定了state是REACHABLE，而usingAuthorizedSnode是0.</p>
<h2 id="普通点的SuperNode启用流程"><a href="#普通点的SuperNode启用流程" class="headerlink" title="普通点的SuperNode启用流程"></a>普通点的SuperNode启用流程</h2><h3 id="1-Core-init"><a href="#1-Core-init" class="headerlink" title="1. Core_init"></a>1. Core_init</h3><p>admin/angel/Core.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// The link between the Pathfinder and the core needs to be asynchronous.</div><div class="line">struct SubnodePathfinder* spf = SubnodePathfinder_new(</div><div class="line">    alloc, logger, eventBase, rand, nc-&gt;myAddress, privateKey, encodingScheme, notification);</div><div class="line">struct ASynchronizer* spfAsync = ASynchronizer_new(alloc, eventBase, logger);</div><div class="line">Iface_plumb(&amp;spfAsync-&gt;ifA, &amp;spf-&gt;eventIf);</div><div class="line">EventEmitter_regPathfinderIface(nc-&gt;ee, &amp;spfAsync-&gt;ifB);</div><div class="line"></div><div class="line">#ifndef SUBNODE</div><div class="line">    struct Pathfinder* opf = Pathfinder_register(alloc, logger, eventBase, rand, admin);</div><div class="line">    struct ASynchronizer* opfAsync = ASynchronizer_new(alloc, eventBase, logger);</div><div class="line">    Iface_plumb(&amp;opfAsync-&gt;ifA, &amp;opf-&gt;eventIf);</div><div class="line">    EventEmitter_regPathfinderIface(nc-&gt;ee, &amp;opfAsync-&gt;ifB);</div><div class="line">#endif</div><div class="line"></div><div class="line">SubnodePathfinder_start(spf);</div></pre></td></tr></table></figure></p>
<h3 id="2-SubnodePathfinder-start"><a href="#2-SubnodePathfinder-start" class="headerlink" title="2. SubnodePathfinder_start()"></a>2. SubnodePathfinder_start()</h3><p>subnode/SubnodePathfinder.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">void SubnodePathfinder_start(struct SubnodePathfinder* sp)</div><div class="line">&#123;</div><div class="line">    struct SubnodePathfinder_pvt* pf = Identity_check((struct SubnodePathfinder_pvt*) sp);</div><div class="line">    pf-&gt;msgCore = MsgCore_new(pf-&gt;base, pf-&gt;rand, pf-&gt;alloc, pf-&gt;log, pf-&gt;myScheme);</div><div class="line">    Iface_plumb(&amp;pf-&gt;msgCoreIf, &amp;pf-&gt;msgCore-&gt;interRouterIf);</div><div class="line"></div><div class="line">    PingResponder_new(pf-&gt;alloc, pf-&gt;log, pf-&gt;msgCore, pf-&gt;br);</div><div class="line"></div><div class="line">    GetPeersResponder_new(</div><div class="line">        pf-&gt;alloc, pf-&gt;log, pf-&gt;myPeers, pf-&gt;myAddress, pf-&gt;msgCore, pf-&gt;br, pf-&gt;myScheme);</div><div class="line"></div><div class="line">    pf-&gt;pub.snh = SupernodeHunter_new(</div><div class="line">        pf-&gt;alloc, pf-&gt;log, pf-&gt;base, pf-&gt;sp, pf-&gt;myPeers, pf-&gt;msgCore,</div><div class="line">                            pf-&gt;myAddress, pf-&gt;notification);</div><div class="line"></div><div class="line">    pf-&gt;ra = ReachabilityAnnouncer_new(</div><div class="line">        pf-&gt;alloc, pf-&gt;log, pf-&gt;base, pf-&gt;rand, pf-&gt;msgCore, pf-&gt;pub.snh, pf-&gt;privateKey,</div><div class="line">            pf-&gt;myScheme);</div><div class="line"></div><div class="line">    pf-&gt;pub.rc = ReachabilityCollector_new(</div><div class="line">        pf-&gt;alloc, pf-&gt;msgCore, pf-&gt;log, pf-&gt;base, pf-&gt;br, pf-&gt;myAddress);</div><div class="line"></div><div class="line">    pf-&gt;pub.rc-&gt;userData = pf;</div><div class="line">    pf-&gt;pub.rc-&gt;onChange = rcChange;</div><div class="line"></div><div class="line">    struct PFChan_Pathfinder_Connect conn = &#123;</div><div class="line">        .superiority_be = Endian_hostToBigEndian32(1),</div><div class="line">        .version_be = Endian_hostToBigEndian32(Version_CURRENT_PROTOCOL)</div><div class="line">    &#125;;</div><div class="line">    CString_strncpy(conn.userAgent, &quot;Anet subnode pathfinder&quot;, 64);</div><div class="line">    sendEvent(pf, PFChan_Pathfinder_CONNECT, &amp;conn, PFChan_Pathfinder_Connect_SIZE);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="3-SupernodeHunter-new"><a href="#3-SupernodeHunter-new" class="headerlink" title="3. SupernodeHunter_new"></a>3. SupernodeHunter_new</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">struct SupernodeHunter* SupernodeHunter_new(struct Allocator* allocator,</div><div class="line">                                            struct Log* log,</div><div class="line">                                            struct EventBase* base,</div><div class="line">                                            struct SwitchPinger* sp,</div><div class="line">                                            struct AddrSet* peers,</div><div class="line">                                            struct MsgCore* msgCore,</div><div class="line">                                            struct Address* myAddress,</div><div class="line">                                            struct Notification* notification)</div><div class="line">&#123;</div><div class="line">    struct Allocator* alloc = Allocator_child(allocator);</div><div class="line">    struct SupernodeHunter_pvt* out =</div><div class="line">        Allocator_calloc(alloc, sizeof(struct SupernodeHunter_pvt), 1);</div><div class="line">    Identity_set(out);</div><div class="line">    out-&gt;authorizedSnodes = AddrSet_new(alloc);</div><div class="line">    out-&gt;peers = peers;</div><div class="line">    out-&gt;base = base;</div><div class="line">    out-&gt;pub.notification = notification;</div><div class="line">    //out-&gt;rand = rand;</div><div class="line">    //out-&gt;nodes = AddrSet_new(alloc);</div><div class="line">    //out-&gt;timeSnodeCalled = Time_currentTimeMilliseconds(base);</div><div class="line">    //out-&gt;snodeCandidates = AddrSet_new(alloc);</div><div class="line">    out-&gt;log = log;</div><div class="line">    out-&gt;alloc = alloc;</div><div class="line">    out-&gt;msgCore = msgCore;</div><div class="line">    out-&gt;myAddress = myAddress;</div><div class="line">    out-&gt;selfAddrStr = String_newBinary(myAddress-&gt;ip6.bytes, 16, alloc);</div><div class="line">    out-&gt;sp = sp;</div><div class="line">    out-&gt;snodePathUpdated = false;</div><div class="line">    out-&gt;pub.onSnodeUnreachable = onSnodeUnreachable;</div><div class="line">    Timeout_setInterval(probePeerCycle, out, CYCLE_MS, base, alloc);</div><div class="line">    return &amp;out-&gt;pub;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-probePeerCycle"><a href="#4-probePeerCycle" class="headerlink" title="4. probePeerCycle"></a>4. probePeerCycle</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">static void probePeerCycle(void* vsn)</div><div class="line">&#123;</div><div class="line">    struct SupernodeHunter_pvt* snp = Identity_check((struct SupernodeHunter_pvt*) vsn);</div><div class="line"></div><div class="line">    if (snp-&gt;pub.snodeIsReachable &amp;&amp; !snp-&gt;snodePathUpdated) &#123;</div><div class="line">        updateSnodePath(snp);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (snp-&gt;pub.snodeIsReachable &gt; 1) &#123; return; &#125;</div><div class="line">    if (snp-&gt;pub.snodeIsReachable &amp;&amp; !snp-&gt;authorizedSnodes-&gt;length) &#123; return; &#125;</div><div class="line">    if (!snp-&gt;peers-&gt;length) &#123; return; &#125;</div><div class="line"></div><div class="line">    //Log_debug(snp-&gt;log, &quot;probePeerCycle()&quot;);</div><div class="line"></div><div class="line">    if (AddrSet_indexOf(snp-&gt;authorizedSnodes, snp-&gt;myAddress) != -1) &#123;</div><div class="line">        Log_info(snp-&gt;log, &quot;Self is specified as supernode, pinging...&quot;);</div><div class="line">        adoptSupernode(snp, snp-&gt;myAddress);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    struct Address* peer = getPeerByNpn(snp, snp-&gt;nextPeer);</div><div class="line">    if (!peer) &#123;</div><div class="line">        Log_info(snp-&gt;log, &quot;No peer found who is version &gt;= 20&quot;);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    snp-&gt;nextPeer++;</div><div class="line"></div><div class="line">    struct SwitchPinger_Ping* p =</div><div class="line">        SwitchPinger_newPing(peer-&gt;path, String_CONST(&quot;&quot;), 3000, peerResponse, snp-&gt;alloc, snp-&gt;sp);</div><div class="line">    Assert_true(p);</div><div class="line"></div><div class="line">    p-&gt;type = SwitchPinger_Type_GETSNODE;</div><div class="line">    if (snp-&gt;pub.snodeIsReachable) &#123;</div><div class="line">        Bits_memcpy(&amp;p-&gt;snode, &amp;snp-&gt;pub.snodeAddr, sizeof(struct Address));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    p-&gt;onResponseContext = snp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当首次调用到这里，snp-&gt;pub.snodeIsReachable为false，snp-&gt;snodePathUpdate为false，snp-&gt;authorizedSnodes为空。<br>直接到这里开始执行，首先遍历自己的peer，依次问每个peer，找到version大于等于20的peer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">struct Address* peer = getPeerByNpn(snp, snp-&gt;nextPeer);</div><div class="line">if (!peer) &#123;</div><div class="line">    Log_info(snp-&gt;log, &quot;No peer found who is version &gt;= 20&quot;);</div><div class="line">    return;</div><div class="line">&#125;</div><div class="line">snp-&gt;nextPeer++;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">static struct Address* getPeerByNpn(struct SupernodeHunter_pvt* snp, int npn)</div><div class="line">&#123;</div><div class="line">    npn = npn % snp-&gt;peers-&gt;length;</div><div class="line">    int i = npn;</div><div class="line">    do &#123;</div><div class="line">        struct Address* peer = AddrSet_get(snp-&gt;peers, i);</div><div class="line">        if (peer &amp;&amp; peer-&gt;protocolVersion &gt; 19) &#123; return peer; &#125;</div><div class="line">        i = (i + 1) % snp-&gt;peers-&gt;length;</div><div class="line">    &#125; while (i != npn);</div><div class="line">    return NULL;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后问这个peer，snode在哪里<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">struct SwitchPinger_Ping* p =</div><div class="line">    SwitchPinger_newPing(peer-&gt;path, String_CONST(&quot;&quot;), 3000, peerResponse, snp-&gt;alloc, snp-&gt;sp);</div><div class="line">Assert_true(p);</div><div class="line"></div><div class="line">p-&gt;type = SwitchPinger_Type_GETSNODE;</div><div class="line">if (snp-&gt;pub.snodeIsReachable) &#123;</div><div class="line">    Bits_memcpy(&amp;p-&gt;snode, &amp;snp-&gt;pub.snodeAddr, sizeof(struct Address));</div><div class="line">&#125;</div><div class="line"></div><div class="line">p-&gt;onResponseContext = snp;</div></pre></td></tr></table></figure></p>
<p>发送了一个SwitchPinger_Ping，type是SwitchPinger_Type_GETSNODE.回调函数是peerResponse<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">static void peerResponse(struct SwitchPinger_Response* resp, void* userData)</div><div class="line">&#123;</div><div class="line">    struct SupernodeHunter_pvt* snp = Identity_check((struct SupernodeHunter_pvt*) userData);</div><div class="line">    char* err = &quot;&quot;;</div><div class="line">    switch (resp-&gt;res) &#123;</div><div class="line">        case SwitchPinger_Result_OK: peerResponseOK(resp, snp); return;</div><div class="line">        case SwitchPinger_Result_LABEL_MISMATCH: err = &quot;LABEL_MISMATCH&quot;; break;</div><div class="line">        case SwitchPinger_Result_WRONG_DATA: err = &quot;WRONG_DATA&quot;; break;</div><div class="line">        case SwitchPinger_Result_ERROR_RESPONSE: err = &quot;ERROR_RESPONSE&quot;; break;</div><div class="line">        case SwitchPinger_Result_LOOP_ROUTE: err = &quot;LOOP_ROUTE&quot;; break;</div><div class="line">        case SwitchPinger_Result_TIMEOUT: err = &quot;TIMEOUT&quot;; break;</div><div class="line">        default: err = &quot;unknown error&quot;; break;</div><div class="line">    &#125;</div><div class="line">    Log_debug(snp-&gt;log, &quot;Error sending snp query to peer [%s]&quot;, err);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>正常情况下，应该收到SwitchPinger_Result_OK，调用peerResponseOK<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">static void peerResponseOK(struct SwitchPinger_Response* resp, struct SupernodeHunter_pvt* snp)</div><div class="line">&#123;</div><div class="line">    struct Address snode;</div><div class="line">    Bits_memcpy(&amp;snode, &amp;resp-&gt;snode, sizeof(struct Address));</div><div class="line">    if (!snode.path) &#123;</div><div class="line">        uint8_t label[20];</div><div class="line">        AddrTools_printPath(label, resp-&gt;label);</div><div class="line">        Log_debug(snp-&gt;log, &quot;Peer [%s] reports no supernode&quot;, label);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    uint64_t path = LabelSplicer_splice(snode.path, resp-&gt;label);</div><div class="line">    if (path == UINT64_MAX) &#123;</div><div class="line">        Log_debug(snp-&gt;log, &quot;Supernode path could not be spliced&quot;);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    snode.path = path;</div><div class="line"></div><div class="line">    struct Address* firstPeer = getPeerByNpn(snp, 0);</div><div class="line">    if (!firstPeer) &#123;</div><div class="line">        Log_info(snp-&gt;log, &quot;All peers have gone away while packet was outstanding&quot;);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 1.</div><div class="line">    // If we have looped around and queried all of our peers returning to the first and we have</div><div class="line">    // still not found an snode in our authorized snodes list, we should simply accept this one.</div><div class="line">    if (!snp-&gt;pub.snodeIsReachable &amp;&amp; snp-&gt;nextPeer &gt; 1 &amp;&amp; firstPeer-&gt;path == resp-&gt;label) &#123;</div><div class="line">        if (!snp-&gt;snodeCandidate.path) &#123;</div><div class="line">            Log_info(snp-&gt;log, &quot;No snode candidate found&quot;);</div><div class="line">            snp-&gt;nextPeer = 0;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        if (Bits_memcmp(&amp;snp-&gt;snodeCandidate, &amp;snp-&gt;pub.snodeAddr, Address_SIZE)) &#123;</div><div class="line">            Log_info(snp-&gt;log, &quot;SnodeAddr != snodeCandidate&quot;);</div><div class="line">            snp-&gt;nextPeer = 0;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        adoptSupernode(snp, &amp;snp-&gt;snodeCandidate);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 2.</div><div class="line">    // If this snode is one of our authorized snodes OR if we have none defined, accept this one.</div><div class="line">    if (!snp-&gt;authorizedSnodes-&gt;length || AddrSet_indexOf(snp-&gt;authorizedSnodes, &amp;snode) &gt; -1) &#123;</div><div class="line">        Address_getPrefix(&amp;snode);</div><div class="line">        adoptSupernode(snp, &amp;snode);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (!snp-&gt;snodeCandidate.path) &#123;</div><div class="line">        Bits_memcpy(&amp;snp-&gt;snodeCandidate, &amp;snode, sizeof(struct Address));</div><div class="line">        Address_getPrefix(&amp;snp-&gt;snodeCandidate);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里分了两种情况来添加snode，对于第一次调用到此处的普通点，它会将peer告诉他的snode地址设置成自己的snode，调用adoptSupernode，试图和snode联系<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">static void adoptSupernode(struct SupernodeHunter_pvt* snp, struct Address* candidate)</div><div class="line">&#123;</div><div class="line">    struct MsgCore_Promise* qp = MsgCore_createQuery(snp-&gt;msgCore, 0, snp-&gt;alloc);</div><div class="line">    struct Query* q = Allocator_calloc(qp-&gt;alloc, sizeof(struct Query), 1);</div><div class="line">    Identity_set(q);</div><div class="line">    q-&gt;snp = snp;</div><div class="line">    q-&gt;sendTime = Time_currentTimeMilliseconds(snp-&gt;base);</div><div class="line"></div><div class="line">    Dict* msg = qp-&gt;msg = Dict_new(qp-&gt;alloc);</div><div class="line">    qp-&gt;cb = adoptSupernode2;</div><div class="line">    qp-&gt;userData = q;</div><div class="line">    qp-&gt;target = Address_clone(candidate, qp-&gt;alloc);</div><div class="line"></div><div class="line">    Log_debug(snp-&gt;log, &quot;Pinging snode [%s]&quot;, Address_toString(qp-&gt;target, qp-&gt;alloc)-&gt;bytes);</div><div class="line">    Dict_putStringCC(msg, &quot;sq&quot;, &quot;pn&quot;, qp-&gt;alloc);</div><div class="line"></div><div class="line">    Assert_true(AddressCalc_validAddress(candidate-&gt;ip6.bytes));</div><div class="line">    return;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>回调函数是adoptSupernode2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">static void adoptSupernode2(Dict* msg, struct Address* src, struct MsgCore_Promise* prom)</div><div class="line">&#123;</div><div class="line">    struct Query* q = Identity_check((struct Query*) prom-&gt;userData);</div><div class="line">    struct SupernodeHunter_pvt* snp = Identity_check(q-&gt;snp);</div><div class="line"></div><div class="line">    if (!src) &#123;</div><div class="line">        String* addrStr = Address_toString(prom-&gt;target, prom-&gt;alloc);</div><div class="line">        Log_debug(snp-&gt;log, &quot;timeout sending to %s&quot;, addrStr-&gt;bytes);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    String* addrStr = Address_toString(src, prom-&gt;alloc);</div><div class="line">    Log_debug(snp-&gt;log, &quot;Reply from %s&quot;, addrStr-&gt;bytes);</div><div class="line"></div><div class="line">    int64_t* snodeRecvTime = Dict_getIntC(msg, &quot;recvTime&quot;);</div><div class="line">    if (!snodeRecvTime) &#123;</div><div class="line">        Log_info(snp-&gt;log, &quot;getRoute reply with no timeStamp, bad snode&quot;);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    Log_debug(snp-&gt;log, &quot;\n\nSupernode location confirmed [%s]\n\n&quot;,</div><div class="line">        Address_toString(src, prom-&gt;alloc)-&gt;bytes);</div><div class="line">    if (snp-&gt;pub.snodeIsReachable) &#123;</div><div class="line">        // If while we were searching, the outside code declared that indeed the snode</div><div class="line">        // is reachable, we will not try to change their snode.</div><div class="line">    &#125; else if (snp-&gt;pub.onSnodeChange) &#123;</div><div class="line">        Bits_memcpy(&amp;snp-&gt;pub.snodeAddr, src, Address_SIZE);</div><div class="line">        snp-&gt;pub.snodeIsReachable = (AddrSet_indexOf(snp-&gt;authorizedSnodes, src) != -1) ? 2 : 1;</div><div class="line">        snp-&gt;pub.onSnodeChange(&amp;snp-&gt;pub, q-&gt;sendTime, *snodeRecvTime);</div><div class="line">        Notification_doNotify(snp-&gt;pub.notification, SNODE_REACHABLE,REACHABLE);</div><div class="line">    &#125; else &#123;</div><div class="line">        Log_warn(snp-&gt;log, &quot;onSnodeChange is not set&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>主要操作是：将snode的地址设置到snp-&gt;pub.snodeAddr，更新snp-&gt;pub.snodeIsReachable的值，调用snp-&gt;pub.onSnodeChange<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">static void onSnodeChange(struct SupernodeHunter* sh,</div><div class="line">                          int64_t sendTime,</div><div class="line">                          int64_t snodeRecvTime)</div><div class="line">&#123;</div><div class="line">    struct ReachabilityAnnouncer_pvt* rap =</div><div class="line">        Identity_check((struct ReachabilityAnnouncer_pvt*) sh-&gt;userData);</div><div class="line">    int64_t clockSkew = estimateClockSkew(sendTime, snodeRecvTime, ourTime(rap));</div><div class="line">    uint64_t clockSkewDiff = (clockSkew - rap-&gt;clockSkew) &amp; ~(((uint64_t)1)&lt;&lt;63);</div><div class="line">    // If the node is the same and the clock skew difference is less than 10 seconds,</div><div class="line">    // just change path and continue.</div><div class="line">    if (!Bits_memcmp(rap-&gt;snode.key, sh-&gt;snodeAddr.key, 32) &amp;&amp; clockSkewDiff &lt; 5000) &#123;</div><div class="line">        Log_debug(rap-&gt;log, &quot;Change Supernode (path only)&quot;);</div><div class="line">        Bits_memcpy(&amp;rap-&gt;snode, &amp;sh-&gt;snodeAddr, Address_SIZE);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    Log_debug(rap-&gt;log, &quot;Change Supernode&quot;);</div><div class="line">    Bits_memcpy(&amp;rap-&gt;snode, &amp;sh-&gt;snodeAddr, Address_SIZE);</div><div class="line">    rap-&gt;clockSkew = estimateClockSkew(sendTime, snodeRecvTime, ourTime(rap));</div><div class="line">    stateReset(rap);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>做了一些地址设置的操作，暂时不继续往下分析。<br>至此，普通点向peer询问snode地址，并与snode建立联系的过程分析完成。但这并没有结束，接下来，普通点还会向snode询问最佳路径。<br>回到<code>SupernodeHunter_new</code>中再看一次：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">struct SupernodeHunter* SupernodeHunter_new(struct Allocator* allocator,</div><div class="line">                                            struct Log* log,</div><div class="line">                                            struct EventBase* base,</div><div class="line">                                            struct SwitchPinger* sp,</div><div class="line">                                            struct AddrSet* peers,</div><div class="line">                                            struct MsgCore* msgCore,</div><div class="line">                                            struct Address* myAddress,</div><div class="line">                                            struct Notification* notification)</div><div class="line">&#123;</div><div class="line">    struct Allocator* alloc = Allocator_child(allocator);</div><div class="line">    struct SupernodeHunter_pvt* out =</div><div class="line">        Allocator_calloc(alloc, sizeof(struct SupernodeHunter_pvt), 1);</div><div class="line">    Identity_set(out);</div><div class="line">    out-&gt;authorizedSnodes = AddrSet_new(alloc);</div><div class="line">    out-&gt;peers = peers;</div><div class="line">    out-&gt;base = base;</div><div class="line">    out-&gt;pub.notification = notification;</div><div class="line">    //out-&gt;rand = rand;</div><div class="line">    //out-&gt;nodes = AddrSet_new(alloc);</div><div class="line">    //out-&gt;timeSnodeCalled = Time_currentTimeMilliseconds(base);</div><div class="line">    //out-&gt;snodeCandidates = AddrSet_new(alloc);</div><div class="line">    out-&gt;log = log;</div><div class="line">    out-&gt;alloc = alloc;</div><div class="line">    out-&gt;msgCore = msgCore;</div><div class="line">    out-&gt;myAddress = myAddress;</div><div class="line">    out-&gt;selfAddrStr = String_newBinary(myAddress-&gt;ip6.bytes, 16, alloc);</div><div class="line">    out-&gt;sp = sp;</div><div class="line">    out-&gt;snodePathUpdated = false;</div><div class="line">    out-&gt;pub.onSnodeUnreachable = onSnodeUnreachable;</div><div class="line">    Timeout_setInterval(probePeerCycle, out, CYCLE_MS, base, alloc);</div><div class="line">    return &amp;out-&gt;pub;</div></pre></td></tr></table></figure></p>
<p>可以看到，对probePeerCycle的调用，是一个周期性的行为，每CYCLE_MS时间调用一次，继续进入到probePeerCycle中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">static void probePeerCycle(void* vsn)</div><div class="line">&#123;</div><div class="line">    struct SupernodeHunter_pvt* snp = Identity_check((struct SupernodeHunter_pvt*) vsn);</div><div class="line"></div><div class="line">    if (snp-&gt;pub.snodeIsReachable &amp;&amp; !snp-&gt;snodePathUpdated) &#123;</div><div class="line">        updateSnodePath(snp);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (snp-&gt;pub.snodeIsReachable &gt; 1) &#123; return; &#125;</div><div class="line">    if (snp-&gt;pub.snodeIsReachable &amp;&amp; !snp-&gt;authorizedSnodes-&gt;length) &#123; return; &#125;</div><div class="line">    if (!snp-&gt;peers-&gt;length) &#123; return; &#125;</div><div class="line"></div><div class="line">    //Log_debug(snp-&gt;log, &quot;probePeerCycle()&quot;);</div><div class="line"></div><div class="line">    if (AddrSet_indexOf(snp-&gt;authorizedSnodes, snp-&gt;myAddress) != -1) &#123;</div><div class="line">        Log_info(snp-&gt;log, &quot;Self is specified as supernode, pinging...&quot;);</div><div class="line">        adoptSupernode(snp, snp-&gt;myAddress);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    struct Address* peer = getPeerByNpn(snp, snp-&gt;nextPeer);</div><div class="line">    if (!peer) &#123;</div><div class="line">        Log_info(snp-&gt;log, &quot;No peer found who is version &gt;= 20&quot;);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    snp-&gt;nextPeer++;</div><div class="line"></div><div class="line">    struct SwitchPinger_Ping* p =</div><div class="line">        SwitchPinger_newPing(peer-&gt;path, String_CONST(&quot;&quot;), 3000, peerResponse, snp-&gt;alloc, snp-&gt;sp);</div><div class="line">    Assert_true(p);</div><div class="line"></div><div class="line">    p-&gt;type = SwitchPinger_Type_GETSNODE;</div><div class="line">    if (snp-&gt;pub.snodeIsReachable) &#123;</div><div class="line">        Bits_memcpy(&amp;p-&gt;snode, &amp;snp-&gt;pub.snodeAddr, sizeof(struct Address));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    p-&gt;onResponseContext = snp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这一次，snp-&gt;pub.snodeIsReachable已经为true，调用updateSnodePath<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">static void updateSnodePath(struct SupernodeHunter_pvt* snp)</div><div class="line">&#123;</div><div class="line">    struct MsgCore_Promise* qp = MsgCore_createQuery(snp-&gt;msgCore, 0, snp-&gt;alloc);</div><div class="line">    struct Query* q = Allocator_calloc(qp-&gt;alloc, sizeof(struct Query), 1);</div><div class="line">    Identity_set(q);</div><div class="line">    q-&gt;snp = snp;</div><div class="line">    q-&gt;sendTime = Time_currentTimeMilliseconds(snp-&gt;base);</div><div class="line"></div><div class="line">    Dict* msg = qp-&gt;msg = Dict_new(qp-&gt;alloc);</div><div class="line">    qp-&gt;cb = updateSnodePath2;</div><div class="line">    qp-&gt;userData = q;</div><div class="line">    qp-&gt;target = Address_clone(&amp;snp-&gt;pub.snodeAddr, qp-&gt;alloc);;</div><div class="line"></div><div class="line">    Log_debug(snp-&gt;log, &quot;Update snode [%s] path&quot;, Address_toString(qp-&gt;target, qp-&gt;alloc)-&gt;bytes);</div><div class="line">    Dict_putStringCC(msg, &quot;sq&quot;, &quot;gr&quot;, qp-&gt;alloc);</div><div class="line">    String* src = String_newBinary(snp-&gt;myAddress-&gt;ip6.bytes, 16, qp-&gt;alloc);</div><div class="line">    Dict_putStringC(msg, &quot;src&quot;, src, qp-&gt;alloc);</div><div class="line">    String* target = String_newBinary(snp-&gt;pub.snodeAddr.ip6.bytes, 16, qp-&gt;alloc);</div><div class="line">    Dict_putStringC(msg, &quot;tar&quot;, target, qp-&gt;alloc);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>回调函数为updateSnodePath2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">static void updateSnodePath2(Dict* msg, struct Address* src, struct MsgCore_Promise* prom)</div><div class="line">&#123;</div><div class="line">    struct Query* q = Identity_check((struct Query*) prom-&gt;userData);</div><div class="line">    struct SupernodeHunter_pvt* snp = Identity_check(q-&gt;snp);</div><div class="line"></div><div class="line">    if (!src) &#123;</div><div class="line">        String* addrStr = Address_toString(prom-&gt;target, prom-&gt;alloc);</div><div class="line">        Log_debug(snp-&gt;log, &quot;timeout sending to %s&quot;, addrStr-&gt;bytes);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    int64_t* snodeRecvTime = Dict_getIntC(msg, &quot;recvTime&quot;);</div><div class="line">    if (!snodeRecvTime) &#123;</div><div class="line">        Log_info(snp-&gt;log, &quot;getRoute reply with no timeStamp, bad snode&quot;);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    struct Address_List* al = ReplySerializer_parse(src, msg, snp-&gt;log, false, prom-&gt;alloc);</div><div class="line">    if (!al || al-&gt;length == 0) &#123; return; &#125;</div><div class="line">    Log_debug(snp-&gt;log, &quot;Supernode path updated with[%s]&quot;,</div><div class="line">                        Address_toString(&amp;al-&gt;elems[0], prom-&gt;alloc)-&gt;bytes);</div><div class="line"></div><div class="line">    snp-&gt;snodePathUpdated = true;</div><div class="line">    if (!Bits_memcmp(&amp;snp-&gt;pub.snodeAddr, &amp;al-&gt;elems[0], Address_SIZE)) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    Bits_memcpy(&amp;snp-&gt;pub.snodeAddr, &amp;al-&gt;elems[0], Address_SIZE);</div><div class="line">    Bits_memcpy(&amp;snp-&gt;snodeCandidate, &amp;al-&gt;elems[0], Address_SIZE);</div><div class="line">    if (snp-&gt;pub.onSnodeChange) &#123;</div><div class="line">        snp-&gt;pub.snodeIsReachable = (AddrSet_indexOf(snp-&gt;authorizedSnodes, src) != -1) ? 2 : 1;</div><div class="line">        snp-&gt;pub.onSnodeChange(&amp;snp-&gt;pub, q-&gt;sendTime, *snodeRecvTime);</div><div class="line">        Notification_doNotify(snp-&gt;pub.notification, SNODE_REACHABLE,REACHABLE);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>主要操作是将path设置到snp-&gt;pub.snodeAddr和snp-&gt;snodeCandidate，将 snp-&gt;snodePathUpdated设为true。<br>这样，下次调用到probePeerCycle时，会进入到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if (snp-&gt;pub.snodeIsReachable &amp;&amp; !snp-&gt;authorizedSnodes-&gt;length) &#123; return; &#125;</div></pre></td></tr></table></figure></p>
<p>直接返回。这样，只要snodeIsReachable一直为true，就会一直返回。</p>
<h2 id="snode的SuperNode启动过程"><a href="#snode的SuperNode启动过程" class="headerlink" title="snode的SuperNode启动过程"></a>snode的SuperNode启动过程</h2><h3 id="conf文件分析"><a href="#conf文件分析" class="headerlink" title="conf文件分析"></a>conf文件分析</h3><p>snode的conf文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&quot;interfaces&quot;:&#123;</div><div class="line">	&quot;UDPInterface&quot;:[</div><div class="line">    	&#123;</div><div class="line">        	&quot;bind&quot;:&quot;0.0.0.0:34435&quot;,</div><div class="line">            &quot;connectTo&quot;:&#123;&#125;</div><div class="line">        &#125;</div><div class="line">    ],</div><div class="line">    ...</div><div class="line">&#125;,</div><div class="line">&quot;router&quot;:&#123;</div><div class="line">	&quot;supernodes&quot;:[</div><div class="line">    	&quot;r3919swdqt8022xwf3dq8y4uwn8t87f38qsw7fkjzl7x6h358s20.k&quot;</div><div class="line">    ],</div><div class="line">    ...</div><div class="line">    &quot;ipTunnel&quot;:&#123;</div><div class="line">    	&quot;allowedConnections&quot;:[],</div><div class="line">        &quot;outgoingConnections&quot;:[]</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对比起来，普通点的conf文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&quot;interfaces&quot;:&#123;</div><div class="line">	&quot;UDPInterface&quot;:[</div><div class="line">		&#123;</div><div class="line">			&quot;bind&quot;:&quot;0.0.0.0:26808&quot;,</div><div class="line">			&quot;connectTo&quot;:&#123;</div><div class="line">				&quot;106.75.59.53:50001&quot;:&#123;</div><div class="line">					&quot;password&quot;:&quot;XRuMWpgvNienefc7ZT8gXTuTCvSWWSA&quot;,</div><div class="line">					&quot;publicKey&quot;:&quot;nsn1nz93lztkg6zbw4yqnr6zlzxhchppzdkduwh9wh79p88fwx60.k&quot;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	],</div><div class="line">	...</div><div class="line">&#125;,</div><div class="line">&quot;router&quot;:&#123;</div><div class="line">	...</div><div class="line">	&quot;ipTunnel&quot;:&#123;</div><div class="line">		&quot;allowedConnections&quot;:[],</div><div class="line">		&quot;outgoingConnections&quot;:[</div><div class="line">			&quot;wfzyzrc0q4g83y0dgzxx1l862u0lscucj75yw9q1ymbltzwh2fq0.k&quot;</div><div class="line">		]</div><div class="line">	&#125;</div><div class="line">&#125;,</div></pre></td></tr></table></figure></p>
<p>snode的conf文件的不同主要体现在下面几点：</p>
<ol>
<li>interfaces的UDPInterface的connectTo为空，说明snode并不主动连接到任何点。</li>
<li>route的ipTunnel的outgoingConnetctions为空，说明snode并不将任何点设为离岸点。</li>
<li>在route中设置有snode，值为自己的pubkey。<br>关于上面两条，本文不做具体分析，重点关注与snode相关的内容，即第三条。</li>
</ol>
<p>当conf文件中配置有snode时，首先的影响就是会调用到增加snode的API接口：<code>SupernodeHunter_addSnode</code>。上面分析过，这个接口的作用是增加snode到snp-&gt;authorizedSnodes中。仅仅增加地址到snp-&gt;authorizedSnodes中，还远未完成整个snode的添加过程。接下来，分析snode是怎么把自己设置为snode的。</p>
<h3 id="snode的Super-Node设置"><a href="#snode的Super-Node设置" class="headerlink" title="snode的Super Node设置"></a>snode的Super Node设置</h3><p>snode的启动过程与普通点一样，不同点是从probePeerCycle方法中开始的，再次查看这个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">static void probePeerCycle(void* vsn)</div><div class="line">&#123;</div><div class="line">    struct SupernodeHunter_pvt* snp = Identity_check((struct SupernodeHunter_pvt*) vsn);</div><div class="line"></div><div class="line">    if (snp-&gt;pub.snodeIsReachable &amp;&amp; !snp-&gt;snodePathUpdated) &#123;</div><div class="line">        updateSnodePath(snp);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (snp-&gt;pub.snodeIsReachable &gt; 1) &#123; return; &#125;</div><div class="line">    if (snp-&gt;pub.snodeIsReachable &amp;&amp; !snp-&gt;authorizedSnodes-&gt;length) &#123; return; &#125;</div><div class="line">    if (!snp-&gt;peers-&gt;length) &#123; return; &#125;</div><div class="line"></div><div class="line">    //Log_debug(snp-&gt;log, &quot;probePeerCycle()&quot;);</div><div class="line"></div><div class="line">    if (AddrSet_indexOf(snp-&gt;authorizedSnodes, snp-&gt;myAddress) != -1) &#123;</div><div class="line">        Log_info(snp-&gt;log, &quot;Self is specified as supernode, pinging...&quot;);</div><div class="line">        adoptSupernode(snp, snp-&gt;myAddress);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    struct Address* peer = getPeerByNpn(snp, snp-&gt;nextPeer);</div><div class="line">    if (!peer) &#123;</div><div class="line">        Log_info(snp-&gt;log, &quot;No peer found who is version &gt;= 20&quot;);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    snp-&gt;nextPeer++;</div><div class="line"></div><div class="line">    struct SwitchPinger_Ping* p =</div><div class="line">        SwitchPinger_newPing(peer-&gt;path, String_CONST(&quot;&quot;), 3000, peerResponse, snp-&gt;alloc, snp-&gt;sp);</div><div class="line">    Assert_true(p);</div><div class="line"></div><div class="line">    p-&gt;type = SwitchPinger_Type_GETSNODE;</div><div class="line">    if (snp-&gt;pub.snodeIsReachable) &#123;</div><div class="line">        Bits_memcpy(&amp;p-&gt;snode, &amp;snp-&gt;pub.snodeAddr, sizeof(struct Address));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    p-&gt;onResponseContext = snp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当首次调用到这里，snp-&gt;pub.snodeIsReachable为false，snp-&gt;snodePathUpdate为false，snp-&gt;authorizedSnodes中是从conf中添加进来的snode，也就是自己。所以，会执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (AddrSet_indexOf(snp-&gt;authorizedSnodes, snp-&gt;myAddress) != -1) &#123;</div><div class="line">    Log_info(snp-&gt;log, &quot;Self is specified as supernode, pinging...&quot;);</div><div class="line">    adoptSupernode(snp, snp-&gt;myAddress);</div><div class="line">    return;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>将自己设置为snode，具体设置过程不再分析。<br>看一下API调用结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[root:sbu-snode]# ./cexec   &quot;SupernodeHunter_status()&quot;</div><div class="line">&#123;</div><div class="line">  &quot;activeSnode&quot;: &quot;v20.0000.0000.0000.0001.r3919swdqt8022xwf3dq8y4uwn8t87f38qsw7fkjzl7x6h358s20.k&quot;,</div><div class="line">  &quot;error&quot;: &quot;none&quot;,</div><div class="line">  &quot;state&quot;: &quot;REACHABLE&quot;,</div><div class="line">  &quot;txid&quot;: &quot;2038609306&quot;,</div><div class="line">  &quot;usingAuthorizedSnode&quot;: &quot;1&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不同点在于usingAuthorizedSnode为1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[root:sbu-snode]# ./cexec   &quot;SupernodeHunter_listSnodes(0)&quot;</div><div class="line">&#123;</div><div class="line">  &quot;error&quot;: &quot;none&quot;,</div><div class="line">  &quot;snodes&quot;: [</div><div class="line">    &quot;r3919swdqt8022xwf3dq8y4uwn8t87f38qsw7fkjzl7x6h358s20.k&quot;</div><div class="line">  ],</div><div class="line">  &quot;txid&quot;: &quot;3762445565&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有返回，不为空。</p>
<h2 id="inbound的Super-Node启动过程"><a href="#inbound的Super-Node启动过程" class="headerlink" title="inbound的Super Node启动过程"></a>inbound的Super Node启动过程</h2><h3 id="conf文件分析-1"><a href="#conf文件分析-1" class="headerlink" title="conf文件分析"></a>conf文件分析</h3><p>以inbound上的sbu-gate1为例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&quot;interfaces&quot;:&#123;</div><div class="line">	&quot;UDPInterface&quot;:[</div><div class="line">    	&#123;</div><div class="line">        	&quot;connectTo&quot;:&#123;</div><div class="line">            	&quot;47.92.135.33:34435&quot;:&#123;</div><div class="line">					&quot;password&quot;:&quot;0Jsal98j1Mbv1WFVVzlzB33of4J910C&quot;,</div><div class="line">                    &quot;publicKey&quot;:&quot;r3919swdqt8022xwf3dq8y4uwn8t87f38qsw7fkjzl7x6h358s20.k&quot;</div><div class="line">				&#125;,</div><div class="line">                &quot;172.17.0.1:50002&quot;:&#123;</div><div class="line">                	&quot;password&quot;:&quot;q3lAM4EvrYsYDGQynkIeD1rbDjBtoc8&quot;,</div><div class="line">                    &quot;publicKey&quot;:&quot;5zl6xndspf1sm2042987rthn8pcgxzf74rfvc5njl2gh6s9g8780.k&quot;</div><div class="line">                &#125;</div><div class="line">            &#125;,</div><div class="line">            &quot;bind&quot;:&quot;0.0.0.0:50001&quot;</div><div class="line">        &#125;</div><div class="line">    ],</div><div class="line">    ...</div><div class="line">&#125;,</div><div class="line">&quot;router&quot;:&#123;</div><div class="line">	&quot;supernodes&quot;:[</div><div class="line">    	&quot;r3919swdqt8022xwf3dq8y4uwn8t87f38qsw7fkjzl7x6h358s20.k&quot;</div><div class="line">    ],</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>interfaces的UDPInterface的connectTo中，设置了两个点，一个是snode，一个是sbu-gate2，也就是同时将snode和sbu-gate2设为peer。</li>
<li>route的supernodes中设置了snode。<br>conf文件中配置有snode，所以会调用到增加snode的API接口：<code>SupernodeHunter_addSnode</code>。增加snode到snp-&gt;authorizedSnodes中。</li>
</ol>
<h3 id="inbound的Super-Node设置"><a href="#inbound的Super-Node设置" class="headerlink" title="inbound的Super Node设置"></a>inbound的Super Node设置</h3><p>直接从probePeerCycle开始分析<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">static void probePeerCycle(void* vsn)</div><div class="line">&#123;</div><div class="line">    struct SupernodeHunter_pvt* snp = Identity_check((struct SupernodeHunter_pvt*) vsn);</div><div class="line"></div><div class="line">    if (snp-&gt;pub.snodeIsReachable &amp;&amp; !snp-&gt;snodePathUpdated) &#123;</div><div class="line">        updateSnodePath(snp);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (snp-&gt;pub.snodeIsReachable &gt; 1) &#123; return; &#125;</div><div class="line">    if (snp-&gt;pub.snodeIsReachable &amp;&amp; !snp-&gt;authorizedSnodes-&gt;length) &#123; return; &#125;</div><div class="line">    if (!snp-&gt;peers-&gt;length) &#123; return; &#125;</div><div class="line"></div><div class="line">    //Log_debug(snp-&gt;log, &quot;probePeerCycle()&quot;);</div><div class="line"></div><div class="line">    if (AddrSet_indexOf(snp-&gt;authorizedSnodes, snp-&gt;myAddress) != -1) &#123;</div><div class="line">        Log_info(snp-&gt;log, &quot;Self is specified as supernode, pinging...&quot;);</div><div class="line">        adoptSupernode(snp, snp-&gt;myAddress);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    struct Address* peer = getPeerByNpn(snp, snp-&gt;nextPeer);</div><div class="line">    if (!peer) &#123;</div><div class="line">        Log_info(snp-&gt;log, &quot;No peer found who is version &gt;= 20&quot;);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    snp-&gt;nextPeer++;</div><div class="line"></div><div class="line">    struct SwitchPinger_Ping* p =</div><div class="line">        SwitchPinger_newPing(peer-&gt;path, String_CONST(&quot;&quot;), 3000, peerResponse, snp-&gt;alloc, snp-&gt;sp);</div><div class="line">    Assert_true(p);</div><div class="line"></div><div class="line">    p-&gt;type = SwitchPinger_Type_GETSNODE;</div><div class="line">    if (snp-&gt;pub.snodeIsReachable) &#123;</div><div class="line">        Bits_memcpy(&amp;p-&gt;snode, &amp;snp-&gt;pub.snodeAddr, sizeof(struct Address));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    p-&gt;onResponseContext = snp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当首次调用到这里，snp-&gt;pub.snodeIsReachable为false，snp-&gt;snodePathUpdate为false，snp-&gt;authorizedSnodes中是从conf中添加进来的snode，也就是snode点。所以，会执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">struct Address* peer = getPeerByNpn(snp, snp-&gt;nextPeer);</div><div class="line">if (!peer) &#123;</div><div class="line">    Log_info(snp-&gt;log, &quot;No peer found who is version &gt;= 20&quot;);</div><div class="line">    return;</div><div class="line">&#125;</div><div class="line">snp-&gt;nextPeer++;</div><div class="line"></div><div class="line">struct SwitchPinger_Ping* p =</div><div class="line">    SwitchPinger_newPing(peer-&gt;path, String_CONST(&quot;&quot;), 3000, peerResponse, snp-&gt;alloc, snp-&gt;sp);</div><div class="line">Assert_true(p);</div><div class="line"></div><div class="line">p-&gt;type = SwitchPinger_Type_GETSNODE;</div><div class="line">if (snp-&gt;pub.snodeIsReachable) &#123;</div><div class="line">    Bits_memcpy(&amp;p-&gt;snode, &amp;snp-&gt;pub.snodeAddr, sizeof(struct Address));</div><div class="line">&#125;</div><div class="line"></div><div class="line">p-&gt;onResponseContext = snp;</div></pre></td></tr></table></figure></p>
<p>和普通点一样，询问自己的peer，进而找到前往snode的路径，与snode建立连接后，更新前往snode的路径。<br>但注意，inbound的两个peer，其中有一个就是snode。<br>查看API调用的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">root@sbu-gate1:/ancode/new# ./cexec   &quot;SupernodeHunter_status()&quot;</div><div class="line">&#123;</div><div class="line">  &quot;activeSnode&quot;: &quot;v20.0000.0000.0000.0015.r3919swdqt8022xwf3dq8y4uwn8t87f38qsw7fkjzl7x6h358s20.k&quot;,</div><div class="line">  &quot;error&quot;: &quot;none&quot;,</div><div class="line">  &quot;state&quot;: &quot;REACHABLE&quot;,</div><div class="line">  &quot;txid&quot;: &quot;1834461195&quot;,</div><div class="line">  &quot;usingAuthorizedSnode&quot;: &quot;1&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>usingAuthorizedSnode值为1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">root@sbu-gate4:/ancode/new# ./cexec &quot;SupernodeHunter_listSnodes(0)&quot;</div><div class="line">&#123;</div><div class="line">  &quot;error&quot;: &quot;none&quot;,</div><div class="line">  &quot;snodes&quot;: [</div><div class="line">    &quot;r3919swdqt8022xwf3dq8y4uwn8t87f38qsw7fkjzl7x6h358s20.k&quot;</div><div class="line">  ],</div><div class="line">  &quot;txid&quot;: &quot;2813207163&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>listSnode中有conf中配置的snode。</p>
<h2 id="GETSNODE请求的发起和peer的回应"><a href="#GETSNODE请求的发起和peer的回应" class="headerlink" title="GETSNODE请求的发起和peer的回应"></a>GETSNODE请求的发起和peer的回应</h2><h3 id="GETSNODE请求的发送"><a href="#GETSNODE请求的发送" class="headerlink" title="GETSNODE请求的发送"></a>GETSNODE请求的发送</h3><p>之前在分析snode的启动流程时讲到，普通点和inbound在寻找snode的路径时，采用的方法是，向自己的peer询问。即向每个peer发送一个p-&gt;type为SwitchPinger_Type_GETSNODE的SwitchPinger_Ping。现在来具体看一下这个请求的发送过程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct SwitchPinger_Ping* p =</div><div class="line">    SwitchPinger_newPing(peer-&gt;path, String_CONST(&quot;&quot;), 3000, peerResponse, snp-&gt;alloc, snp-&gt;sp);</div><div class="line">Assert_true(p);</div><div class="line"></div><div class="line">p-&gt;type = SwitchPinger_Type_GETSNODE;</div></pre></td></tr></table></figure></p>
<p>调用到SwitchPinger_newPing<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">struct SwitchPinger_Ping* SwitchPinger_newPing(uint64_t label,</div><div class="line">                                               String* data,</div><div class="line">                                               uint32_t timeoutMilliseconds,</div><div class="line">                                               SwitchPinger_ResponseCallback onResponse,</div><div class="line">                                               struct Allocator* alloc,</div><div class="line">                                               struct SwitchPinger* context)</div><div class="line">&#123;</div><div class="line">    struct SwitchPinger_pvt* ctx = Identity_check((struct SwitchPinger_pvt*)context);</div><div class="line">    if (data &amp;&amp; data-&gt;len &gt; Control_Ping_MAX_SIZE) &#123;</div><div class="line">        return NULL;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (ctx-&gt;outstandingPings &gt; ctx-&gt;maxConcurrentPings) &#123;</div><div class="line">        Log_debug(ctx-&gt;logger, &quot;Skipping switch ping because there are already [%d] outstanding&quot;,</div><div class="line">                  ctx-&gt;outstandingPings);</div><div class="line">        return NULL;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    struct Pinger_Ping* pp =</div><div class="line">        Pinger_newPing(data, onPingResponse, sendPing, timeoutMilliseconds, alloc, ctx-&gt;pinger);</div><div class="line"></div><div class="line">    struct Ping* ping = Allocator_clone(pp-&gt;pingAlloc, (&amp;(struct Ping) &#123;</div><div class="line">        .pub = &#123;</div><div class="line">            .pingAlloc = pp-&gt;pingAlloc</div><div class="line">        &#125;,</div><div class="line">        .label = label,</div><div class="line">        .data = String_clone(data, pp-&gt;pingAlloc),</div><div class="line">        .context = ctx,</div><div class="line">        .onResponse = onResponse,</div><div class="line">        .pingerPing = pp</div><div class="line">    &#125;));</div><div class="line">    Identity_set(ping);</div><div class="line">    Allocator_onFree(pp-&gt;pingAlloc, onPingFree, ping);</div><div class="line">    pp-&gt;context = ping;</div><div class="line">    ctx-&gt;outstandingPings++;</div><div class="line"></div><div class="line">    return &amp;ping-&gt;pub;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>调用sendPing<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">static void sendPing(String* data, void* sendPingContext)</div><div class="line">&#123;</div><div class="line">    struct Ping* p = Identity_check((struct Ping*) sendPingContext);</div><div class="line"></div><div class="line">    struct Message* msg = Message_new(0, data-&gt;len + 512, p-&gt;pub.pingAlloc);</div><div class="line"></div><div class="line">    while (((uintptr_t)msg-&gt;bytes - data-&gt;len) % 4) &#123;</div><div class="line">        Message_push8(msg, 0, NULL);</div><div class="line">    &#125;</div><div class="line">    msg-&gt;length = 0;</div><div class="line"></div><div class="line">    Message_push(msg, data-&gt;bytes, data-&gt;len, NULL);</div><div class="line">    Assert_true(!((uintptr_t)msg-&gt;bytes % 4) &amp;&amp; &quot;alignment fault&quot;);</div><div class="line"></div><div class="line">    if (p-&gt;pub.type == SwitchPinger_Type_KEYPING) &#123;</div><div class="line">        Message_push(msg, NULL, Control_KeyPing_HEADER_SIZE, NULL);</div><div class="line">        struct Control_KeyPing* keyPingHeader = (struct Control_KeyPing*) msg-&gt;bytes;</div><div class="line">        keyPingHeader-&gt;magic = Control_KeyPing_MAGIC;</div><div class="line">        keyPingHeader-&gt;version_be = Endian_hostToBigEndian32(Version_CURRENT_PROTOCOL);</div><div class="line">        Bits_memcpy(keyPingHeader-&gt;key, p-&gt;context-&gt;myAddr-&gt;key, 32);</div><div class="line">    &#125; else if (p-&gt;pub.type == SwitchPinger_Type_PING) &#123;</div><div class="line">        Message_push(msg, NULL, Control_Ping_HEADER_SIZE, NULL);</div><div class="line">        struct Control_Ping* pingHeader = (struct Control_Ping*) msg-&gt;bytes;</div><div class="line">        pingHeader-&gt;magic = Control_Ping_MAGIC;</div><div class="line">        pingHeader-&gt;version_be = Endian_hostToBigEndian32(Version_CURRENT_PROTOCOL);</div><div class="line">    &#125; else if (p-&gt;pub.type == SwitchPinger_Type_GETSNODE) &#123;</div><div class="line">        Message_push(msg, NULL, Control_GetSnode_HEADER_SIZE, NULL);</div><div class="line">        struct Control_GetSnode* hdr = (struct Control_GetSnode*) msg-&gt;bytes;</div><div class="line">        hdr-&gt;magic = Control_GETSNODE_QUERY_MAGIC;</div><div class="line">        hdr-&gt;version_be = Endian_hostToBigEndian32(Version_CURRENT_PROTOCOL);</div><div class="line">        hdr-&gt;kbps_be = Endian_hostToBigEndian32(p-&gt;pub.kbpsLimit);</div><div class="line">        Bits_memcpy(hdr-&gt;snodeKey, p-&gt;pub.snode.key, 32);</div><div class="line">        uint64_t pathToSnode_be = Endian_hostToBigEndian64(p-&gt;pub.snode.path);</div><div class="line">        Bits_memcpy(hdr-&gt;pathToSnode_be, &amp;pathToSnode_be, 8);</div><div class="line">        hdr-&gt;snodeVersion_be = Endian_hostToBigEndian32(p-&gt;pub.snode.protocolVersion);</div><div class="line">    &#125; else &#123;</div><div class="line">        Assert_failure(&quot;unexpected ping type&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Message_shift(msg, Control_Header_SIZE, NULL);</div><div class="line">    struct Control* ctrl = (struct Control*) msg-&gt;bytes;</div><div class="line">    ctrl-&gt;header.checksum_be = 0;</div><div class="line">    if (p-&gt;pub.type == SwitchPinger_Type_PING) &#123;</div><div class="line">        ctrl-&gt;header.type_be = Control_PING_be;</div><div class="line">    &#125; else if (p-&gt;pub.type == SwitchPinger_Type_KEYPING) &#123;</div><div class="line">        ctrl-&gt;header.type_be = Control_KEYPING_be;</div><div class="line">    &#125; else if (p-&gt;pub.type == SwitchPinger_Type_GETSNODE) &#123;</div><div class="line">        ctrl-&gt;header.type_be = Control_GETSNODE_QUERY_be;</div><div class="line">    &#125; else &#123;</div><div class="line">        Assert_failure(&quot;unexpected type&quot;);</div><div class="line">    &#125;</div><div class="line">    ctrl-&gt;header.checksum_be = Checksum_engine(msg-&gt;bytes, msg-&gt;length);</div><div class="line"></div><div class="line">    struct RouteHeader rh;</div><div class="line">    Bits_memset(&amp;rh, 0, RouteHeader_SIZE);</div><div class="line">    rh.flags |= RouteHeader_flags_CTRLMSG;</div><div class="line">    rh.sh.label_be = Endian_hostToBigEndian64(p-&gt;label);</div><div class="line">    SwitchHeader_setVersion(&amp;rh.sh, SwitchHeader_CURRENT_VERSION);</div><div class="line"></div><div class="line">    Message_push(msg, &amp;rh, RouteHeader_SIZE, NULL);</div><div class="line"></div><div class="line">    Iface_send(&amp;p-&gt;context-&gt;pub.controlHandlerIf, msg);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>主要的操作包括两部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">else if (p-&gt;pub.type == SwitchPinger_Type_GETSNODE) &#123;</div><div class="line">        Message_push(msg, NULL, Control_GetSnode_HEADER_SIZE, NULL);</div><div class="line">        struct Control_GetSnode* hdr = (struct Control_GetSnode*) msg-&gt;bytes;</div><div class="line">        hdr-&gt;magic = Control_GETSNODE_QUERY_MAGIC;</div><div class="line">        hdr-&gt;version_be = Endian_hostToBigEndian32(Version_CURRENT_PROTOCOL);</div><div class="line">        hdr-&gt;kbps_be = Endian_hostToBigEndian32(p-&gt;pub.kbpsLimit);</div><div class="line">        Bits_memcpy(hdr-&gt;snodeKey, p-&gt;pub.snode.key, 32);</div><div class="line">        uint64_t pathToSnode_be = Endian_hostToBigEndian64(p-&gt;pub.snode.path);</div><div class="line">        Bits_memcpy(hdr-&gt;pathToSnode_be, &amp;pathToSnode_be, 8);</div><div class="line">        hdr-&gt;snodeVersion_be = Endian_hostToBigEndian32(p-&gt;pub.snode.protocolVersion);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">else if (p-&gt;pub.type == SwitchPinger_Type_GETSNODE) &#123;</div><div class="line">        ctrl-&gt;header.type_be = Control_GETSNODE_QUERY_be;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>主要是一些字段内容的设置，特别注意到<code>ctrl-&gt;header.type_be = Control_GETSNODE_QUERY_be</code>,这一设置对应到peer回应时的处理。<br>字段设置之后，这个ping被发送出去，具体的发送过程不在这里分析了。接下来看看peer对这个ping的回复过程。</p>
<h3 id="peer对GETSNODE请求的回应"><a href="#peer对GETSNODE请求的回应" class="headerlink" title="peer对GETSNODE请求的回应"></a>peer对GETSNODE请求的回应</h3><p>对于回应过程的分析，直接从ControlHandler.c中的incomingFromCore函数开始。无关内容太多，直接给出核心代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">else if (ctrl-&gt;header.type_be == Control_GETSNODE_QUERY_be) &#123;</div><div class="line">        return handleGetSnodeQuery(msg, ch, label, labelStr);</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">static Iface_DEFUN handleGetSnodeQuery(struct Message* msg,</div><div class="line">                                       struct ControlHandler_pvt* ch,</div><div class="line">                                       uint64_t label,</div><div class="line">                                       uint8_t* labelStr)</div><div class="line">&#123;</div><div class="line">    Log_debug(ch-&gt;log, &quot;incoming getSupernode query&quot;);</div><div class="line">    if (msg-&gt;length &lt; handleGetSnodeQuery_MIN_SIZE) &#123;</div><div class="line">        Log_info(ch-&gt;log, &quot;DROP runt getSupernode query&quot;);</div><div class="line">        return NULL;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    struct Control* ctrl = (struct Control*) msg-&gt;bytes;</div><div class="line">    struct Control_GetSnode* snq = &amp;ctrl-&gt;content.getSnode;</div><div class="line"></div><div class="line">    if (snq-&gt;magic != Control_GETSNODE_QUERY_MAGIC) &#123;</div><div class="line">        Log_debug(ch-&gt;log, &quot;DROP getSupernode query (bad magic)&quot;);</div><div class="line">        return NULL;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    uint32_t herVersion = Endian_bigEndianToHost32(snq-&gt;version_be);</div><div class="line">    if (!Version_isCompatible(Version_CURRENT_PROTOCOL, herVersion)) &#123;</div><div class="line">        Log_debug(ch-&gt;log, &quot;DROP getSupernode query from incompatible version [%d]&quot;, herVersion);</div><div class="line">        return NULL;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ctrl-&gt;header.type_be = Control_GETSNODE_REPLY_be;</div><div class="line">    snq-&gt;kbps_be = 0xffffffff;</div><div class="line">    snq-&gt;version_be = Endian_hostToBigEndian32(Version_CURRENT_PROTOCOL);</div><div class="line">    snq-&gt;magic = Control_GETSNODE_REPLY_MAGIC;</div><div class="line">    if (ch-&gt;activeSnode.path) &#123;</div><div class="line">        uint64_t fixedLabel = NumberCompress_getLabelFor(ch-&gt;activeSnode.path, label);</div><div class="line">        uint64_t fixedLabel_be = Endian_hostToBigEndian64(fixedLabel);</div><div class="line">        Bits_memcpy(snq-&gt;pathToSnode_be, &amp;fixedLabel_be, 8);</div><div class="line">        Bits_memcpy(&amp;snq-&gt;snodeKey, ch-&gt;activeSnode.key, 32);</div><div class="line">        snq-&gt;snodeVersion_be = Endian_hostToBigEndian32(ch-&gt;activeSnode.protocolVersion);</div><div class="line"></div><div class="line">    &#125; else &#123;</div><div class="line">        snq-&gt;snodeVersion_be = 0;</div><div class="line">        Bits_memset(snq-&gt;pathToSnode_be, 0, 8);</div><div class="line">        Bits_memcpy(&amp;snq-&gt;snodeKey, ch-&gt;activeSnode.key, 32);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ctrl-&gt;header.checksum_be = 0;</div><div class="line">    ctrl-&gt;header.checksum_be = Checksum_engine(msg-&gt;bytes, msg-&gt;length);</div><div class="line"></div><div class="line">    Message_shift(msg, RouteHeader_SIZE, NULL);</div><div class="line">    struct RouteHeader* routeHeader = (struct RouteHeader*) msg-&gt;bytes;</div><div class="line">    Bits_memset(routeHeader, 0, RouteHeader_SIZE);</div><div class="line">    SwitchHeader_setVersion(&amp;routeHeader-&gt;sh, SwitchHeader_CURRENT_VERSION);</div><div class="line">    routeHeader-&gt;sh.label_be = Endian_hostToBigEndian64(label);</div><div class="line">    routeHeader-&gt;flags |= RouteHeader_flags_CTRLMSG;</div><div class="line">    return Iface_next(&amp;ch-&gt;pub.coreIf, msg);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>主要操作是将snode相关的内容放入struct Control_GetSnode* snq当中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">struct Control_GetSnode* snq = &amp;ctrl-&gt;content.getSnode;</div><div class="line"></div><div class="line">if (snq-&gt;magic != Control_GETSNODE_QUERY_MAGIC) &#123;</div><div class="line">    Log_debug(ch-&gt;log, &quot;DROP getSupernode query (bad magic)&quot;);</div><div class="line">    return NULL;</div><div class="line">&#125;</div><div class="line"></div><div class="line">uint32_t herVersion = Endian_bigEndianToHost32(snq-&gt;version_be);</div><div class="line">if (!Version_isCompatible(Version_CURRENT_PROTOCOL, herVersion)) &#123;</div><div class="line">    Log_debug(ch-&gt;log, &quot;DROP getSupernode query from incompatible version [%d]&quot;, herVersion);</div><div class="line">    return NULL;</div><div class="line">&#125;</div><div class="line"></div><div class="line">ctrl-&gt;header.type_be = Control_GETSNODE_REPLY_be;</div><div class="line">snq-&gt;kbps_be = 0xffffffff;</div><div class="line">snq-&gt;version_be = Endian_hostToBigEndian32(Version_CURRENT_PROTOCOL);</div><div class="line">snq-&gt;magic = Control_GETSNODE_REPLY_MAGIC;</div><div class="line">if (ch-&gt;activeSnode.path) &#123;</div><div class="line">    uint64_t fixedLabel = NumberCompress_getLabelFor(ch-&gt;activeSnode.path, label);</div><div class="line">    uint64_t fixedLabel_be = Endian_hostToBigEndian64(fixedLabel);</div><div class="line">    Bits_memcpy(snq-&gt;pathToSnode_be, &amp;fixedLabel_be, 8);</div><div class="line">    Bits_memcpy(&amp;snq-&gt;snodeKey, ch-&gt;activeSnode.key, 32);</div><div class="line">    snq-&gt;snodeVersion_be = Endian_hostToBigEndian32(ch-&gt;activeSnode.protocolVersion);</div><div class="line"></div><div class="line">&#125; else &#123;</div><div class="line">    snq-&gt;snodeVersion_be = 0;</div><div class="line">    Bits_memset(snq-&gt;pathToSnode_be, 0, 8);</div><div class="line">    Bits_memcpy(&amp;snq-&gt;snodeKey, ch-&gt;activeSnode.key, 32);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="收到GETSNODE请求的回复后，peer的处理"><a href="#收到GETSNODE请求的回复后，peer的处理" class="headerlink" title="收到GETSNODE请求的回复后，peer的处理"></a>收到GETSNODE请求的回复后，peer的处理</h3><p>在上面发起请求时，我们使用的是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">struct SwitchPinger_Ping* p =</div><div class="line">    SwitchPinger_newPing(peer-&gt;path, String_CONST(&quot;&quot;), 3000, peerResponse, snp-&gt;alloc, snp-&gt;sp);</div><div class="line">Assert_true(p);</div></pre></td></tr></table></figure></p>
<p>可以看到，callback函数是peerResponse，查看这个方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">static void peerResponse(struct SwitchPinger_Response* resp, void* userData)</div><div class="line">&#123;</div><div class="line">    struct SupernodeHunter_pvt* snp = Identity_check((struct SupernodeHunter_pvt*) userData);</div><div class="line">    char* err = &quot;&quot;;</div><div class="line">    switch (resp-&gt;res) &#123;</div><div class="line">        case SwitchPinger_Result_OK: peerResponseOK(resp, snp); return;</div><div class="line">        case SwitchPinger_Result_LABEL_MISMATCH: err = &quot;LABEL_MISMATCH&quot;; break;</div><div class="line">        case SwitchPinger_Result_WRONG_DATA: err = &quot;WRONG_DATA&quot;; break;</div><div class="line">        case SwitchPinger_Result_ERROR_RESPONSE: err = &quot;ERROR_RESPONSE&quot;; break;</div><div class="line">        case SwitchPinger_Result_LOOP_ROUTE: err = &quot;LOOP_ROUTE&quot;; break;</div><div class="line">        case SwitchPinger_Result_TIMEOUT: err = &quot;TIMEOUT&quot;; break;</div><div class="line">        default: err = &quot;unknown error&quot;; break;</div><div class="line">    &#125;</div><div class="line">    Log_debug(snp-&gt;log, &quot;Error sending snp query to peer [%s]&quot;, err);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在正常的情况下，调用到peerResponseOK，查看这个方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line">static void peerResponseOK(struct SwitchPinger_Response* resp, struct SupernodeHunter_pvt* snp)</div><div class="line">&#123;</div><div class="line">    struct Address snode;</div><div class="line">    Bits_memcpy(&amp;snode, &amp;resp-&gt;snode, sizeof(struct Address));</div><div class="line">    if (!snode.path) &#123;</div><div class="line">        uint8_t label[20];</div><div class="line">        AddrTools_printPath(label, resp-&gt;label);</div><div class="line">        Log_debug(snp-&gt;log, &quot;Peer [%s] reports no supernode&quot;, label);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    uint64_t path = LabelSplicer_splice(snode.path, resp-&gt;label);</div><div class="line">    if (path == UINT64_MAX) &#123;</div><div class="line">        Log_debug(snp-&gt;log, &quot;Supernode path could not be spliced&quot;);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    snode.path = path;</div><div class="line"></div><div class="line">    struct Address* firstPeer = getPeerByNpn(snp, 0);</div><div class="line">    if (!firstPeer) &#123;</div><div class="line">        Log_info(snp-&gt;log, &quot;All peers have gone away while packet was outstanding&quot;);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 1.</div><div class="line">    // If we have looped around and queried all of our peers returning to the first and we have</div><div class="line">    // still not found an snode in our authorized snodes list, we should simply accept this one.</div><div class="line">    if (!snp-&gt;pub.snodeIsReachable &amp;&amp; snp-&gt;nextPeer &gt; 1 &amp;&amp; firstPeer-&gt;path == resp-&gt;label) &#123;</div><div class="line">            Log_debug(snp-&gt;log,&quot;snodesnode1 &amp;snp-&gt;snodeCandidate:%s  pub.snodeAddr:%s&quot;,</div><div class="line">                    Address_toString(&amp;snp-&gt;snodeCandidate, snp-&gt;alloc)-&gt;bytes,</div><div class="line">                    Address_toString(&amp;snp-&gt;pub.snodeAddr, snp-&gt;alloc)-&gt;bytes);</div><div class="line">            Log_debug(snp-&gt;log,&quot;snodesnode1 snode:%s&quot;,</div><div class="line">                Address_toString(&amp;snode, snp-&gt;alloc)-&gt;bytes);</div><div class="line">            Log_debug(snp-&gt;log,&quot;snodesnode1 myAddress:%s&quot;,</div><div class="line">                Address_toString(snp-&gt;myAddress, snp-&gt;alloc)-&gt;bytes);</div><div class="line">        if (!snp-&gt;snodeCandidate.path) &#123;</div><div class="line">            Log_info(snp-&gt;log, &quot;No snode candidate found&quot;);</div><div class="line">            snp-&gt;nextPeer = 0;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        adoptSupernode(snp, &amp;snp-&gt;snodeCandidate);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 2.</div><div class="line">    // If this snode is one of our authorized snodes OR if we have none defined, accept this one.</div><div class="line">    if (!snp-&gt;authorizedSnodes-&gt;length || AddrSet_indexOf(snp-&gt;authorizedSnodes, &amp;snode) &gt; -1) &#123;</div><div class="line">            Log_debug(snp-&gt;log,&quot;snodesnode2 &amp;snp-&gt;snodeCandidate:%s  pub.snodeAddr:%s&quot;,</div><div class="line">                Address_toString(&amp;snp-&gt;snodeCandidate, snp-&gt;alloc)-&gt;bytes,</div><div class="line">                Address_toString(&amp;snp-&gt;pub.snodeAddr, snp-&gt;alloc)-&gt;bytes);</div><div class="line">            Log_debug(snp-&gt;log,&quot;snodesnode2 snode:%s&quot;,</div><div class="line">                Address_toString(&amp;snode, snp-&gt;alloc)-&gt;bytes);</div><div class="line">        Address_getPrefix(&amp;snode);</div><div class="line">        adoptSupernode(snp, &amp;snode);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (!snp-&gt;snodeCandidate.path) &#123;</div><div class="line">        Log_debug(snp-&gt;log,&quot;snodesnode2.5 &amp;snp-&gt;snodeCandidate:%s  pub.snodeAddr:%s&quot;,</div><div class="line">                Address_toString(&amp;snp-&gt;snodeCandidate, snp-&gt;alloc)-&gt;bytes,</div><div class="line">                Address_toString(&amp;snp-&gt;pub.snodeAddr, snp-&gt;alloc)-&gt;bytes);</div><div class="line">        Log_debug(snp-&gt;log,&quot;snodesnode2.5 snode:%s&quot;,</div><div class="line">                Address_toString(&amp;snode, snp-&gt;alloc)-&gt;bytes);</div><div class="line">        Bits_memcpy(&amp;snp-&gt;snodeCandidate, &amp;snode, sizeof(struct Address));</div><div class="line">        Address_getPrefix(&amp;snp-&gt;snodeCandidate);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 3.</div><div class="line">    // If this snode is not one of our authorized snodes, query it for all of our authorized snodes.</div><div class="line">    queryForAuthorized(snp, &amp;snode);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码中，首先要注意的是它对peer返回的snode的path做了一个LabelSplicer_splice操作。这个操作的作用是基于peer在自己这里的path和snode在peer那里的path，来推算出snode在自己这里应有的path。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">uint64_t path = LabelSplicer_splice(snode.path, resp-&gt;label);</div></pre></td></tr></table></figure></p>
<p>其中，snode.path就是snode在peer那里的path，而resp-&gt;laber是peer在自己这里的path。<br>LabelSplicer_splice方法可以基于peer在自己这里的path和snode在peer那里的path，来推算出snode在自己这里应有的path。</p>
<p>由于这段代码已经被修改过，情况3已经不再处理，这段代码已经不是原始的cjdns代码，所以，只简单分析大致的逻辑。<br>当前点会询问所有的peer，当收到第一个peer返回的snode之后，将这个snode的地址记录在snodeCandidate中，继续等待其他peer的回应，在这个过程中，如果某个peer回应的snode是当前点在conf中配置的snode，那么接受这个在conf中配置的snode。<br>如果所有的peer都已经回复的自己的snode，而其中并没有当前点在conf中配置的snode，那么接受snodeCandidate，也就是第一个peer回复的snode。<br>接下来，看一下什么是接受snode。所谓接受snode，就是adoptSupernode方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">static void adoptSupernode(struct SupernodeHunter_pvt* snp, struct Address* candidate)</div><div class="line">&#123;</div><div class="line">    struct MsgCore_Promise* qp = MsgCore_createQuery(snp-&gt;msgCore, 0, snp-&gt;alloc);</div><div class="line">    struct Query* q = Allocator_calloc(qp-&gt;alloc, sizeof(struct Query), 1);</div><div class="line">    Identity_set(q);</div><div class="line">    q-&gt;snp = snp;</div><div class="line">    q-&gt;sendTime = Time_currentTimeMilliseconds(snp-&gt;base);</div><div class="line"></div><div class="line">    Dict* msg = qp-&gt;msg = Dict_new(qp-&gt;alloc);</div><div class="line">    qp-&gt;cb = adoptSupernode2;</div><div class="line">    qp-&gt;userData = q;</div><div class="line">    qp-&gt;target = Address_clone(candidate, qp-&gt;alloc);</div><div class="line"></div><div class="line">    Log_debug(snp-&gt;log, &quot;Pinging snode [%s]&quot;, Address_toString(qp-&gt;target, qp-&gt;alloc)-&gt;bytes);</div><div class="line">    Dict_putStringCC(msg, &quot;sq&quot;, &quot;pn&quot;, qp-&gt;alloc);</div><div class="line"></div><div class="line">    Assert_true(AddressCalc_validAddress(candidate-&gt;ip6.bytes));</div><div class="line">    return;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码的作用是向snode发送一个pn请求，试图连接这个snode，如果收到snode的回复，进入到adoptSupernode2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">static void adoptSupernode2(Dict* msg, struct Address* src, struct MsgCore_Promise* prom)</div><div class="line">&#123;</div><div class="line">    struct Query* q = Identity_check((struct Query*) prom-&gt;userData);</div><div class="line">    struct SupernodeHunter_pvt* snp = Identity_check(q-&gt;snp);</div><div class="line"></div><div class="line">    if (!src) &#123;</div><div class="line">        String* addrStr = Address_toString(prom-&gt;target, prom-&gt;alloc);</div><div class="line">        Log_debug(snp-&gt;log, &quot;timeout sending to %s&quot;, addrStr-&gt;bytes);</div><div class="line">        if (!Bits_memcmp(prom-&gt;target, snp-&gt;myAddress, Address_SIZE)) &#123;</div><div class="line">            askPeer(snp);</div><div class="line">            //~ snp-&gt;pub.snodeIsReachable = 0;</div><div class="line">            Log_debug(snp-&gt;log, &quot;snode snode my cjdnsnode is not working try to ask peer&quot;</div><div class="line">                    &quot; now snodeIsReachable:%d&quot;,snp-&gt;pub.snodeIsReachable);</div><div class="line">        &#125;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    String* addrStr = Address_toString(src, prom-&gt;alloc);</div><div class="line">    Log_debug(snp-&gt;log, &quot;Reply from %s&quot;, addrStr-&gt;bytes);</div><div class="line"></div><div class="line">    int64_t* snodeRecvTime = Dict_getIntC(msg, &quot;recvTime&quot;);</div><div class="line">    if (!snodeRecvTime) &#123;</div><div class="line">        Log_info(snp-&gt;log, &quot;getRoute reply with no timeStamp, bad snode&quot;);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    Log_debug(snp-&gt;log, &quot;\n\nSupernode location confirmed [%s]\n\n&quot;,</div><div class="line">        Address_toString(src, prom-&gt;alloc)-&gt;bytes);</div><div class="line">    if (snp-&gt;pub.snodeIsReachable &amp;&amp; Bits_memcmp(src, snp-&gt;myAddress, Address_SIZE)) &#123;</div><div class="line">        // If while we were searching, the outside code declared that indeed the snode</div><div class="line">        // is reachable, we will not try to change their snode.</div><div class="line">    &#125; else if (snp-&gt;pub.onSnodeChange) &#123;</div><div class="line">            Bits_memcpy(&amp;snp-&gt;pub.snodeAddr, src, Address_SIZE);</div><div class="line">            snp-&gt;pub.snodeIsReachable = (AddrSet_indexOf(snp-&gt;authorizedSnodes, src) != -1) ? 2 : 1;</div><div class="line">            snp-&gt;pub.onSnodeChange(&amp;snp-&gt;pub, q-&gt;sendTime, *snodeRecvTime);</div><div class="line">            Notification_snode(snp-&gt;pub.notification,REACHABLE);</div><div class="line">    &#125; else &#123;</div><div class="line">            Log_warn(snp-&gt;log, &quot;onSnodeChange is not set&quot;);</div><div class="line">    &#125;</div><div class="line">    SupernodeStore_updateSnodeAddress(snp-&gt;pub.snodeStore, src, true);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这个方法中，对snp-&gt;pub.snodeAddr进行赋值，并且处理了一些在snode发生变化时，应该做的操作。<br>至此，snodeAddr的赋值完成，snode就算稳定了。</p>
<h2 id="向snode点询问去某点的路径"><a href="#向snode点询问去某点的路径" class="headerlink" title="向snode点询问去某点的路径"></a>向snode点询问去某点的路径</h2><h3 id="向snode发送地址询问请求"><a href="#向snode发送地址询问请求" class="headerlink" title="向snode发送地址询问请求"></a>向snode发送地址询问请求</h3><p>从SessionManager.c的triggerSearch方法开始分析。这是询问请求的开始之处。有两个地方会调用到triggerSearch方法，分别是：</p>
<ol>
<li>checkTimedOutSessions</li>
<li>needsLookup</li>
</ol>
<p>下面来看一下triggerSearch方法的源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">static void triggerSearch(struct SessionManager_pvt* sm, uint8_t target[16], uint32_t version)</div><div class="line">&#123;</div><div class="line">    struct Allocator* eventAlloc = Allocator_child(sm-&gt;alloc);</div><div class="line">    struct Message* eventMsg = Message_new(0, 512, eventAlloc);</div><div class="line">    Message_push32(eventMsg, version, NULL);</div><div class="line">    Message_push32(eventMsg, 0, NULL);</div><div class="line">    Message_push(eventMsg, target, 16, NULL);</div><div class="line">    Message_push32(eventMsg, 0xffffffff, NULL);</div><div class="line">    Message_push32(eventMsg, PFChan_Core_SEARCH_REQ, NULL);</div><div class="line">    Iface_send(&amp;sm-&gt;eventIf, eventMsg);</div><div class="line">    Allocator_free(eventAlloc);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中，target是对方的ipv6地址，version是对方的版本。<br>最后调用<code>Iface_send(&amp;sm-&gt;eventIf, eventMsg);</code><br>所以接下来查找sm-&gt;eventIf和什么绑定。<br>在SessionManager_new中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">EventEmitter_regCore(ee, &amp;sm-&gt;eventIf, PFChan_Pathfinder_NODE);</div></pre></td></tr></table></figure></p>
<p>查看这个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">void EventEmitter_regCore(struct EventEmitter* eventEmitter,</div><div class="line">                          struct Iface* iface,</div><div class="line">                          enum PFChan_Pathfinder ev)</div><div class="line">&#123;</div><div class="line">    struct EventEmitter_pvt* ee = Identity_check((struct EventEmitter_pvt*) eventEmitter);</div><div class="line">    iface-&gt;connectedIf = &amp;ee-&gt;trickIf;</div><div class="line">    struct ArrayList_Ifaces* l = getHandlers(ee, ev, true);</div><div class="line">    if (!l) &#123;</div><div class="line">        Assert_true(ev == 0);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    ArrayList_Ifaces_add(l, iface);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>继续查找ee-&gt;trickIf，在EventEmitter_new中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ee-&gt;trickIf.send = incomingFromCore;</div></pre></td></tr></table></figure></p>
<p>查看incomingFromCore<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">static Iface_DEFUN incomingFromCore(struct Message* msg, struct Iface* trickIf)</div><div class="line">&#123;</div><div class="line">    struct EventEmitter_pvt* ee = Identity_containerOf(trickIf, struct EventEmitter_pvt, trickIf);</div><div class="line">    Assert_true(!((uintptr_t)msg-&gt;bytes % 4) &amp;&amp; &quot;alignment&quot;);</div><div class="line">    enum PFChan_Core ev = Message_pop32(msg, NULL);</div><div class="line">    Assert_true(PFChan_Core_sizeOk(ev, msg-&gt;length+4));</div><div class="line">    uint32_t pathfinderNum = Message_pop32(msg, NULL);</div><div class="line">    Message_push32(msg, ev, NULL);</div><div class="line">    if (pathfinderNum != 0xffffffff) &#123;</div><div class="line">        struct Pathfinder* pf = ArrayList_Pathfinders_get(ee-&gt;pathfinders, pathfinderNum);</div><div class="line">        Assert_true(pf &amp;&amp; pf-&gt;state == Pathfinder_state_CONNECTED);</div><div class="line">        return sendToPathfinder(msg, pf);</div><div class="line">    &#125; else &#123;</div><div class="line">        for (int i = 0; i &lt; ee-&gt;pathfinders-&gt;length; i++) &#123;</div><div class="line">            struct Pathfinder* pf = ArrayList_Pathfinders_get(ee-&gt;pathfinders, i);</div><div class="line">            if (!pf || pf-&gt;state != Pathfinder_state_CONNECTED) &#123; continue; &#125;</div><div class="line">            struct Message* messageClone = Message_clone(msg, msg-&gt;alloc);</div><div class="line">            Iface_CALL(sendToPathfinder, messageClone, pf);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return NULL;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>根据message push和pop的顺序关系，可以知道，pathfinderNum等于0xffffffff，执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">for (int i = 0; i &lt; ee-&gt;pathfinders-&gt;length; i++) &#123;</div><div class="line">    struct Pathfinder* pf = ArrayList_Pathfinders_get(ee-&gt;pathfinders, i);</div><div class="line">    if (!pf || pf-&gt;state != Pathfinder_state_CONNECTED) &#123; continue; &#125;</div><div class="line">    struct Message* messageClone = Message_clone(msg, msg-&gt;alloc);</div><div class="line">    Iface_CALL(sendToPathfinder, messageClone, pf);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>查看sendToPathfinder<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">static Iface_DEFUN sendToPathfinder(struct Message* msg, struct Pathfinder* pf)</div><div class="line">&#123;</div><div class="line">    if (!pf || pf-&gt;state != Pathfinder_state_CONNECTED) &#123; return NULL; &#125;</div><div class="line">    if (pf-&gt;bytesSinceLastPing &lt; 8192 &amp;&amp; pf-&gt;bytesSinceLastPing + msg-&gt;length &gt;= 8192) &#123;</div><div class="line">        struct Message* ping = Message_new(0, 512, msg-&gt;alloc);</div><div class="line">        Message_push32(ping, pf-&gt;bytesSinceLastPing, NULL);</div><div class="line">        Message_push32(ping, PING_MAGIC, NULL);</div><div class="line">        Message_push32(ping, PFChan_Core_PING, NULL);</div><div class="line">        Iface_send(&amp;pf-&gt;iface, ping);</div><div class="line">    &#125;</div><div class="line">    pf-&gt;bytesSinceLastPing += msg-&gt;length;</div><div class="line">    return Iface_next(&amp;pf-&gt;iface, msg);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>调用到<code>Iface_next(&amp;pf-&gt;iface, msg);</code><br>pf-&gt;iface在EventEmitter_regPathfinderIface中设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">void EventEmitter_regPathfinderIface(struct EventEmitter* emitter, struct Iface* iface)</div><div class="line">&#123;</div><div class="line">    struct EventEmitter_pvt* ee = Identity_check((struct EventEmitter_pvt*) emitter);</div><div class="line">    struct Allocator* alloc = Allocator_child(ee-&gt;alloc);</div><div class="line">    struct Pathfinder* pf = Allocator_calloc(alloc, sizeof(struct Pathfinder), 1);</div><div class="line">    pf-&gt;ee = ee;</div><div class="line">    pf-&gt;iface.send = incomingFromPathfinder;</div><div class="line">    pf-&gt;alloc = alloc;</div><div class="line">    Iface_plumb(&amp;pf-&gt;iface, iface);</div><div class="line">    Identity_set(pf);</div><div class="line">    int i = 0;</div><div class="line">    for (; i &lt; ee-&gt;pathfinders-&gt;length; i++) &#123;</div><div class="line">        struct Pathfinder* xpf = ArrayList_Pathfinders_get(ee-&gt;pathfinders, i);</div><div class="line">        if (!xpf) &#123; break; &#125;</div><div class="line">    &#125;</div><div class="line">    pf-&gt;pathfinderId = ArrayList_Pathfinders_put(ee-&gt;pathfinders, i, pf);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中的<code>Iface_plumb(&amp;pf-&gt;iface, iface);</code>就是绑定pf-&gt;iface和iface的语句。<br>这个函数的调用在Core.c中，分为两种情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">struct SubnodePathfinder* spf = SubnodePathfinder_new(</div><div class="line">    alloc, logger, eventBase, rand, nc-&gt;myAddress, privateKey, encodingScheme, notification);</div><div class="line">struct ASynchronizer* spfAsync = ASynchronizer_new(alloc, eventBase, logger);</div><div class="line">Iface_plumb(&amp;spfAsync-&gt;ifA, &amp;spf-&gt;eventIf);</div><div class="line">EventEmitter_regPathfinderIface(nc-&gt;ee, &amp;spfAsync-&gt;ifB);</div><div class="line"></div><div class="line">#ifndef SUBNODE</div><div class="line">    struct Pathfinder* opf = Pathfinder_register(alloc, logger, eventBase, rand, admin);</div><div class="line">    struct ASynchronizer* opfAsync = ASynchronizer_new(alloc, eventBase, logger);</div><div class="line">    Iface_plumb(&amp;opfAsync-&gt;ifA, &amp;opf-&gt;eventIf);</div><div class="line">    EventEmitter_regPathfinderIface(nc-&gt;ee, &amp;opfAsync-&gt;ifB);</div><div class="line">#endif</div></pre></td></tr></table></figure></p>
<p>目前系统中启用了SUBNODE，所以：只分析上面那种。也就是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct SubnodePathfinder* spf = SubnodePathfinder_new(</div><div class="line">    alloc, logger, eventBase, rand, nc-&gt;myAddress, privateKey, encodingScheme, notification);</div><div class="line">struct ASynchronizer* spfAsync = ASynchronizer_new(alloc, eventBase, logger);</div><div class="line">Iface_plumb(&amp;spfAsync-&gt;ifA, &amp;spf-&gt;eventIf);</div><div class="line">EventEmitter_regPathfinderIface(nc-&gt;ee, &amp;spfAsync-&gt;ifB);</div></pre></td></tr></table></figure></p>
<p>它将&amp;spfAsync-&gt;ifA 和 &amp;spf-&gt;eventIf绑定，并通过函数调用，将pf-&gt;iface 和 &amp;spfAsync-&gt;ifB绑定。<br>现在先查看spfAsync-&gt;ifB相关代码，在ASynchronizer.c的ASynchronizer_new中有<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ctx-&gt;pub.ifB.send = fromB;</div></pre></td></tr></table></figure></p>
<p>查看fromB<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">static Iface_DEFUN fromB(struct Message* msg, struct Iface* ifB)</div><div class="line">&#123;</div><div class="line">    struct ASynchronizer_pvt* as = Identity_containerOf(ifB, struct ASynchronizer_pvt, pub.ifB);</div><div class="line">    if (!as-&gt;cycleAlloc) &#123; as-&gt;cycleAlloc = Allocator_child(as-&gt;alloc); &#125;</div><div class="line">    if (!as-&gt;msgsToA) &#123; as-&gt;msgsToA = ArrayList_Messages_new(as-&gt;cycleAlloc); &#125;</div><div class="line">    Allocator_adopt(as-&gt;cycleAlloc, msg-&gt;alloc);</div><div class="line">    ArrayList_Messages_add(as-&gt;msgsToA, msg);</div><div class="line">    checkTimeout(as);</div><div class="line">    return NULL;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意这两句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ArrayList_Messages_add(as-&gt;msgsToA, msg);</div><div class="line">checkTimeout(as);</div></pre></td></tr></table></figure></p>
<p>这个消息被放入到了as-&gt;msgsToA当中，然后调用了checkTimeout(as)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">static void checkTimeout(struct ASynchronizer_pvt* as)</div><div class="line">&#123;</div><div class="line">    if (as-&gt;timeoutAlloc) &#123; return; &#125;</div><div class="line">    as-&gt;timeoutAlloc = Allocator_child(as-&gt;alloc);</div><div class="line">    Timeout_setInterval(timeoutTrigger, as, 1, as-&gt;base, as-&gt;timeoutAlloc);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>调用timeoutTrigger<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">static void timeoutTrigger(void* vASynchronizer)</div><div class="line">&#123;</div><div class="line">    struct ASynchronizer_pvt* as = Identity_check((struct ASynchronizer_pvt*) vASynchronizer);</div><div class="line"></div><div class="line">    if (!as-&gt;cycleAlloc) &#123;</div><div class="line">        if (as-&gt;dryCycles++ &lt; MAX_DRY_CYCLES || !as-&gt;timeoutAlloc) &#123; return; &#125;</div><div class="line">        Allocator_free(as-&gt;timeoutAlloc);</div><div class="line">        as-&gt;timeoutAlloc = NULL;</div><div class="line">        as-&gt;dryCycles = 0;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    struct ArrayList_Messages* msgsToA = as-&gt;msgsToA;</div><div class="line">    struct ArrayList_Messages* msgsToB = as-&gt;msgsToB;</div><div class="line">    struct Allocator* cycleAlloc = as-&gt;cycleAlloc;</div><div class="line">    as-&gt;msgsToA = NULL;</div><div class="line">    as-&gt;msgsToB = NULL;</div><div class="line">    as-&gt;cycleAlloc = NULL;</div><div class="line"></div><div class="line">    if (msgsToA) &#123;</div><div class="line">        for (int i = 0; i &lt; msgsToA-&gt;length; i++) &#123;</div><div class="line">            struct Message* msg = ArrayList_Messages_get(msgsToA, i);</div><div class="line">            Iface_send(&amp;as-&gt;pub.ifA, msg);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if (msgsToB) &#123;</div><div class="line">        for (int i = 0; i &lt; msgsToB-&gt;length; i++) &#123;</div><div class="line">            struct Message* msg = ArrayList_Messages_get(msgsToB, i);</div><div class="line">            Iface_send(&amp;as-&gt;pub.ifB, msg);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    Allocator_free(cycleAlloc);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>之前的代码中，将msg加入到了as-&gt;msgsToA中，所以，这里会执行到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if (msgsToA) &#123;</div><div class="line">    for (int i = 0; i &lt; msgsToA-&gt;length; i++) &#123;</div><div class="line">        struct Message* msg = ArrayList_Messages_get(msgsToA, i);</div><div class="line">        Iface_send(&amp;as-&gt;pub.ifA, msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>调用到<code>Iface_send(&amp;as-&gt;pub.ifA, msg);</code><br>前面在Core.c中讲到过，<code>Iface_plumb(&amp;spfAsync-&gt;ifA, &amp;spf-&gt;eventIf);</code>将spfAsync-&gt;ifA 和 &amp;spf-&gt;eventIf绑定，所以，现在要寻找<code>spf-&gt;eventIf</code>，在subnode/SubnodePathfinder.c的SubnodePathfinder_new方法中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pf-&gt;pub.eventIf.send = incomingFromEventIf;</div></pre></td></tr></table></figure></p>
<p>查看incomingFromEventIf方法，直接给出核心代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">case PFChan_Core_SEARCH_REQ: return searchReq(msg, pf);</div></pre></td></tr></table></figure></p>
<p>查看serchReq方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">static Iface_DEFUN searchReq(struct Message* msg, struct SubnodePathfinder_pvt* pf)</div><div class="line">&#123;</div><div class="line">    uint8_t addr[16];</div><div class="line">    Message_pop(msg, addr, 16, NULL);</div><div class="line">    Message_pop32(msg, NULL);</div><div class="line">    uint32_t version = Message_pop32(msg, NULL);</div><div class="line">    if (version &amp;&amp; version &lt; 20) &#123; return NULL; &#125;</div><div class="line">    Assert_true(!msg-&gt;length);</div><div class="line">    uint8_t printedAddr[40];</div><div class="line">    AddrTools_printIp(printedAddr, addr);</div><div class="line">    Log_debug(pf-&gt;log, &quot;Search req [%s]&quot;, printedAddr);</div><div class="line"></div><div class="line">    if (!pf-&gt;pub.snh || !pf-&gt;pub.snh-&gt;snodeAddr.path) &#123; return NULL; &#125;</div><div class="line"></div><div class="line">    if (!Bits_memcmp(pf-&gt;pub.snh-&gt;snodeAddr.ip6.bytes, addr, 16)) &#123;</div><div class="line">        return sendNode(msg, &amp;pf-&gt;pub.snh-&gt;snodeAddr, 0xfff00000, PFChan_Pathfinder_NODE, pf);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    struct MsgCore_Promise* qp = MsgCore_createQuery(pf-&gt;msgCore, 0, pf-&gt;alloc);</div><div class="line"></div><div class="line">    Dict* dict = qp-&gt;msg = Dict_new(qp-&gt;alloc);</div><div class="line">    qp-&gt;cb = getRouteReply;</div><div class="line">    qp-&gt;userData = pf;</div><div class="line"></div><div class="line">    Assert_true(AddressCalc_validAddress(pf-&gt;pub.snh-&gt;snodeAddr.ip6.bytes));</div><div class="line">    qp-&gt;target = &amp;pf-&gt;pub.snh-&gt;snodeAddr;</div><div class="line"></div><div class="line">    Log_debug(pf-&gt;log, &quot;Sending getRoute to snode %s&quot;,</div><div class="line">        Address_toString(qp-&gt;target, qp-&gt;alloc)-&gt;bytes);</div><div class="line">    Dict_putStringCC(dict, &quot;sq&quot;, &quot;gr&quot;, qp-&gt;alloc);</div><div class="line">    String* src = String_newBinary(pf-&gt;myAddress-&gt;ip6.bytes, 16, qp-&gt;alloc);</div><div class="line">    Dict_putStringC(dict, &quot;src&quot;, src, qp-&gt;alloc);</div><div class="line">    String* target = String_newBinary(addr, 16, qp-&gt;alloc);</div><div class="line">    Dict_putStringC(dict, &quot;tar&quot;, target, qp-&gt;alloc);</div><div class="line"></div><div class="line">    return NULL;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>发往snode的信息包括：</p>
<ul>
<li>“sq”:”gr”</li>
<li>“src”:自己的ipv6地址</li>
<li>“tar”:要寻找的点的ipv6地址<br>这些信息都包含在MsgCore_Promise* qp的msg当中。</li>
</ul>
<p>此外，qp的target为snode的地址，也就是发往snode<br>qp的cb是getRouteReply,这是回调函数。</p>
<p>再回头看这一句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">struct MsgCore_Promise* qp = MsgCore_createQuery(pf-&gt;msgCore, 0, pf-&gt;alloc);</div></pre></td></tr></table></figure></p>
<p>查看MsgCore_createQuery方法，在subnode/MsgCore.c中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">struct MsgCore_Promise* MsgCore_createQuery(struct MsgCore* core,</div><div class="line">                                            uint32_t timeoutMilliseconds,</div><div class="line">                                            struct Allocator* allocator)</div><div class="line">&#123;</div><div class="line">    struct MsgCore_pvt* mcp = Identity_check((struct MsgCore_pvt*) core);</div><div class="line">    if (!timeoutMilliseconds) &#123;</div><div class="line">        timeoutMilliseconds = DEFAULT_TIMEOUT_MILLISECONDS;</div><div class="line">    &#125;</div><div class="line">    struct Pinger_Ping* p = Pinger_newPing(</div><div class="line">        NULL, pingerOnResponse, pingerSendPing, timeoutMilliseconds, allocator, mcp-&gt;pinger);</div><div class="line">    struct MsgCore_Promise_pvt* out =</div><div class="line">        Allocator_calloc(p-&gt;pingAlloc, sizeof(struct MsgCore_Promise_pvt), 1);</div><div class="line">    Identity_set(out);</div><div class="line">    p-&gt;context = out;</div><div class="line">    out-&gt;pub.alloc = p-&gt;pingAlloc;</div><div class="line">    out-&gt;mcp = mcp;</div><div class="line">    out-&gt;ping = p;</div><div class="line">    return &amp;out-&gt;pub;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这是一个Pinger_Ping。pingerSendPing负责发送ping<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">static void pingerSendPing(String* data, void* context)</div><div class="line">&#123;</div><div class="line">    struct MsgCore_Promise_pvt* pp = Identity_check((struct MsgCore_Promise_pvt*) context);</div><div class="line">    Assert_true(pp-&gt;pub.target);</div><div class="line">    Assert_true(pp-&gt;pub.msg);</div><div class="line">    Dict_putStringC(pp-&gt;pub.msg, &quot;txid&quot;, data, pp-&gt;pub.alloc);</div><div class="line">    sendMsg(pp-&gt;mcp, pp-&gt;pub.msg, pp-&gt;pub.target, pp-&gt;pub.alloc);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">static void sendMsg(struct MsgCore_pvt* mcp,</div><div class="line">                    Dict* msgDict,</div><div class="line">                    struct Address* addr,</div><div class="line">                    struct Allocator* allocator)</div><div class="line">&#123;</div><div class="line">    struct Allocator* alloc = Allocator_child(allocator);</div><div class="line"></div><div class="line">    // Send the encoding scheme definition</div><div class="line">    Dict_putString(msgDict, CJDHTConstants_ENC_SCHEME, mcp-&gt;schemeDefinition, allocator);</div><div class="line"></div><div class="line">    // And tell the asker which interface the message came from</div><div class="line">    int encIdx = EncodingScheme_getFormNum(mcp-&gt;scheme, addr-&gt;path);</div><div class="line">    Assert_true(encIdx != EncodingScheme_getFormNum_INVALID);</div><div class="line">    Dict_putInt(msgDict, CJDHTConstants_ENC_INDEX, encIdx, allocator);</div><div class="line"></div><div class="line">    // send the protocol version</div><div class="line">    Dict_putInt(msgDict, CJDHTConstants_PROTOCOL, Version_CURRENT_PROTOCOL, allocator);</div><div class="line"></div><div class="line">    if (!Defined(SUBNODE)) &#123;</div><div class="line">        ......</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    struct Message* msg = Message_new(0, 2048, alloc);</div><div class="line">    BencMessageWriter_write(msgDict, msg, NULL);</div><div class="line"></div><div class="line">    // Sanity check (make sure the addr was actually calculated)</div><div class="line">    Assert_true(AddressCalc_validAddress(addr-&gt;ip6.bytes));</div><div class="line"></div><div class="line">    struct DataHeader data;</div><div class="line">    Bits_memset(&amp;data, 0, sizeof(struct DataHeader));</div><div class="line">    DataHeader_setVersion(&amp;data, DataHeader_CURRENT_VERSION);</div><div class="line">    DataHeader_setContentType(&amp;data, ContentType_CJDHT);</div><div class="line">    Message_push(msg, &amp;data, sizeof(struct DataHeader), NULL);</div><div class="line"></div><div class="line">    struct RouteHeader route;</div><div class="line">    Bits_memset(&amp;route, 0, sizeof(struct RouteHeader));</div><div class="line">    Bits_memcpy(route.ip6, addr-&gt;ip6.bytes, 16);</div><div class="line">    route.version_be = Endian_hostToBigEndian32(addr-&gt;protocolVersion);</div><div class="line">    route.sh.label_be = Endian_hostToBigEndian64(addr-&gt;path);</div><div class="line">    Bits_memcpy(route.publicKey, addr-&gt;key, 32);</div><div class="line">    Message_push(msg, &amp;route, sizeof(struct RouteHeader), NULL);</div><div class="line"></div><div class="line">    Iface_send(&amp;mcp-&gt;pub.interRouterIf, msg);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意这一句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DataHeader_setContentType(&amp;data, ContentType_CJDHT);</div></pre></td></tr></table></figure></p>
<p>其中ContentType_CJDHT的值为256.<br>之后的ping操作不再具体分析。</p>
<h2 id="snode收到了地址询问请求"><a href="#snode收到了地址询问请求" class="headerlink" title="snode收到了地址询问请求"></a>snode收到了地址询问请求</h2><p>snode通过server.js提供寻址服务。源码在cjdnsnode项目的server.js中<br>首先是main<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">const main = (ctx) =&gt; &#123;</div><div class="line">    const config = getConfig();</div><div class="line">    if (!ctx) &#123;</div><div class="line">        ......</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    nThen((waitFor) =&gt; &#123;</div><div class="line">        if (Object.keys(ctx.nodesByIp).length == 0)</div><div class="line">            loadDb(ctx, waitFor());</div><div class="line">        else</div><div class="line">            waitFor();</div><div class="line">    &#125;).nThen((waitFor) =&gt; &#123;</div><div class="line">        //keepTableClean(ctx);</div><div class="line">        if (config.connectCjdns) &#123; service(ctx); &#125;</div><div class="line">        testSrv(ctx);</div><div class="line">        ctx.peer.onAnnounce((peer, msg) =&gt; &#123; handleAnnounce(ctx, msg, false, false); &#125;);</div><div class="line">        (ctx.config.peers || []).forEach(ctx.peer.connectTo);</div><div class="line">    &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>调用<code>service(ctx)</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">const service = (ctx) =&gt; &#123;</div><div class="line">    let cjdns;</div><div class="line">    nThen((waitFor) =&gt; &#123;</div><div class="line">        Cjdnsadmin.connectWithAdminInfo(waitFor((c) =&gt; &#123; cjdns = c; &#125;));</div><div class="line">    &#125;).nThen((waitFor) =&gt; &#123;</div><div class="line">        ......</div><div class="line">    &#125;).nThen((waitFor) =&gt; &#123;</div><div class="line">        Cjdnsniff.sniffTraffic(cjdns, &apos;CJDHT&apos;, waitFor((err, cjdnslink) =&gt; &#123;</div><div class="line">            console.log(&quot;Connected to cjdns engine&quot;);</div><div class="line">            if (err) &#123; throw err; &#125;</div><div class="line">            cjdnslink.on(&apos;error&apos;, (e) =&gt; &#123;</div><div class="line">                console.error(&apos;sniffTraffic error&apos;);</div><div class="line">                console.error(e.stack);</div><div class="line">            &#125;);</div><div class="line">            cjdnslink.on(&apos;message&apos;, (msg) =&gt; &#123;</div><div class="line">                /*::msg = (msg:Cjdnsniff_BencMsg_t);*/</div><div class="line">                onSubnodeMessage(ctx, msg, cjdnslink);</div><div class="line">            &#125;);</div><div class="line">        &#125;));</div><div class="line">    &#125;).nThen((waitFor) =&gt; &#123;</div><div class="line">        ......</div><div class="line">    &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>调用<code>onSubnodeMessage(ctx, msg, cjdnslink);</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">const onSubnodeMessage = (ctx, msg, cjdnslink) =&gt; &#123;</div><div class="line">    if (!msg.contentBenc.sq) &#123; return; &#125;</div><div class="line">    if (!msg.routeHeader.version) &#123;</div><div class="line">        if (msg.contentBenc.p) &#123;</div><div class="line">            msg.routeHeader.version = msg.contentBenc.p;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if (!msg.routeHeader.version || !msg.routeHeader.publicKey) &#123;</div><div class="line">        //if (msg.routeHeader.ip) &#123;</div><div class="line">        console.log(&quot;message from &quot; + msg.routeHeader.ip + `with missing key($&#123;msg.routeHeader.version&#125;) or version($&#123;msg.routeHeader.publicKey&#125;)`);</div><div class="line">        //&#125;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    if (msg.contentBenc.sq.toString(&apos;utf8&apos;) === &apos;gr&apos;) &#123;</div><div class="line">        const srcIp = Cjdnskeys.ip6BytesToString(msg.contentBenc.src);</div><div class="line">        const tarIp = Cjdnskeys.ip6BytesToString(msg.contentBenc.tar);</div><div class="line">        const src = ctx.nodesByIp[srcIp];</div><div class="line">        const tar = ctx.nodesByIp[tarIp];</div><div class="line">        const logMsg = &quot;getRoute req &quot; + srcIp + &quot; &quot; + tarIp + &quot;  &quot;;</div><div class="line">        const r = getRoute(ctx, src, tar);</div><div class="line"></div><div class="line">        if (r) &#123;</div><div class="line">            console.log(logMsg + r.label);</div><div class="line">            msg.contentBenc.n = Buffer.concat([</div><div class="line">                Cjdnskeys.keyStringToBytes(tar.key),</div><div class="line">                new Buffer(r.label.replace(/\./g, &apos;&apos;), &apos;hex&apos;)</div><div class="line">            ]);</div><div class="line">            msg.contentBenc.np = new Buffer([1, tar.version]);</div><div class="line">        &#125; else &#123;</div><div class="line">            console.log(logMsg + &quot;not found&quot;);</div><div class="line">        &#125;</div><div class="line">        msg.contentBenc.recvTime = now();</div><div class="line">        msg.routeHeader.switchHeader.labelShift = 0;</div><div class="line"></div><div class="line">        delete msg.contentBenc.sq;</div><div class="line">        delete msg.contentBenc.src;</div><div class="line">        delete msg.contentBenc.tar;</div><div class="line">        cjdnslink.send(msg);</div><div class="line">    &#125; else if (msg.contentBenc.sq.toString(&apos;utf8&apos;) === &apos;ann&apos;) &#123;</div><div class="line">        ......</div><div class="line">    &#125; else if (msg.contentBenc.sq.toString(&apos;utf8&apos;) === &apos;pn&apos;) &#123;</div><div class="line">        ......</div><div class="line">    &#125; else &#123;</div><div class="line">        console.log(msg.contentBenc);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>调用getRoute(ctx, src, tar);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">const getRoute = (ctx, src, dst) =&gt; &#123;</div><div class="line">    if (!src || !dst) &#123; return null; &#125;</div><div class="line"></div><div class="line">    if (src === dst) &#123;</div><div class="line">        return &#123; label: &apos;0000.0000.0000.0001&apos;, hops: [] &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //if (!ctx.mut.dijkstra) &#123; </div><div class="line">    ctx.mut.routeCache = &#123;&#125;;</div><div class="line">    const dijkstra = ctx.mut.dijkstra = new Dijkstra();</div><div class="line">    for (const nip in ctx.nodesByIp) &#123;</div><div class="line">        const links = ctx.nodesByIp[nip].inwardLinksByIp;</div><div class="line">        const l = &#123;&#125;;</div><div class="line">        for (const pip in links) &#123; l[pip] = linkValue(links[pip]); &#125;</div><div class="line">        ctx.mut.dijkstra.addNode(nip, l);</div><div class="line">    &#125;</div><div class="line">    //&#125;</div><div class="line"></div><div class="line">    // const cachedEntry = ctx.mut.routeCache[dst.ipv6 + &apos;|&apos; + src.ipv6];</div><div class="line">    // if (typeof (cachedEntry) !== &apos;undefined&apos;) &#123;</div><div class="line">    //     return cachedEntry;</div><div class="line">    // &#125;</div><div class="line"></div><div class="line">    // we ask for the path in reverse because we build the graph in reverse.</div><div class="line">    // because nodes announce own their reachability instead of announcing reachability of others.</div><div class="line">    const path = ctx.mut.dijkstra.path(dst.ipv6, src.ipv6);</div><div class="line">    if (!path) &#123;</div><div class="line">        return (ctx.mut.routeCache[dst.ipv6 + &apos;|&apos; + src.ipv6] = null);</div><div class="line">    &#125;</div><div class="line">    path.reverse();</div><div class="line">    let last;</div><div class="line">    let lastLink;</div><div class="line">    const hops = [];</div><div class="line">    const labels = [];</div><div class="line">    let formNum;</div><div class="line"></div><div class="line">    path.forEach((nip) =&gt; &#123;</div><div class="line">        const node = ctx.nodesByIp[nip];</div><div class="line">        if (last) &#123;</div><div class="line">            const link = node.inwardLinksByIp[last.ipv6];</div><div class="line">            let label = link.label;</div><div class="line">            const curFormNum = Cjdnsplice.getEncodingForm(label, last.encodingScheme);</div><div class="line">            if (curFormNum &lt; formNum) &#123;</div><div class="line">                label = Cjdnsplice.reEncode(label, last.encodingScheme, formNum);</div><div class="line">            &#125;</div><div class="line">            labels.unshift(label);</div><div class="line">            hops.push(&#123;</div><div class="line">                label: label,</div><div class="line">                origLabel: link.label,</div><div class="line">                scheme: last.encodingScheme,</div><div class="line">                inverseFormNum: formNum</div><div class="line">            &#125;);</div><div class="line">            formNum = link.encodingFormNum;</div><div class="line">        &#125;</div><div class="line">        last = node;</div><div class="line">    &#125;);</div><div class="line">    labels.unshift(&apos;0000.0000.0000.0001&apos;);</div><div class="line">    const spliced = Cjdnsplice.splice.apply(null, labels);</div><div class="line">    return (ctx.mut.routeCache[dst.ipv6 + &apos;|&apos; + src.ipv6] = &#123; label: spliced, hops: hops, path: path &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="收到snode的地址请求回复后的处理"><a href="#收到snode的地址请求回复后的处理" class="headerlink" title="收到snode的地址请求回复后的处理"></a>收到snode的地址请求回复后的处理</h2><p>上面提到，地址请求的回调函数是subnode/SubnodePathfinder.c中的getRouteReply方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">static void getRouteReply(Dict* msg, struct Address* src, struct MsgCore_Promise* prom)</div><div class="line">&#123;</div><div class="line">    struct SubnodePathfinder_pvt* pf =</div><div class="line">        Identity_check((struct SubnodePathfinder_pvt*) prom-&gt;userData);</div><div class="line">    if (!src) &#123;</div><div class="line">        Log_debug(pf-&gt;log, &quot;GetRoute timeout&quot;);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    Log_debug(pf-&gt;log, &quot;Search reply!&quot;);</div><div class="line">    struct Address_List* al = ReplySerializer_parse(src, msg, pf-&gt;log, false, prom-&gt;alloc);</div><div class="line">    if (!al || al-&gt;length == 0) &#123; return; &#125;</div><div class="line">    Log_debug(pf-&gt;log, &quot;reply with[%s]&quot;, Address_toString(&amp;al-&gt;elems[0], prom-&gt;alloc)-&gt;bytes);</div><div class="line"></div><div class="line">    if (al-&gt;elems[0].protocolVersion &lt; 20) &#123;</div><div class="line">        Log_debug(pf-&gt;log, &quot;not sending [%s] because version is old&quot;,</div><div class="line">            Address_toString(&amp;al-&gt;elems[0], prom-&gt;alloc)-&gt;bytes);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //NodeCache_discoverNode(pf-&gt;nc, &amp;al-&gt;elems[0]);</div><div class="line">    struct Message* msgToCore = Message_new(0, 512, prom-&gt;alloc);</div><div class="line">    Iface_CALL(sendNode, msgToCore, &amp;al-&gt;elems[0], 0xfff00033, PFChan_Pathfinder_NODE, pf);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>调用sendNode<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">static Iface_DEFUN sendNode(struct Message* msg,</div><div class="line">                            struct Address* addr,</div><div class="line">                            uint32_t metric,</div><div class="line">                            enum PFChan_Pathfinder msgType,</div><div class="line">                            struct SubnodePathfinder_pvt* pf)</div><div class="line">&#123;</div><div class="line">    Message_reset(msg);</div><div class="line">    Message_shift(msg, PFChan_Node_SIZE, NULL);</div><div class="line">    nodeForAddress((struct PFChan_Node*) msg-&gt;bytes, addr, metric);</div><div class="line">    if (addr-&gt;path == UINT64_MAX) &#123;</div><div class="line">        ((struct PFChan_Node*) msg-&gt;bytes)-&gt;path_be = 0;</div><div class="line">    &#125;</div><div class="line">    Message_push32(msg, msgType, NULL);</div><div class="line">    return Iface_next(&amp;pf-&gt;pub.eventIf, msg);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后是一个Iface_next,上面讲到过，在Core.c中将(&amp;spfAsync-&gt;ifA 和 &amp;spf-&gt;eventIf绑定，所以，接下来看ASynchronizer的ifA，代码在interface/ASyncronizer.c中，因为ifA和ifB代码完全对称，所以不再做详细分析，调用会因为在Core.c中的设置将将pf-&gt;iface 和 &amp;spfAsync-&gt;ifB绑定，从而调用到net/EventEmitter.c中的incomingFromPathfinder方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">static Iface_DEFUN incomingFromPathfinder(struct Message* msg, struct Iface* iface)</div><div class="line">&#123;</div><div class="line">    struct Pathfinder* pf = Identity_containerOf(iface, struct Pathfinder, iface);</div><div class="line">    struct EventEmitter_pvt* ee = Identity_check((struct EventEmitter_pvt*) pf-&gt;ee);</div><div class="line">    if (msg-&gt;length &lt; 4) &#123;</div><div class="line">        Log_debug(ee-&gt;log, &quot;DROPPF runt&quot;);</div><div class="line">        return NULL;</div><div class="line">    &#125;</div><div class="line">    enum PFChan_Pathfinder ev = Message_pop32(msg, NULL);</div><div class="line">    Message_push32(msg, pf-&gt;pathfinderId, NULL);</div><div class="line">    Message_push32(msg, ev, NULL);</div><div class="line">    if (ev &lt;= PFChan_Pathfinder__TOO_LOW || ev &gt;= PFChan_Pathfinder__TOO_HIGH) &#123;</div><div class="line">        Log_debug(ee-&gt;log, &quot;DROPPF invalid type [%d]&quot;, ev);</div><div class="line">        return NULL;</div><div class="line">    &#125;</div><div class="line">    if (!PFChan_Pathfinder_sizeOk(ev, msg-&gt;length)) &#123;</div><div class="line">        Log_debug(ee-&gt;log, &quot;DROPPF incorrect length[%d] for type [%d]&quot;, msg-&gt;length, ev);</div><div class="line">        return NULL;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (pf-&gt;state == Pathfinder_state_DISCONNECTED) &#123;</div><div class="line">        if (ev != PFChan_Pathfinder_CONNECT) &#123;</div><div class="line">            Log_debug(ee-&gt;log, &quot;DROPPF disconnected and event != CONNECT event:[%d]&quot;, ev);</div><div class="line">            return NULL;</div><div class="line">        &#125;</div><div class="line">    &#125; else if (pf-&gt;state != Pathfinder_state_CONNECTED) &#123;</div><div class="line">        Log_debug(ee-&gt;log, &quot;DROPPF error state&quot;);</div><div class="line">        return NULL;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (handleFromPathfinder(ev, msg, ee, pf)) &#123; return NULL; &#125;</div><div class="line"></div><div class="line">    struct ArrayList_Ifaces* handlers = getHandlers(ee, ev, false);</div><div class="line">    if (!handlers) &#123; return NULL; &#125;</div><div class="line">    for (int i = 0; i &lt; handlers-&gt;length; i++) &#123;</div><div class="line">        struct Message* messageClone = Message_clone(msg, msg-&gt;alloc);</div><div class="line">        struct Iface* iface = ArrayList_Ifaces_get(handlers, i);</div><div class="line">        // We have to call this manually because we don&apos;t have an interface handy which is</div><div class="line">        // actually plumbed with this one.</div><div class="line">        Assert_true(iface);</div><div class="line">        Assert_true(iface-&gt;send);</div><div class="line">        Iface_CALL(iface-&gt;send, messageClone, iface);</div><div class="line">    &#125;</div><div class="line">    return NULL;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/08/28/cjdns-SuperNodeHunter/" data-id="cje6pjw4j00dvweyxha2vzc0z" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C/">C/C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cjdns/">cjdns</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cjdns源码分析/">cjdns源码分析</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-rom7.0-build" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/25/rom7.0-build/" class="article-date">
  <time datetime="2017-08-25T02:21:40.000Z" itemprop="datePublished">2017-08-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Anrom/">Anrom</a>►<a class="article-category-link" href="/categories/Anrom/rom7-0/">rom7.0</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/25/rom7.0-build/">Android7.0Rom编译相关</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="踩过的坑"><a href="#踩过的坑" class="headerlink" title="踩过的坑"></a>踩过的坑</h2><h3 id="？？？"><a href="#？？？" class="headerlink" title="？？？"></a>？？？</h3><p>错误描述<br>没记下来<br>解决方法<br>执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">art/runtime/interpreter/mterp/rebuild.sh</div></pre></td></tr></table></figure></p>
<h3 id="Cannot-allocate-memory"><a href="#Cannot-allocate-memory" class="headerlink" title="Cannot allocate memory"></a>Cannot allocate memory</h3><p>错误描述<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ninja: fatal: fork: Cannot allocate memory</div><div class="line">build/core/ninja.mk:151: recipe for target &apos;ninja_wrapper&apos; failed</div><div class="line">make: *** [ninja_wrapper] Error 1</div></pre></td></tr></table></figure></p>
<p>解决方法</p>
<h4 id="第一种解决方法：内存不够用了，首先执行free，查看内存使用状况"><a href="#第一种解决方法：内存不够用了，首先执行free，查看内存使用状况" class="headerlink" title="第一种解决方法：内存不够用了，首先执行free，查看内存使用状况"></a>第一种解决方法：内存不够用了，首先执行free，查看内存使用状况</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">              total        used        free      shared  buff/cache   available</div><div class="line">Mem:       16382208     9798008      314756      734804     6269444     5714252</div><div class="line">Swap:       8098808      276960     7821848</div></pre></td></tr></table></figure>
<p>如果本身硬件内存够大，优先考虑降低内存使用量，运行top，shift+m，按照内存排序，把内存使用量大的进程看情况杀掉一些。</p>
<ul>
<li>清除buff/cache<br>执行free后发现buff/cache异常的高，占了快一半的内存。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo 3 &gt; /proc/sys/vm/drop_caches</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="第二种方法，修改JACK-SERVER-VM-ARGUMENTS"><a href="#第二种方法，修改JACK-SERVER-VM-ARGUMENTS" class="headerlink" title="第二种方法，修改JACK_SERVER_VM_ARGUMENTS"></a>第二种方法，修改JACK_SERVER_VM_ARGUMENTS</h4><ol>
<li>第一种解决方法，这种起作用了<br>编辑~/.profile  增加<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export JACK_SERVER_VM_ARGUMENTS=&quot;-Dfile.encoding=UTF-8 -XX:+TieredCompilation -Xmx4g&quot;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">jack-admin kill-server </div><div class="line">jack-admin start-server</div><div class="line">source ~/.profile</div></pre></td></tr></table></figure></p>
<p>然后再编译</p>
<ol>
<li>修改vim prebuilts/sdk/tools/jack-admin<br>将<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">JACK_SERVER_COMMAND=&quot;java -XX:MaxJavaStackTraceDepth=-1 -Djava.io.tmpdir=$TMPDIR $JACK_SERVER_VM_ARGUMENTS -cp $LAUNCHER_JAR $LAUNCHER_NAME&quot;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>改成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">JACK_SERVER_COMMAND=&quot;java -XX:MaxJavaStackTraceDepth=-1 -Djava.io.tmpdir=$TMPDIR $JACK_SERVER_VM_ARGUMENTS -Xmx8g -cp $LAUNCHER_JAR $LAUNCHER_NAME&quot;</div></pre></td></tr></table></figure></p>
<p>运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">jack-admin kill-server </div><div class="line">jack-admin start-server</div></pre></td></tr></table></figure></p>
<p>然后再编译</p>
<h4 id="第三种方法：修改swap大小"><a href="#第三种方法：修改swap大小" class="headerlink" title="第三种方法：修改swap大小"></a>第三种方法：修改swap大小</h4><pre><code>1.创建交换分区的文件:增加1G大小的交换分区，则命令写法如下，其中的 count 等于想要的块大小。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># dd if=/dev/zero of=/home/swapfile bs=1M count=1024</div></pre></td></tr></table></figure>

2.设置交换分区文件:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># mkswap /home/swapfile  #建立swap的文件系统</div></pre></td></tr></table></figure>

3.立即启用交换分区文件:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># swapon /home/swapfile   #启用swap文件</div></pre></td></tr></table></figure>

4.使系统开机时自启用，在文件/etc/fstab中添加一行：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/home/swapfile swap swap defaults 0 0</div></pre></td></tr></table></figure>
</code></pre><h3 id="subcommand-failed"><a href="#subcommand-failed" class="headerlink" title="subcommand failed"></a>subcommand failed</h3><p>错误描述：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/bin/bash: xmllint: 未找到命令</div><div class="line">.........</div><div class="line">[ 32% 1076/3288] Building with Jack: /home/...mework_intermediates/with-local/classes.dex</div><div class="line">ninja: build stopped: subcommand failed.</div><div class="line">build/core/ninja.mk:151: recipe for target &apos;ninja_wrapper&apos; failed</div><div class="line">make: *** [ninja_wrapper] Error 1</div></pre></td></tr></table></figure></p>
<p>解决方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install libxml2-utils</div></pre></td></tr></table></figure></p>
<p>错误描述：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">FAILED: /bin/bash -c &quot;prebuilts/misc/linux-x86/flex/flex-2.5.39 -o/home/chris/rom7.0/out/host/linux-x86/obj/STATIC_LIBRARIES/libaidl-common_intermediates/aidl_language_l.cpp system/tools/aidl/aidl_language_l.ll&quot;</div><div class="line">flex-2.5.39：严重内部错误，exec of /usr/bin/m4 failed</div><div class="line">[  0% 8/49773] Yacc: aidl &lt;= system/tools/aidl/aidl_language_y.yy</div><div class="line">FAILED: /bin/bash -c &quot;prebuilts/misc/linux-x86/bison/bison -d  --defines=/home/chris/rom7.0/out/host/linux-x86/obj/STATIC_LIBRARIES/libaidl-common_intermediates/aidl_language_y.h -o /home/chris/rom7.0/out/host/linux-x86/obj/STATIC_LIBRARIES/libaidl-common_intermediates/aidl_language_y.cpp system/tools/aidl/aidl_language_y.yy&quot;</div><div class="line">[  0% 8/49773] host C++: ijar &lt;= build/tools/ijar/classfile.cc</div><div class="line">ninja: build stopped: subcommand failed.</div><div class="line">build/core/ninja.mk:151: recipe for target &apos;ninja_wrapper&apos; failed</div><div class="line">make: *** [ninja_wrapper] Error 1</div></pre></td></tr></table></figure></p>
<p>解决方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install m4</div></pre></td></tr></table></figure></p>
<h3 id="Oracle-JDK-7-is-NOT-installed"><a href="#Oracle-JDK-7-is-NOT-installed" class="headerlink" title="Oracle JDK 7 is NOT installed."></a>Oracle JDK 7 is NOT installed.</h3><p>错误描述<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Oracle JDK 7 is NOT installed.</div><div class="line">dpkg: 处理软件包 oracle-java7-installer (--configure)时出错：</div><div class="line"> 子进程 已安装 post-installation 脚本 返回错误状态 1</div><div class="line">正在设置 libxml2-utils (2.9.3+dfsg1-1ubuntu0.2) ...</div><div class="line">在处理时有错误发生：</div><div class="line"> oracle-java7-installer</div><div class="line">E: Sub-process /usr/bin/dpkg returned an error code (1)</div></pre></td></tr></table></figure></p>
<p>解决方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">sudo update-alternatives --config java</div><div class="line">有 2 个候选项可用于替换 java (提供 /usr/bin/java)。</div><div class="line"></div><div class="line">  选择       路径                                          优先级  状态</div><div class="line">------------------------------------------------------------</div><div class="line">  0            /usr/lib/jvm/java-8-oracle/jre/bin/java          1081      自动模式</div><div class="line">  1            /usr/lib/jvm/java-8-openjdk-amd64/jre/bin/java   1081      手动模式</div><div class="line">* 2            /usr/lib/jvm/java-8-oracle/jre/bin/java          1081      手动模式</div><div class="line"></div><div class="line">要维持当前值[*]请按&lt;回车键&gt;，或者键入选择的编号：1</div><div class="line">update-alternatives: 使用 /usr/lib/jvm/java-8-openjdk-amd64/jre/bin/java 来在手动模式中提供 /usr/bin/java (java)</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/08/25/rom7.0-build/" data-id="cje6pjw2x006hweyxdxm3ce5e" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Anrom/">Anrom</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-cjdns_RouteGen-d" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/02/cjdns_RouteGen-d/" class="article-date">
  <time datetime="2017-08-02T03:42:23.000Z" itemprop="datePublished">2017-08-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/cjdns/">cjdns</a>►<a class="article-category-link" href="/categories/cjdns/cjdns源码分析/">cjdns源码分析</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/02/cjdns_RouteGen-d/">cjdns源码分析--RouteGen</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">struct RouteGen</div><div class="line">&#123;</div><div class="line">    bool hasUncommittedChanges;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line">struct RouteGen_pvt</div><div class="line">&#123;</div><div class="line">    struct RouteGen pub;</div><div class="line">    struct ArrayList_OfPrefix6* prefixes6;</div><div class="line">    struct ArrayList_OfPrefix6* localPrefixes6;</div><div class="line">    struct ArrayList_OfPrefix6* exceptions6;</div><div class="line"></div><div class="line">    struct ArrayList_OfPrefix4* prefixes4;</div><div class="line">    struct ArrayList_OfPrefix4* localPrefixes4;</div><div class="line">    struct ArrayList_OfPrefix4* exceptions4;</div><div class="line"></div><div class="line">    struct Allocator* alloc;</div><div class="line">    struct Log* log;</div><div class="line"></div><div class="line">    Identity</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>可以看到，ipv4和ipv6各有三个ArrayList。这里面放着一些网段信息。</p>
<h2 id="RouteGen-new"><a href="#RouteGen-new" class="headerlink" title="RouteGen_new"></a>RouteGen_new</h2><p>这个方法在Core.c的Core_init中调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">struct RouteGen* RouteGen_new(struct Allocator* allocator, struct Log* log)</div><div class="line">&#123;</div><div class="line">    struct Allocator* alloc = Allocator_child(allocator);</div><div class="line">    struct RouteGen_pvt* rp = Allocator_calloc(alloc, sizeof(struct RouteGen_pvt), 1);</div><div class="line">    rp-&gt;prefixes6 = ArrayList_OfPrefix6_new(alloc);</div><div class="line">    rp-&gt;localPrefixes6 = ArrayList_OfPrefix6_new(alloc);</div><div class="line">    rp-&gt;exceptions6 = ArrayList_OfPrefix6_new(alloc);</div><div class="line">    rp-&gt;prefixes4 = ArrayList_OfPrefix4_new(alloc);</div><div class="line">    rp-&gt;localPrefixes4 = ArrayList_OfPrefix4_new(alloc);</div><div class="line">    rp-&gt;exceptions4 = ArrayList_OfPrefix4_new(alloc);</div><div class="line">    rp-&gt;log = log;</div><div class="line">    rp-&gt;alloc = alloc;</div><div class="line">    Identity_set(rp);</div><div class="line">    setupDefaultLocalPrefixes(rp);</div><div class="line">    return &amp;rp-&gt;pub;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>除了简单的赋值之外，主要做了两件事：</p>
<ol>
<li>new各种ArrayList</li>
<li>setupDefaultLocalPrefixes<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">static void setupDefaultLocalPrefixes(struct RouteGen_pvt* rp)</div><div class="line">&#123;</div><div class="line">    struct Sockaddr_storage ss;</div><div class="line">    #define ADD_PREFIX(str) \</div><div class="line">        Assert_true(!Sockaddr_parse(str, &amp;ss));       \</div><div class="line">        RouteGen_addLocalPrefix(&amp;rp-&gt;pub, &amp;ss.addr)</div><div class="line"></div><div class="line">    ADD_PREFIX(&quot;fe80::/10&quot;);</div><div class="line">    ADD_PREFIX(&quot;fd00::/8&quot;);</div><div class="line"></div><div class="line">    ADD_PREFIX(&quot;10.0.0.0/8&quot;);</div><div class="line">    ADD_PREFIX(&quot;172.16.0.0/12&quot;);</div><div class="line">    ADD_PREFIX(&quot;192.168.0.0/16&quot;);</div><div class="line">    ADD_PREFIX(&quot;127.0.0.0/8&quot;);</div><div class="line"></div><div class="line">    #undef ADD_PREFIX</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这个函数add了一些网段信息到LocalPrefix表。<br>这个过程调用到了两个函数:<br>1.Sockaddr_parse<br>将一个字符串类型的ip地址转成Sockaddr_storage类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line">struct Sockaddr</div><div class="line">&#123;</div><div class="line">    /** the length of this sockaddr, this field is included in the length. */</div><div class="line">    uint16_t addrLen;</div><div class="line"></div><div class="line">    #define Sockaddr_flags_BCAST  1</div><div class="line">    #define Sockaddr_flags_PREFIX (1&lt;&lt;1)</div><div class="line">    uint16_t flags;</div><div class="line"></div><div class="line">    /** Only applies if flags &amp; Sockaddr_flags_PREFIX is true. */</div><div class="line">    uint8_t prefix;</div><div class="line"></div><div class="line">    uint8_t pad1;</div><div class="line">    uint16_t pad2;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct Sockaddr_storage</div><div class="line">&#123;</div><div class="line">    struct Sockaddr addr;</div><div class="line">    uint64_t nativeAddr[Sockaddr_MAXSIZE / 8];</div><div class="line">&#125;;</div><div class="line"></div><div class="line">int Sockaddr_parse(const char* input, struct Sockaddr_storage* out)</div><div class="line">&#123;</div><div class="line">    struct Sockaddr_storage unusedOut;</div><div class="line">    if (!out) &#123;</div><div class="line">        out = &amp;unusedOut;</div><div class="line">    &#125;</div><div class="line">    uint8_t buff[64] = &#123;0&#125;;</div><div class="line">    if (CString_strlen(input) &gt; 63) &#123;</div><div class="line">        return -1;</div><div class="line">    &#125;</div><div class="line">    CString_strncpy(buff, input, 63);</div><div class="line"></div><div class="line">    int64_t port = 0;</div><div class="line">    char* lastColon = CString_strrchr(buff, &apos;:&apos;);</div><div class="line">    char* firstColon = CString_strchr(buff, &apos;:&apos;);</div><div class="line">    char* bracket = CString_strchr(buff, &apos;]&apos;);</div><div class="line">    if (!lastColon) &#123;</div><div class="line">        // ipv4, no port</div><div class="line">    &#125; else if (lastColon != firstColon &amp;&amp; (!bracket || lastColon &lt; bracket)) &#123;</div><div class="line">        // ipv6, no port</div><div class="line">    &#125; else &#123;</div><div class="line">        if (bracket &amp;&amp; lastColon != &amp;bracket[1]) &#123; return -1; &#125;</div><div class="line">        if (Base10_fromString(&amp;lastColon[1], &amp;port)) &#123; return -1; &#125;</div><div class="line">        if (port &gt; 65535) &#123; return -1; &#125;</div><div class="line">        *lastColon = &apos;\0&apos;;</div><div class="line">    &#125;</div><div class="line">    if (bracket) &#123;</div><div class="line">        *bracket = &apos;\0&apos;;</div><div class="line">        if (buff[0] != &apos;[&apos;) &#123; return -1; &#125;</div><div class="line">    &#125; else if (buff[0] == &apos;[&apos;) &#123; return -1; &#125;</div><div class="line"></div><div class="line">    int64_t prefix = -1;</div><div class="line">    char* slash = CString_strchr(buff, &apos;/&apos;);</div><div class="line">    if (slash) &#123;</div><div class="line">        *slash = &apos;\0&apos;;</div><div class="line">        if (!slash[1]) &#123; return -1; &#125;</div><div class="line">        if (Base10_fromString(&amp;slash[1], &amp;prefix)) &#123; return -1; &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Bits_memset(out, 0, sizeof(struct Sockaddr_storage));</div><div class="line">    if (lastColon != firstColon) &#123;</div><div class="line">        // ipv6</div><div class="line">        struct sockaddr_in6* in6 = (struct sockaddr_in6*) Sockaddr_asNative(&amp;out-&gt;addr);</div><div class="line">        if (uv_inet_pton(AF_INET6, (char*) ((buff[0] == &apos;[&apos;) ? &amp;buff[1] : buff), &amp;in6-&gt;sin6_addr)) &#123;</div><div class="line">            return -1;</div><div class="line">        &#125;</div><div class="line">        out-&gt;addr.addrLen = sizeof(struct sockaddr_in6) + Sockaddr_OVERHEAD;</div><div class="line">        in6-&gt;sin6_port = Endian_hostToBigEndian16(port);</div><div class="line">        in6-&gt;sin6_family = AF_INET6;</div><div class="line">    &#125; else &#123;</div><div class="line">        struct sockaddr_in* in = ((struct sockaddr_in*) Sockaddr_asNative(&amp;out-&gt;addr));</div><div class="line">        if (uv_inet_pton(AF_INET, (char*) buff, &amp;in-&gt;sin_addr)) &#123;</div><div class="line">            return -1;</div><div class="line">        &#125;</div><div class="line">        out-&gt;addr.addrLen = sizeof(struct sockaddr_in) + Sockaddr_OVERHEAD;</div><div class="line">        in-&gt;sin_port = Endian_hostToBigEndian16(port);</div><div class="line">        in-&gt;sin_family = AF_INET;</div><div class="line">    &#125;</div><div class="line">    if (prefix != -1) &#123;</div><div class="line">        if (prefix &lt; 0 || prefix &gt; 128) &#123; return -1; &#125;</div><div class="line">        if (Sockaddr_getFamily(&amp;out-&gt;addr) == Sockaddr_AF_INET &amp;&amp; prefix &gt; 32) &#123; return -1; &#125;</div><div class="line">        out-&gt;addr.prefix = prefix;</div><div class="line">        out-&gt;addr.flags |= Sockaddr_flags_PREFIX;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>看一下跟prefix相关的代码，基本上可以将prefix理解为掩码的长度。这个变量可以用来判断两个ip地址是否在同一网段，或某个网段是否是另一个网段的子集。</p>
<p>2.RouteGen_addLocalPrefix<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">void RouteGen_addLocalPrefix(struct RouteGen* rg, struct Sockaddr* destination)</div><div class="line">&#123;</div><div class="line">    struct RouteGen_pvt* rp = Identity_check((struct RouteGen_pvt*) rg);</div><div class="line">    addSomething(rp, destination, rp-&gt;localPrefixes6, rp-&gt;localPrefixes4);</div><div class="line">&#125;</div><div class="line"></div><div class="line">static void addSomething(struct RouteGen_pvt* rp,</div><div class="line">                         struct Sockaddr* exempt,</div><div class="line">                         struct ArrayList_OfPrefix6* list6,</div><div class="line">                         struct ArrayList_OfPrefix4* list4)</div><div class="line">&#123;</div><div class="line">    if (Sockaddr_getFamily(exempt) == Sockaddr_AF_INET) &#123;</div><div class="line">        struct Prefix4* p4 = sockaddrToPrefix4(exempt, rp-&gt;alloc);</div><div class="line">        ArrayList_OfPrefix4_add(list4, p4);</div><div class="line">    &#125; else if (Sockaddr_getFamily(exempt) == Sockaddr_AF_INET6) &#123;</div><div class="line">        struct Prefix6* p6 = sockaddrToPrefix6(exempt, rp-&gt;alloc);</div><div class="line">        ArrayList_OfPrefix6_add(list6, p6);</div><div class="line">    &#125; else &#123;</div><div class="line">        Assert_failure(&quot;unexpected addr type&quot;);</div><div class="line">    &#125;</div><div class="line">    rp-&gt;pub.hasUncommittedChanges = true;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>将一些路由信息加入到localPrefixes表中。</p>
<h2 id="RouteGen-commit"><a href="#RouteGen-commit" class="headerlink" title="RouteGen_commit"></a>RouteGen_commit</h2><p>这个函数有两个地方调用：</p>
<ol>
<li>在RouteGen_admin中注册，作为一个外部可直接调用的API，需要传入tunName。目前代码自己运行的逻辑中并未使用这种调用。</li>
<li>在IpTunnel.c的incomingAddresses方法中调用。也就是在普通点收到离岸点分配的ip之后，会调用到该方法。</li>
</ol>
<p>分析一下这个函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">void RouteGen_commit(struct RouteGen* rg,</div><div class="line">                     const char* tunName,</div><div class="line">                     struct Allocator* tempAlloc,</div><div class="line">                     struct Except* eh)</div><div class="line">&#123;</div><div class="line">    struct RouteGen_pvt* rp = Identity_check((struct RouteGen_pvt*) rg);</div><div class="line">    struct Prefix46* p46 = getGeneratedRoutes(rp, tempAlloc);</div><div class="line">    struct Sockaddr** prefixSet =</div><div class="line">        Allocator_calloc(tempAlloc, sizeof(char*), p46-&gt;prefix4-&gt;length + p46-&gt;prefix6-&gt;length);</div><div class="line">    int prefixNum = 0;</div><div class="line">    for (int i = 0; i &lt; p46-&gt;prefix4-&gt;length; i++) &#123;</div><div class="line">        struct Prefix4* pfx4 = ArrayList_OfPrefix4_get(p46-&gt;prefix4, i);</div><div class="line">        prefixSet[prefixNum++] = sockaddrForPrefix4(tempAlloc, pfx4);</div><div class="line">    &#125;</div><div class="line">    for (int i = 0; i &lt; p46-&gt;prefix6-&gt;length; i++) &#123;</div><div class="line">        struct Prefix6* pfx6 = ArrayList_OfPrefix6_get(p46-&gt;prefix6, i);</div><div class="line">        prefixSet[prefixNum++] = sockaddrForPrefix6(tempAlloc, pfx6);</div><div class="line">    &#125;</div><div class="line">    Assert_true(prefixNum == p46-&gt;prefix4-&gt;length + p46-&gt;prefix6-&gt;length);</div><div class="line">    NetDev_setRoutes(tunName, prefixSet, prefixNum, rp-&gt;log, tempAlloc, eh);</div><div class="line">    rp-&gt;pub.hasUncommittedChanges = false;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>依次做了一下操作：</p>
<h3 id="1-getGeneratedRoutes"><a href="#1-getGeneratedRoutes" class="headerlink" title="1. getGeneratedRoutes"></a>1. getGeneratedRoutes</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">static struct Prefix46* getGeneratedRoutes(struct RouteGen_pvt* rp, struct Allocator* alloc)</div><div class="line">&#123;</div><div class="line">    struct Prefix46* out = Allocator_calloc(alloc, sizeof(struct Prefix46), 1);</div><div class="line">    if (rp-&gt;prefixes4-&gt;length &gt; 0) &#123;</div><div class="line">        out-&gt;prefix4 = genPrefixes4(rp-&gt;prefixes4, rp-&gt;exceptions4, rp-&gt;localPrefixes4, alloc);</div><div class="line">    &#125; else &#123;</div><div class="line">        out-&gt;prefix4 = ArrayList_OfPrefix4_new(alloc);</div><div class="line">    &#125;</div><div class="line">    if (rp-&gt;prefixes6-&gt;length &gt; 0) &#123;</div><div class="line">        out-&gt;prefix6 = genPrefixes6(rp-&gt;prefixes6, rp-&gt;exceptions6, rp-&gt;localPrefixes6, alloc);</div><div class="line">    &#125; else &#123;</div><div class="line">        out-&gt;prefix6 = ArrayList_OfPrefix6_new(alloc);</div><div class="line">    &#125;</div><div class="line">    return out;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数，针对ipv4和ipv6做了一样的操作：如果prefixes的length&gt;0，调用genPrefixes方法，否则new一个对应的ArrayList。<br>查看一下genPrefixes方法，以genPrefixes4为例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line">static struct ArrayList_OfPrefix4* genPrefixes4(struct ArrayList_OfPrefix4* prefixes,</div><div class="line">                                                struct ArrayList_OfPrefix4* exceptions,</div><div class="line">                                                struct ArrayList_OfPrefix4* localPrefixes,</div><div class="line">                                                struct Allocator* alloc)</div><div class="line">&#123;</div><div class="line">    struct Allocator* tempAlloc = Allocator_child(alloc);</div><div class="line"></div><div class="line">    struct ArrayList_OfPrefix4* effectiveLocalPrefixes = ArrayList_OfPrefix4_new(tempAlloc);</div><div class="line">    for (int i = 0; i &lt; localPrefixes-&gt;length; i++) &#123;</div><div class="line">        bool add = true;</div><div class="line">        struct Prefix4* localPfx = ArrayList_OfPrefix4_get(localPrefixes, i);</div><div class="line">        for (int j = 0; j &lt; prefixes-&gt;length; j++) &#123;</div><div class="line">            struct Prefix4* pfx = ArrayList_OfPrefix4_get(prefixes, j);</div><div class="line">            if (isSubsetOf4(pfx, localPfx)) &#123;</div><div class="line">                add = false;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (add) &#123;</div><div class="line">            ArrayList_OfPrefix4_add(effectiveLocalPrefixes, localPfx);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    struct ArrayList_OfPrefix4* allPrefixes = ArrayList_OfPrefix4_new(tempAlloc);</div><div class="line">    for (int i = 0; i &lt; exceptions-&gt;length; i++) &#123;</div><div class="line">        struct Prefix4* pfxToInvert = ArrayList_OfPrefix4_get(exceptions, i);</div><div class="line">        bool add = true;</div><div class="line">        for (int j = 0; j &lt; effectiveLocalPrefixes-&gt;length; j++) &#123;</div><div class="line">            struct Prefix4* localPfx = ArrayList_OfPrefix4_get(effectiveLocalPrefixes, j);</div><div class="line">            if (isSubsetOf4(pfxToInvert, localPfx)) &#123;</div><div class="line">                add = false;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (add) &#123;</div><div class="line">            struct ArrayList_OfPrefix4* prefixes4 = invertPrefix4(pfxToInvert, tempAlloc);</div><div class="line">            mergePrefixSets4(allPrefixes, prefixes4);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for (int i = allPrefixes-&gt;length - 2; i &gt;= 0; i--) &#123;</div><div class="line">        struct Prefix4* pfx = ArrayList_OfPrefix4_get(allPrefixes, i);</div><div class="line">        struct Prefix4* pfx2 = ArrayList_OfPrefix4_get(allPrefixes, i+1);</div><div class="line">        if (isSubsetOf4(pfx2, pfx)) &#123;</div><div class="line">            ArrayList_OfPrefix4_remove(allPrefixes, i+1);</div><div class="line">            if (i &lt; (allPrefixes-&gt;length - 2)) &#123; i++; &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for (int i = 0; i &lt; prefixes-&gt;length; i++) &#123;</div><div class="line">        struct Prefix4* pfx = ArrayList_OfPrefix4_get(prefixes, i);</div><div class="line">        int addPrefix = true;</div><div class="line">        for (int j = allPrefixes-&gt;length - 1; j &gt;= 0; j--) &#123;</div><div class="line">            struct Prefix4* pfx2 = ArrayList_OfPrefix4_get(allPrefixes, j);</div><div class="line">            if (isSubsetOf4(pfx2, pfx)) &#123;</div><div class="line">                addPrefix = false;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (addPrefix) &#123;</div><div class="line">            ArrayList_OfPrefix4_add(allPrefixes, pfx);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ArrayList_OfPrefix4_sort(allPrefixes);</div><div class="line"></div><div class="line">    struct ArrayList_OfPrefix4* out = ArrayList_OfPrefix4_new(alloc);</div><div class="line">    for (int i = 0; i &lt; allPrefixes-&gt;length; i++) &#123;</div><div class="line">        struct Prefix4* pfx = ArrayList_OfPrefix4_get(allPrefixes, i);</div><div class="line">        for (int j = 0; j &lt; prefixes-&gt;length; j++) &#123;</div><div class="line">            struct Prefix4* pfx2 = ArrayList_OfPrefix4_get(prefixes, j);</div><div class="line">            if (isSubsetOf4(pfx, pfx2)) &#123;</div><div class="line">                ArrayList_OfPrefix4_add(out, clonePrefix4(pfx, alloc));</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    Allocator_free(tempAlloc);</div><div class="line">    return out;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这是一个重要的函数，它将prefixes,exceptions,localPrefixes三个ArrayList中的内容进行merge，共同形成一个新的ArrayList.</p>
<h4 id="0-各prefixes的内容"><a href="#0-各prefixes的内容" class="headerlink" title="0. 各prefixes的内容"></a>0. 各prefixes的内容</h4><p>按照程序目前的运行流程，当收到离岸点分配的ipv4地址后，首次调用RouteGen_commit，进而调用到genPrefixes4，此时，三个prefixes中的内容如下：</p>
<ol>
<li><p>rp-&gt;prefixes4 这是自己的ipv4地址，由离岸点分配得到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1467638405 DEBUG RouteGen.c:137 getGeneratedRoutes rp prefixes4</div><div class="line">1467638405 DEBUG Prefix.c:112 printprefix 192.168.254.2/0</div></pre></td></tr></table></figure>
</li>
<li><p>rp-&gt;localPrefixes4 这是一些local地址，在RouteGen.c中的RouteGen_new函数中，通过调用setupDefaultLocalPrefixes方法来设置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1467638405 DEBUG RouteGen.c:139 getGeneratedRoutes rp localPrefixes4</div><div class="line">1467638405 DEBUG Prefix.c:112 printprefix 10.0.0.0/8</div><div class="line">1467638405 DEBUG Prefix.c:112 printprefix 172.16.0.0/12</div><div class="line">1467638405 DEBUG Prefix.c:112 printprefix 192.168.0.0/16</div><div class="line">1467638405 DEBUG Prefix.c:112 printprefix 127.0.0.0/8</div></pre></td></tr></table></figure>
</li>
<li><p>rp-&gt;exceptions4 这是接入点的ipv4地址，在Configurator.c文件中，通过调用接口设置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1467638405 DEBUG RouteGen.c:141 getGeneratedRoutes rp exceptions4</div><div class="line">1467638405 DEBUG Prefix.c:112 printprefix 106.75.59.53/32</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="1-prefixes和localPrefixes-进行merge"><a href="#1-prefixes和localPrefixes-进行merge" class="headerlink" title="1. prefixes和localPrefixes 进行merge"></a>1. prefixes和localPrefixes 进行merge</h4><p> 先看第一块代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">for (int i = 0; i &lt; localPrefixes-&gt;length; i++) &#123;</div><div class="line">    bool add = true;</div><div class="line">    struct Prefix4* localPfx = ArrayList_OfPrefix4_get(localPrefixes, i);</div><div class="line">    for (int j = 0; j &lt; prefixes-&gt;length; j++) &#123;</div><div class="line">        struct Prefix4* pfx = ArrayList_OfPrefix4_get(prefixes, j);</div><div class="line">        if (isSubsetOf4(pfx, localPfx)) &#123;</div><div class="line">            add = false;</div><div class="line">            break;</div><div class="line">        &#125; </div><div class="line">    &#125;</div><div class="line">    if (add) &#123;</div><div class="line">        ArrayList_OfPrefix4_add(effectiveLocalPrefixes, localPfx);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这一块代码，将localPrefixes和prefixes中网段依次取出，放入isSubsetOf4函数中进行检测，如果prefixes中的网段不是localPrefixes中的网段的子集，就将这条从localPrefixes中取出的网段放入effectiveLocalPrefixes中。<br>也就是说，一条localPrefixes中的网段想要被加入effectiveLocalPrefixes中，必须满足条件：在prefixes中没有比它更加精准的网段匹配项，或者说，没有比它范围更小的匹配项。看一下isSubsetOf4的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">struct Prefix4</div><div class="line">&#123;</div><div class="line">    uint32_t bits;   //addr</div><div class="line">    int prefix;</div><div class="line">    struct Allocator* alloc;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">static bool isSubsetOf4(struct Prefix4* isSubset, struct Prefix4* isSuperset)</div><div class="line">&#123;</div><div class="line">    if (isSuperset-&gt;prefix &gt; isSubset-&gt;prefix) &#123; return false; &#125;</div><div class="line">    if (isSuperset-&gt;prefix &gt;= 32) &#123;</div><div class="line">        return isSuperset-&gt;bits == isSubset-&gt;bits;</div><div class="line">    &#125;</div><div class="line">    if (!isSuperset-&gt;prefix) &#123; return true; &#125;</div><div class="line">    uint32_t shift = 32 - isSuperset-&gt;prefix;</div><div class="line">    return (isSuperset-&gt;bits &gt;&gt; shift) == (isSubset-&gt;bits &gt;&gt; shift);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，主要依靠prefix来判断。</p>
<h4 id="2-与exceptions进行merge"><a href="#2-与exceptions进行merge" class="headerlink" title="2. 与exceptions进行merge"></a>2. 与exceptions进行merge</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"> struct ArrayList_OfPrefix4* allPrefixes = ArrayList_OfPrefix4_new(tempAlloc);</div><div class="line"> for (int i = 0; i &lt; exceptions-&gt;length; i++) &#123;</div><div class="line">     struct Prefix4* pfxToInvert = ArrayList_OfPrefix4_get(exceptions, i);</div><div class="line">     bool add = true;</div><div class="line">     for (int j = 0; j &lt; effectiveLocalPrefixes-&gt;length; j++) &#123;</div><div class="line">         struct Prefix4* localPfx = ArrayList_OfPrefix4_get(effectiveLocalPrefixes, j);</div><div class="line">         if (isSubsetOf4(pfxToInvert, localPfx)) &#123;</div><div class="line">             add = false;</div><div class="line">             break;</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line">     if (add) &#123;</div><div class="line">         struct ArrayList_OfPrefix4* prefixes4 = invertPrefix4(pfxToInvert, tempAlloc);</div><div class="line">         mergePrefixSets4(allPrefixes, prefixes4);</div><div class="line">     &#125;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line">for (int i = allPrefixes-&gt;length - 2; i &gt;= 0; i--) &#123;</div><div class="line">     struct Prefix4* pfx = ArrayList_OfPrefix4_get(allPrefixes, i);</div><div class="line">     struct Prefix4* pfx2 = ArrayList_OfPrefix4_get(allPrefixes, i+1);</div><div class="line">     if (isSubsetOf4(pfx2, pfx)) &#123;</div><div class="line">         ArrayList_OfPrefix4_remove(allPrefixes, i+1);</div><div class="line">         if (i &lt; (allPrefixes-&gt;length - 2)) &#123; i++; &#125;</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>首先将exceptions和effectiveLocalPrefixes中的路由记录依次取出，放入isSubsetOf4函数中进行检测，查看exceptions中的项是否是effectiveLocalPrefixes中项的子集。<br>之后，不再是简单的add操作，而是invertPrefix4和mergePrefixSets4。<br>exception操作，是一个排除型操作，当我们往exception列表中加入一个地址时，其实是往路由表中加入掩码长度小于等于这个exception地址掩码长度的所有非此网段的地址。举个栗子：<br>当我们使用RouteGen_addException(‘193.199.1.1/16’)时，其实是向路由表中加入了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">193.198.0.0/16</div><div class="line">193.196.0.0/15</div><div class="line">193.192.0.0/14</div><div class="line">193.200.0.0/13 </div><div class="line">193.208.0.0/12 </div><div class="line">193.224.0.0/11 </div><div class="line">193.128.0.0/10 </div><div class="line">193.0.0.0/9 </div><div class="line">192.0.0.0/8</div><div class="line">194.0.0.0/7 </div><div class="line">196.0.0.0/6</div><div class="line">200.0.0.0/5 </div><div class="line">208.0.0.0/4 </div><div class="line">224.0.0.0/3 </div><div class="line">128.0.0.0/2</div><div class="line">0.0.0.0/1</div></pre></td></tr></table></figure></p>
<p>现在来查看执行这个排除操作的函数invertPrefix4<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">static struct ArrayList_OfPrefix4* invertPrefix4(struct Prefix4* toInvert, struct Allocator* alloc)</div><div class="line">&#123;</div><div class="line">    struct ArrayList_OfPrefix4* result = ArrayList_OfPrefix4_new(alloc);</div><div class="line">    for (int i = 32 - toInvert-&gt;prefix; i &lt; 32; i++) &#123;</div><div class="line">        struct Prefix4* pfx = Allocator_calloc(alloc, sizeof(struct Prefix4), 1);</div><div class="line">        pfx-&gt;bits = ( toInvert-&gt;bits &amp; ((uint32_t)~0 &lt;&lt; i) ) ^ (1 &lt;&lt; i);</div><div class="line">        pfx-&gt;prefix = 32 - i;</div><div class="line">        ArrayList_OfPrefix4_add(result, pfx);</div><div class="line">    &#125;</div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，这个函数是将exceptions之外的网段加result中，result是一个ArrayList。</p>
<p>接下来，将这个result和之前的allPrefixes进行merge。(其实此时，allPrefixes还是空的）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">static void mergePrefixSets4(struct ArrayList_OfPrefix4* mergeInto,</div><div class="line">                             struct ArrayList_OfPrefix4* prefixes)</div><div class="line">&#123;</div><div class="line">    struct Prefix4* highestPrefix = NULL;</div><div class="line">    for (int j = 0; j &lt; prefixes-&gt;length; j++) &#123;</div><div class="line">        struct Prefix4* result = ArrayList_OfPrefix4_get(prefixes, j);</div><div class="line">        Assert_true(result);</div><div class="line">        if (!highestPrefix || highestPrefix-&gt;prefix &lt; result-&gt;prefix) &#123;</div><div class="line">            highestPrefix = result;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    struct Prefix4 target;</div><div class="line">    Bits_memcpy(&amp;target, highestPrefix, sizeof(struct Prefix4));</div><div class="line">    target.bits ^= (target.prefix) ? (1 &lt;&lt; (32 - target.prefix)) : 0;</div><div class="line">    for (int i = mergeInto-&gt;length - 1; i &gt;= 0; i--) &#123;</div><div class="line">        struct Prefix4* result = ArrayList_OfPrefix4_get(mergeInto, i);</div><div class="line">        Assert_true(result);</div><div class="line">        if (isSubsetOf4(&amp;target, result)) &#123;</div><div class="line">            ArrayList_OfPrefix4_remove(mergeInto, i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for (int i = 0; i &lt; prefixes-&gt;length; i++) &#123;</div><div class="line">        bool include = true;</div><div class="line">        struct Prefix4* toInclude = ArrayList_OfPrefix4_get(prefixes, i);</div><div class="line">        for (int j = 0; j &lt; mergeInto-&gt;length; j++) &#123;</div><div class="line">            struct Prefix4* test = ArrayList_OfPrefix4_get(mergeInto, j);</div><div class="line">            if (isSubsetOf4(test, toInclude)) &#123;</div><div class="line">                include = false;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (include) &#123;</div><div class="line">            ArrayList_OfPrefix4_add(mergeInto, toInclude);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>至此，localPrefixes和exception进行merge之后的网段都加入到了allPrefixes之中。<br>然后在进行一次排除subset的操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">for (int i = allPrefixes-&gt;length - 2; i &gt;= 0; i--) &#123;</div><div class="line">    struct Prefix4* pfx = ArrayList_OfPrefix4_get(allPrefixes, i);</div><div class="line">    struct Prefix4* pfx2 = ArrayList_OfPrefix4_get(allPrefixes, i+1);</div><div class="line">    if (isSubsetOf4(pfx2, pfx)) &#123;</div><div class="line">        ArrayList_OfPrefix4_remove(allPrefixes, i+1);</div><div class="line">        if (i &lt; (allPrefixes-&gt;length - 2)) &#123; i++; &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="3-prefixes与allPrefixes进行merge"><a href="#3-prefixes与allPrefixes进行merge" class="headerlink" title="3. prefixes与allPrefixes进行merge"></a>3. prefixes与allPrefixes进行merge</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">for (int i = 0; i &lt; prefixes-&gt;length; i++) &#123;</div><div class="line">    struct Prefix4* pfx = ArrayList_OfPrefix4_get(prefixes, i);</div><div class="line">    int addPrefix = true;</div><div class="line">    for (int j = allPrefixes-&gt;length - 1; j &gt;= 0; j--) &#123;</div><div class="line">        struct Prefix4* pfx2 = ArrayList_OfPrefix4_get(allPrefixes, j);</div><div class="line">        if (isSubsetOf4(pfx2, pfx)) &#123;</div><div class="line">            addPrefix = false;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if (addPrefix) &#123;</div><div class="line">        ArrayList_OfPrefix4_add(allPrefixes, pfx);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">ArrayList_OfPrefix4_sort(allPrefixes);</div></pre></td></tr></table></figure>
<p>将prefixes加入到allPrefixes，之后还进行了排序。此时，allPrefixes中是localPrefixes,prefixes,exception共同merge后的结果。</p>
<h4 id="4-prefixes和allPrefixes共同生成out"><a href="#4-prefixes和allPrefixes共同生成out" class="headerlink" title="4. prefixes和allPrefixes共同生成out"></a>4. prefixes和allPrefixes共同生成out</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">struct ArrayList_OfPrefix4* out = ArrayList_OfPrefix4_new(alloc);</div><div class="line">for (int i = 0; i &lt; allPrefixes-&gt;length; i++) &#123;</div><div class="line">    struct Prefix4* pfx = ArrayList_OfPrefix4_get(allPrefixes, i);</div><div class="line">    for (int j = 0; j &lt; prefixes-&gt;length; j++) &#123;</div><div class="line">        struct Prefix4* pfx2 = ArrayList_OfPrefix4_get(prefixes, j);</div><div class="line">        if (isSubsetOf4(pfx, pfx2)) &#123;</div><div class="line">            ArrayList_OfPrefix4_add(out, clonePrefix4(pfx, alloc));</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里不太一样的地方在于，是比较两者，然后取子集加入到out当中。也就是说，out最后回得到一个条目更加精细的集合，该集合综合了prefixes,localPrefixes,exception的记录。</p>
<h3 id="2-把prefixes加入到prefixSet之中"><a href="#2-把prefixes加入到prefixSet之中" class="headerlink" title="2. 把prefixes加入到prefixSet之中"></a>2. 把prefixes加入到prefixSet之中</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct Sockaddr** prefixSet =</div><div class="line">        Allocator_calloc(tempAlloc, sizeof(char*), p46-&gt;prefix4-&gt;length + p46-&gt;prefix6-&gt;length);</div><div class="line">    int prefixNum = 0;</div><div class="line">    for (int i = 0; i &lt; p46-&gt;prefix4-&gt;length; i++) &#123;</div><div class="line">        struct Prefix4* pfx4 = ArrayList_OfPrefix4_get(p46-&gt;prefix4, i);</div><div class="line">        prefixSet[prefixNum++] = sockaddrForPrefix4(tempAlloc, pfx4);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>将上一步得到的路由信息转成Sockaddr，然后加入到prefixSet当中。</p>
<h3 id="3-NetDev-setRoutes"><a href="#3-NetDev-setRoutes" class="headerlink" title="3. NetDev_setRoutes"></a>3. NetDev_setRoutes</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">void NetDev_setRoutes(const char* ifName,</div><div class="line">                      struct Sockaddr** prefixSet,</div><div class="line">                      int prefixCount,</div><div class="line">                      struct Log* logger,</div><div class="line">                      struct Allocator* tempAlloc,</div><div class="line">                      struct Except* eh)</div><div class="line">&#123;</div><div class="line">    for (int i = 0; i &lt; prefixCount; i++) &#123;</div><div class="line">        struct Allocator* alloc = Allocator_child(tempAlloc);</div><div class="line">        int addrFam;</div><div class="line">        char* printedAddr;</div><div class="line">        void* addr;</div><div class="line">        checkAddressAndPrefix(prefixSet[i], &amp;addrFam, &amp;printedAddr, &amp;addr, alloc, eh);</div><div class="line">        Allocator_free(alloc);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    NetPlatform_setRoutes(ifName, prefixSet, prefixCount, logger, tempAlloc, eh);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">void NetPlatform_setRoutes(const char* ifName,</div><div class="line">                           struct Sockaddr** prefixSet,</div><div class="line">                           int prefixCount,</div><div class="line">                           struct Log* logger,</div><div class="line">                           struct Allocator* tempAlloc,</div><div class="line">                           struct Except* eh)</div><div class="line">&#123;</div><div class="line">    int ifIndex = ifIndexForName(ifName, eh);</div><div class="line">    struct RouteInfo* newRi = riForSockaddrs(prefixSet, prefixCount, ifIndex, tempAlloc);</div><div class="line">    int sock = mkSocket(tempAlloc, eh);</div><div class="line">    struct RouteInfo* oldRi = getRoutes(sock, ifIndex, tempAlloc, eh);</div><div class="line">    logRis(oldRi, logger, &quot;DELETE ROUTE&quot;);</div><div class="line">    addDeleteRoutes(sock, true, oldRi, tempAlloc, eh);</div><div class="line">    logRis(newRi, logger, &quot;ADD ROUTE&quot;);</div><div class="line">    addDeleteRoutes(sock, false, newRi, tempAlloc, eh);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际设置路由的过程，在/util/platform/netdev/文件夹下，不做详细分析。</p>
<h2 id="RouteGen-admin"><a href="#RouteGen-admin" class="headerlink" title="RouteGen_admin"></a>RouteGen_admin</h2><p>这个admin文件，写的还是跟别的不太一样的，用到了很多的宏来简化重复代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">void RouteGen_admin_register(struct RouteGen* rg, struct Admin* admin, struct Allocator* alloc)</div><div class="line">&#123;</div><div class="line">    struct RouteGen_admin_Ctx* ctx = Allocator_calloc(alloc, sizeof(struct RouteGen_admin_Ctx), 1);</div><div class="line">    ctx-&gt;rg = rg;</div><div class="line">    ctx-&gt;admin = admin;</div><div class="line">    Identity_set(ctx);</div><div class="line"></div><div class="line">    REGISTER_GET_SOMETHING(getPrefixes, ctx, admin);</div><div class="line">    REGISTER_GET_SOMETHING(getLocalPrefixes, ctx, admin);</div><div class="line">    REGISTER_GET_SOMETHING(getExceptions, ctx, admin);</div><div class="line">    REGISTER_GET_SOMETHING(getGeneratedRoutes, ctx, admin);</div><div class="line"></div><div class="line">    REGISTER_ADD_REMOVE_SOMETHING(addException, ctx, admin);</div><div class="line">    REGISTER_ADD_REMOVE_SOMETHING(addPrefix, ctx, admin);</div><div class="line">    REGISTER_ADD_REMOVE_SOMETHING(addLocalPrefix, ctx, admin);</div><div class="line">    REGISTER_ADD_REMOVE_SOMETHING(removePrefix, ctx, admin);</div><div class="line">    REGISTER_ADD_REMOVE_SOMETHING(removeLocalPrefix, ctx, admin);</div><div class="line">    REGISTER_ADD_REMOVE_SOMETHING(removeException, ctx, admin);</div><div class="line"></div><div class="line">    Admin_registerFunction(&quot;RouteGen_commit&quot;, commit, ctx, true,</div><div class="line">        ((struct Admin_FunctionArg[]) &#123;</div><div class="line">            &#123; .name = &quot;tunName&quot;, .required = 1, .type = &quot;String&quot; &#125;,</div><div class="line">        &#125;), admin);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>除了RouteGen_commit直接写了registerfunction方法，其他都使用了宏定义函数。</p>
<h3 id="REGISTER-GET-SOMETHING"><a href="#REGISTER-GET-SOMETHING" class="headerlink" title="REGISTER_GET_SOMETHING"></a>REGISTER_GET_SOMETHING</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#define REGISTER_GET_SOMETHING(_name, ctx, admin) \</div><div class="line">    Admin_registerFunction(&quot;RouteGen_&quot; #_name, _name, ctx, true,                                \</div><div class="line">        ((struct Admin_FunctionArg[]) &#123;                                                         \</div><div class="line">            &#123; .name = &quot;page&quot;, .required = 0, .type = &quot;Int&quot; &#125;,                                   \</div><div class="line">            &#123; .name = &quot;ip6&quot;, .required = 0, .type = &quot;Int&quot; &#125;                                     \</div><div class="line">        &#125;), admin)</div></pre></td></tr></table></figure>
<p>单井号就是将后面的 宏参数 进行字符串操作，就是将后面的参数用双引号引起来。<br>假设name为getGeneratedRoutes，则等同于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Admin_registerFunction(&quot;RouteGen_&quot; &quot;getGeneratedRoutes&quot;, getGeneratedRoutes, ctx, true,                                \</div><div class="line">    ((struct Admin_FunctionArg[]) &#123;                                                         \</div><div class="line">        &#123; .name = &quot;page&quot;, .required = 0, .type = &quot;Int&quot; &#125;,                                   \</div><div class="line">        &#123; .name = &quot;ip6&quot;, .required = 0, .type = &quot;Int&quot; &#125;                                     \</div><div class="line">    &#125;), admin)</div></pre></td></tr></table></figure></p>
<p>这样，RouteGen_getGeneratedRoutes就被register到getGeneratedRoutes函数上。这一类getxxxx的函数，也使用了宏定义函数，看下这类函数的定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#define GET_SOMETHING(name) \</div><div class="line">    static void name(Dict* args, void* vcontext, String* txid, struct Allocator* requestAlloc)  \</div><div class="line">    &#123;                                                                                           \</div><div class="line">        struct RouteGen_admin_Ctx* ctx = Identity_check((struct RouteGen_admin_Ctx*) vcontext); \</div><div class="line">        Dict* genRoutes = RouteGen_ ## name (ctx-&gt;rg, requestAlloc);                            \</div><div class="line">        getSomething(args, ctx, txid, requestAlloc, genRoutes);                                 \</div><div class="line">    &#125;</div><div class="line">GET_SOMETHING(getPrefixes)</div><div class="line">GET_SOMETHING(getLocalPrefixes)</div><div class="line">GET_SOMETHING(getExceptions)</div><div class="line">GET_SOMETHING(getGeneratedRoutes)</div></pre></td></tr></table></figure></p>
<p>依然以getGeneratedRoutes为例，得到一个getGeneratedRoutes函数(宏定义函数中的双井号就是用于连接)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">static void getGeneratedRoutes(Dict* args, void* vcontext, String* txid, struct Allocator* requestAlloc) </div><div class="line">&#123;</div><div class="line">    struct RouteGen_admin_Ctx* ctx = Identity_check((struct RouteGen_admin_Ctx*) vcontext); </div><div class="line">    Dict* genRoutes = RouteGen_getGeneratedRoutes (ctx-&gt;rg, requestAlloc);                            </div><div class="line">    getSomething(args, ctx, txid, requestAlloc, genRoutes);                                 </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里用到了两个函数：</p>
<h4 id="RouteGen-getGeneratedRoutes"><a href="#RouteGen-getGeneratedRoutes" class="headerlink" title="RouteGen_getGeneratedRoutes"></a>RouteGen_getGeneratedRoutes</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Dict* RouteGen_getGeneratedRoutes(struct RouteGen* rg, struct Allocator* alloc)</div><div class="line">&#123;</div><div class="line">    struct RouteGen_pvt* rp = Identity_check((struct RouteGen_pvt*) rg);</div><div class="line">    struct Prefix46* p46 = getGeneratedRoutes(rp, alloc);</div><div class="line">    return getSomething(rp, alloc, p46-&gt;prefix6, p46-&gt;prefix4);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>getGeneratedRoutes(rp, alloc)<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">static struct Prefix46* getGeneratedRoutes(struct RouteGen_pvt* rp, struct Allocator* alloc)</div><div class="line">&#123;</div><div class="line">    struct Prefix46* out = Allocator_calloc(alloc, sizeof(struct Prefix46), 1);</div><div class="line">    if (rp-&gt;prefixes4-&gt;length &gt; 0) &#123;</div><div class="line">        out-&gt;prefix4 = genPrefixes4(rp-&gt;prefixes4, rp-&gt;exceptions4, rp-&gt;localPrefixes4, alloc);</div><div class="line">    &#125; else &#123;</div><div class="line">        out-&gt;prefix4 = ArrayList_OfPrefix4_new(alloc);</div><div class="line">    &#125;</div><div class="line">    if (rp-&gt;prefixes6-&gt;length &gt; 0) &#123;</div><div class="line">        out-&gt;prefix6 = genPrefixes6(rp-&gt;prefixes6, rp-&gt;exceptions6, rp-&gt;localPrefixes6, alloc);</div><div class="line">    &#125; else &#123;</div><div class="line">        out-&gt;prefix6 = ArrayList_OfPrefix6_new(alloc);</div><div class="line">    &#125;</div><div class="line">    return out;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>上面已经做过分析。</p>
<ol>
<li>getSomething(rp, alloc, p46-&gt;prefix6, p46-&gt;prefix4）<br>注意，这个getSomething是RouteGen.c中的私有方法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">static Dict* getSomething(struct RouteGen_pvt* rp,</div><div class="line">                          struct Allocator* alloc,</div><div class="line">                          struct ArrayList_OfPrefix6* list6,</div><div class="line">                          struct ArrayList_OfPrefix4* list4)</div><div class="line">&#123;</div><div class="line">    ArrayList_OfPrefix6_sort(list6);</div><div class="line">    ArrayList_OfPrefix4_sort(list4);</div><div class="line">    List* prefixes4 = List_new(alloc);</div><div class="line">    for (int i = 0; i &lt; list4-&gt;length; i++) &#123;</div><div class="line">        struct Prefix4* pfx4 = ArrayList_OfPrefix4_get(list4, i);</div><div class="line">        List_addString(prefixes4, printPrefix4(alloc, pfx4), alloc);</div><div class="line">    &#125;</div><div class="line">    List* prefixes6 = List_new(alloc);</div><div class="line">    for (int i = 0; i &lt; list6-&gt;length; i++) &#123;</div><div class="line">        struct Prefix6* pfx6 = ArrayList_OfPrefix6_get(list6, i);</div><div class="line">        List_addString(prefixes6, printPrefix6(alloc, pfx6), alloc);</div><div class="line">    &#125;</div><div class="line">    Dict* out = Dict_new(alloc);</div><div class="line">    Dict_putList(out, String_new(&quot;ipv4&quot;, alloc), prefixes4, alloc);</div><div class="line">    Dict_putList(out, String_new(&quot;ipv6&quot;, alloc), prefixes6, alloc);</div><div class="line">    return out;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>out中包括两个Dict，一个记录ipv4，一个记录ipv6</p>
<h4 id="getSomething"><a href="#getSomething" class="headerlink" title="getSomething"></a>getSomething</h4><p>注意，这个getSomething是RouteGen_admin.c中的私有方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">static void getSomething(Dict* args,</div><div class="line">                         struct RouteGen_admin_Ctx* ctx,</div><div class="line">                         String* txid,</div><div class="line">                         struct Allocator* requestAlloc,</div><div class="line">                         Dict* genRoutes)</div><div class="line">&#123;</div><div class="line">    int page = getIntVal(args, String_CONST(&quot;page&quot;));</div><div class="line">    List* routes;</div><div class="line">    if (getIntVal(args, String_CONST(&quot;ip6&quot;))) &#123;</div><div class="line">        routes = Dict_getListC(genRoutes, &quot;ipv6&quot;);</div><div class="line">    &#125; else &#123;</div><div class="line">        routes = Dict_getListC(genRoutes, &quot;ipv4&quot;);</div><div class="line">    &#125;</div><div class="line">    Assert_true(routes);</div><div class="line">    List* outList = List_new(requestAlloc);</div><div class="line">    bool more = false;</div><div class="line">    for (int i = page * ROUTES_PER_PAGE, j = 0; i &lt; List_size(routes) &amp;&amp; j &lt; ROUTES_PER_PAGE; j++) &#123;</div><div class="line">        String* route = List_getString(routes, i);</div><div class="line">        Assert_true(route);</div><div class="line">        List_addString(outList, route, requestAlloc);</div><div class="line">        if (++i &gt;= List_size(routes)) &#123;</div><div class="line">            more = false;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">        more = true;</div><div class="line">    &#125;</div><div class="line">    Dict* out = Dict_new(requestAlloc);</div><div class="line">    if (more) &#123;</div><div class="line">        Dict_putInt(out, String_new(&quot;more&quot;, requestAlloc), 1, requestAlloc);</div><div class="line">    &#125;</div><div class="line">    Dict_putList(out, String_new(&quot;routes&quot;, requestAlloc), outList, requestAlloc);</div><div class="line">    Admin_sendMessage(out, txid, ctx-&gt;admin);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里主要是根据请求中带的是ip6还是ip4来区分需要返回哪一组数据。</p>
<h3 id="REGISTER-ADD-REMOVE-SOMETHING"><a href="#REGISTER-ADD-REMOVE-SOMETHING" class="headerlink" title="REGISTER_ADD_REMOVE_SOMETHING"></a>REGISTER_ADD_REMOVE_SOMETHING</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line">enum addRemoveSomething_What &#123;</div><div class="line">    addRemoveSomething_What_ADD_EXCEPTION,</div><div class="line">    addRemoveSomething_What_RM_EXCEPTION,</div><div class="line">    addRemoveSomething_What_ADD_PREFIX,</div><div class="line">    addRemoveSomething_What_RM_PREFIX,</div><div class="line">    addRemoveSomething_What_ADD_LOCALPREFIX,</div><div class="line">    addRemoveSomething_What_RM_LOCALPREFIX,</div><div class="line">&#125;;</div><div class="line">static void addRemoveSomething(Dict* args,</div><div class="line">                               void* vcontext,</div><div class="line">                               String* txid,</div><div class="line">                               struct Allocator* requestAlloc,</div><div class="line">                               enum addRemoveSomething_What what)</div><div class="line">&#123;</div><div class="line">    struct RouteGen_admin_Ctx* ctx = Identity_check((struct RouteGen_admin_Ctx*) vcontext);</div><div class="line">    String* route = Dict_getStringC(args, &quot;route&quot;);</div><div class="line">    char* error = NULL;</div><div class="line"></div><div class="line">    struct Sockaddr_storage ss;</div><div class="line">    if (route-&gt;len &gt; 63) &#123;</div><div class="line">        error = &quot;parse_failed&quot;;</div><div class="line">    &#125;</div><div class="line">    if (!error) &#123;</div><div class="line">        if (Sockaddr_parse(route-&gt;bytes, &amp;ss)) &#123;</div><div class="line">            error = &quot;parse_failed&quot;;</div><div class="line">        &#125; else &#123;</div><div class="line">            int family = Sockaddr_getFamily(&amp;ss.addr);</div><div class="line">            if (family != Sockaddr_AF_INET &amp;&amp; family != Sockaddr_AF_INET6) &#123;</div><div class="line">                error = &quot;unexpected_af&quot;;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    int retVal = -1;</div><div class="line">    Dict* out = Dict_new(requestAlloc);</div><div class="line">    if (!error) &#123;</div><div class="line">        switch (what) &#123;</div><div class="line">            case addRemoveSomething_What_ADD_EXCEPTION:</div><div class="line">                RouteGen_addException(ctx-&gt;rg, &amp;ss.addr); break;</div><div class="line">            case addRemoveSomething_What_ADD_PREFIX:</div><div class="line">                RouteGen_addPrefix(ctx-&gt;rg, &amp;ss.addr); break;</div><div class="line">            case addRemoveSomething_What_ADD_LOCALPREFIX:</div><div class="line">                RouteGen_addLocalPrefix(ctx-&gt;rg, &amp;ss.addr); break;</div><div class="line">            case addRemoveSomething_What_RM_EXCEPTION:</div><div class="line">                retVal = RouteGen_removeException(ctx-&gt;rg, &amp;ss.addr); break;</div><div class="line">            case addRemoveSomething_What_RM_PREFIX:</div><div class="line">                retVal = RouteGen_removePrefix(ctx-&gt;rg, &amp;ss.addr); break;</div><div class="line">            case addRemoveSomething_What_RM_LOCALPREFIX:</div><div class="line">                retVal = RouteGen_removeLocalPrefix(ctx-&gt;rg, &amp;ss.addr); break;</div><div class="line">            default: Assert_failure(&quot;invalid op&quot;);</div><div class="line">        &#125;</div><div class="line">        if (!retVal) &#123;</div><div class="line">            error = &quot;no_such_route&quot;;</div><div class="line">        &#125; else &#123;</div><div class="line">            error = &quot;none&quot;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    Dict_putString(out,</div><div class="line">                   String_new(&quot;error&quot;, requestAlloc),</div><div class="line">                   String_new(error, requestAlloc),</div><div class="line">                   requestAlloc);</div><div class="line">    Admin_sendMessage(out, txid, ctx-&gt;admin);</div><div class="line">&#125;</div><div class="line"></div><div class="line">#define ADD_REMOVE_SOMETHING(name, op) \</div><div class="line">    static void name(Dict* args, void* vcontext, String* txid, struct Allocator* requestAlloc)  \</div><div class="line">    &#123;                                                                                           \</div><div class="line">        addRemoveSomething(args, vcontext, txid, requestAlloc, op);                             \</div><div class="line">    &#125;</div><div class="line">ADD_REMOVE_SOMETHING(addException, addRemoveSomething_What_ADD_EXCEPTION)</div><div class="line">ADD_REMOVE_SOMETHING(addPrefix, addRemoveSomething_What_ADD_PREFIX)</div><div class="line">ADD_REMOVE_SOMETHING(addLocalPrefix, addRemoveSomething_What_ADD_LOCALPREFIX)</div><div class="line">ADD_REMOVE_SOMETHING(removePrefix, addRemoveSomething_What_RM_PREFIX)</div><div class="line">ADD_REMOVE_SOMETHING(removeLocalPrefix, addRemoveSomething_What_RM_LOCALPREFIX)</div><div class="line">ADD_REMOVE_SOMETHING(removeException, addRemoveSomething_What_RM_EXCEPTION)</div><div class="line">#define REGISTER_ADD_REMOVE_SOMETHING(_name, ctx, admin) \</div><div class="line">    Admin_registerFunction(&quot;RouteGen_&quot; #_name, _name, ctx, true,                                \</div><div class="line">        ((struct Admin_FunctionArg[]) &#123;                                                         \</div><div class="line">            &#123; .name = &quot;route&quot;, .required = 1, .type = &quot;String&quot; &#125;,                               \</div><div class="line">        &#125;), admin)</div></pre></td></tr></table></figure>
<p>相比GET系列，ADD_REMOVE系列简单很多。以RouteGen_addException为例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">static void addSomething(struct RouteGen_pvt* rp,</div><div class="line">                         struct Sockaddr* exempt,</div><div class="line">                         struct ArrayList_OfPrefix6* list6,</div><div class="line">                         struct ArrayList_OfPrefix4* list4)</div><div class="line">&#123;</div><div class="line">    if (Sockaddr_getFamily(exempt) == Sockaddr_AF_INET) &#123;</div><div class="line">        struct Prefix4* p4 = sockaddrToPrefix4(exempt, rp-&gt;alloc);</div><div class="line">        ArrayList_OfPrefix4_add(list4, p4);</div><div class="line">    &#125; else if (Sockaddr_getFamily(exempt) == Sockaddr_AF_INET6) &#123;</div><div class="line">        struct Prefix6* p6 = sockaddrToPrefix6(exempt, rp-&gt;alloc);</div><div class="line">        ArrayList_OfPrefix6_add(list6, p6);</div><div class="line">    &#125; else &#123;</div><div class="line">        Assert_failure(&quot;unexpected addr type&quot;);</div><div class="line">    &#125;</div><div class="line">    rp-&gt;pub.hasUncommittedChanges = true;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void RouteGen_addException(struct RouteGen* rg, struct Sockaddr* destination)</div><div class="line">&#123;</div><div class="line">    struct RouteGen_pvt* rp = Identity_check((struct RouteGen_pvt*) rg);</div><div class="line">    addSomething(rp, destination, rp-&gt;exceptions6, rp-&gt;exceptions4);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>几乎不需要分析。</p>
<h2 id="源码中对这几个ArrayList的操作"><a href="#源码中对这几个ArrayList的操作" class="headerlink" title="源码中对这几个ArrayList的操作"></a>源码中对这几个ArrayList的操作</h2><ol>
<li><p>IpTunnel.c的addAddress中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">bool installRoute = false;</div><div class="line">if (Sockaddr_getFamily(&amp;ss.addr) == Sockaddr_AF_INET) &#123;</div><div class="line">    installRoute = (prefixLen &lt; 32);</div><div class="line">&#125; else if (Sockaddr_getFamily(&amp;ss.addr) == Sockaddr_AF_INET6) &#123;</div><div class="line">    installRoute = (prefixLen &lt; 128);</div><div class="line">&#125; else &#123;</div><div class="line">    Assert_failure(&quot;bad address family&quot;);</div><div class="line">&#125;</div><div class="line">if (installRoute) &#123;</div><div class="line">    RouteGen_addPrefix(ctx-&gt;rg, &amp;ss.addr);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>RouteGen_new中调用setupDefaultLocalPrefixes</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">static void setupDefaultLocalPrefixes(struct RouteGen_pvt* rp)</div><div class="line">&#123;</div><div class="line">    struct Sockaddr_storage ss;</div><div class="line">    #define ADD_PREFIX(str) \</div><div class="line">        Assert_true(!Sockaddr_parse(str, &amp;ss));       \</div><div class="line">        RouteGen_addLocalPrefix(&amp;rp-&gt;pub, &amp;ss.addr)</div><div class="line"></div><div class="line">    ADD_PREFIX(&quot;fe80::/10&quot;);</div><div class="line">    ADD_PREFIX(&quot;fd00::/8&quot;);</div><div class="line"></div><div class="line">    ADD_PREFIX(&quot;10.0.0.0/8&quot;);</div><div class="line">    ADD_PREFIX(&quot;172.16.0.0/12&quot;);</div><div class="line">    ADD_PREFIX(&quot;192.168.0.0/16&quot;);</div><div class="line">    ADD_PREFIX(&quot;127.0.0.0/8&quot;);</div><div class="line"></div><div class="line">    #undef ADD_PREFIX</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Configurator.c中设置exception<br>解析conf文件中关于设置inbound的配置。配置中包括inbound的ipv4地址，调用’RouteGen_addException’，将这个地址添加到exception当中。<br>conf文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&quot;connectTo&quot;:&#123;</div><div class="line">	&quot;106.75.59.53:50001&quot;:&#123;</div><div class="line">    	&quot;password&quot;:&quot;XRuMWpgvNienefc7ZT8gXTuTCvSWWSA&quot;,</div><div class="line">    	&quot;publicKey&quot;:&quot;nsn1nz93lztkg6zbw4yqnr6zlzxhchppzdkduwh9wh79p88fwx60.k&quot;</div><div class="line">    &#125;</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
</li>
</ol>
<p>Configurator.c中对conf的解析操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">Dict* connectTo = Dict_getDictC(udp, &quot;connectTo&quot;);</div><div class="line">if (connectTo) &#123;</div><div class="line">    struct Dict_Entry* entry = *connectTo;</div><div class="line">    struct Allocator* perCallAlloc = Allocator_child(ctx-&gt;alloc);</div><div class="line">    while (entry != NULL) &#123;</div><div class="line">        String* key = (String*) entry-&gt;key;</div><div class="line">        if (entry-&gt;val-&gt;type != Object_DICT) &#123;</div><div class="line">            Log_critical(ctx-&gt;logger, &quot;interfaces.UDPInterface.connectTo: entry [%s] &quot;</div><div class="line">                                       &quot;is not a dictionary type.&quot;, key-&gt;bytes);</div><div class="line">            exit(-1);</div><div class="line">        &#125;</div><div class="line">        Dict* value = entry-&gt;val-&gt;as.dictionary;</div><div class="line">        Log_keys(ctx-&gt;logger, &quot;Attempting to connect to node [%s].&quot;, key-&gt;bytes);</div><div class="line">        key = String_clone(key, perCallAlloc);</div><div class="line">        char* lastColon = CString_strrchr(key-&gt;bytes, &apos;:&apos;);</div><div class="line"></div><div class="line">        if (lastColon) &#123;</div><div class="line">            if (!Sockaddr_parse(key-&gt;bytes, NULL)) &#123;</div><div class="line">                // it&apos;s a sockaddr, fall through</div><div class="line">            &#125; else &#123;</div><div class="line">                // try it as a hostname.</div><div class="line">                Log_critical(ctx-&gt;logger, &quot;Couldn&apos;t add connection [%s], &quot;</div><div class="line">                                            &quot;hostnames aren&apos;t supported.&quot;, key-&gt;bytes);</div><div class="line">                exit(-1);</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            // it doesn&apos;t have a port</div><div class="line">            Log_critical(ctx-&gt;logger, &quot;Connection [%s] must be $IP:$PORT, or &quot;</div><div class="line">                                        &quot;[$IP]:$PORT for IPv6.&quot;, key-&gt;bytes);</div><div class="line">            exit(-1);</div><div class="line">        &#125;</div><div class="line">        Dict_putIntC(value, &quot;interfaceNumber&quot;, ifNum, perCallAlloc);</div><div class="line">        Dict_putStringC(value, &quot;address&quot;, key, perCallAlloc);</div><div class="line">        rpcCall(String_CONST(&quot;UDPInterface_beginConnection&quot;), value, ctx, perCallAlloc);</div><div class="line"></div><div class="line">        // Make a IPTunnel exception for this node</div><div class="line">        Dict* aed = Dict_new(perCallAlloc);</div><div class="line">        *lastColon = &apos;\0&apos;;</div><div class="line">        Dict_putStringC(aed, &quot;route&quot;, String_new(key-&gt;bytes, perCallAlloc),</div><div class="line">            perCallAlloc);</div><div class="line">        *lastColon = &apos;:&apos;;</div><div class="line">        rpcCall(String_CONST(&quot;RouteGen_addException&quot;), aed, ctx, perCallAlloc);</div><div class="line"></div><div class="line">        entry = entry-&gt;next;</div><div class="line">    &#125;</div><div class="line">    Allocator_free(perCallAlloc);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/08/02/cjdns_RouteGen-d/" data-id="cje6pjw1e002fweyx1bar6o99" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C/">C/C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cjdns/">cjdns</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cjdns源码分析/">cjdns源码分析</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-cjdns_IpTunnel" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/25/cjdns_IpTunnel/" class="article-date">
  <time datetime="2017-07-25T01:48:00.000Z" itemprop="datePublished">2017-07-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/cjdns-cjdns源码分析/">cjdns - cjdns源码分析</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/25/cjdns_IpTunnel/">cjdns源码分析--IpTunnel</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>首先看一下IpTunnel的结构体定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">struct IpTunnel</div><div class="line">&#123;</div><div class="line">    /** The interface used to send and receive messages to the TUN device. */</div><div class="line">    struct Iface tunInterface;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * The interface used to send and receive messages to other nodes.</div><div class="line">     * All messages sent on this interface shall be preceeded with the RouterHeader and DataHeader.</div><div class="line">     */</div><div class="line">    struct Iface nodeInterface;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * The list of registered connections, do not modify manually.</div><div class="line">     * Will be reorganized from time to time so pointers are ephemeral.</div><div class="line">     */</div><div class="line">    struct &#123;</div><div class="line">        uint32_t count;</div><div class="line">        struct IpTunnel_Connection* connections;</div><div class="line">    &#125; connectionList;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>两个Iface，一个负责跟tun设备沟通，一个负责跟其他node沟通<br>一个connectionList，保存现有的所有connection。</p>
<p>然后看一下IpTunnel_Connection的结构体定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">struct IpTunnel_Connection</div><div class="line">&#123;</div><div class="line">    /** The header for routing to this node. */</div><div class="line">    struct RouteHeader routeHeader;</div><div class="line"></div><div class="line">    /** The IPv6 address used for this connection or all zeros if none was assigned. */</div><div class="line">    uint8_t connectionIp6[16];</div><div class="line"></div><div class="line">    /** The IPv4 address used for this connection or all zeros if none was assigned. */</div><div class="line">    uint8_t connectionIp4[4];</div><div class="line"></div><div class="line">    /** The IPv6 netmask/prefix length, in bits. Defaults to 128 if none was assigned. */</div><div class="line">    uint8_t connectionIp6Prefix;</div><div class="line"></div><div class="line">    /** The IPv6 prefix length in, in bits, defining netmask. 0xff if not used. */</div><div class="line">    uint8_t connectionIp6Alloc;</div><div class="line"></div><div class="line">    /** The IPv4 address prefix length, in bits. Defaults to 32 if none was assigned. */</div><div class="line">    uint8_t connectionIp4Prefix;</div><div class="line"></div><div class="line">    /** The IPv6 prefix length in, in bits, defining netmask. 0xff if not used. */</div><div class="line">    uint8_t connectionIp4Alloc;</div><div class="line"></div><div class="line">    /** non-zero if the connection was made using IpTunnel_connectTo(). */</div><div class="line">    int isOutgoing : 1;</div><div class="line"></div><div class="line">    /** The number of the connection so it can be identified when removing. */</div><div class="line">    int number : 31;</div><div class="line"></div><div class="line">    bool reachable;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p> 这个结构体记录的是当前点与其他node的连接信息。对于普通的点来说，这里保存着与离岸点的连接信息。每个在conf中定义的离岸点（outgoingConnections），对应着这里的一个IpTunnel_Connection对象，且该对象的isOutgoing字段为1，表明这是一个与离岸点的连接。对于离岸点来说，这里保存着所有连接到该离岸点的连接信息。每个在conf中定义的允许连接的点（allowedConnections），对应着这里的一个IpTunnel_Connection对象，且该对向的isOutgoing字段为0，表明这不是一个向离岸点的连接。</p>
<p>结构体中还有六个与ip相关的字段，3个ip4，3个ipv6，根据需要，使用其中3个。这些ip字段，记录着该连接中，非离岸点的ip信息。</p>
<p>结构体中的routeHeader字段，记录着去往对方的路由信息。</p>
<h3 id="conf文件起到的作用"><a href="#conf文件起到的作用" class="headerlink" title="conf文件起到的作用"></a>conf文件起到的作用</h3><p>有两种途径来新建一个IpTunnel_Connection。</p>
<ol>
<li><p>作为普通点，建立一个与离岸点的IpTunnel_Connection<br>对应着conf文件中的outgoingConnections配置，调用到IpTunnel_admin中的connectTo方法，继而调用到IpTunnel中的IpTunnel_connectTo方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&quot;outgoingConnections&quot;:[</div><div class="line">	&quot;wfzyzrc0q4g83y0dgzxx1l862u0lscucj75yw9q1ymbltzwh2fq0.k&quot;</div><div class="line">]</div></pre></td></tr></table></figure>
</li>
<li><p>作为离岸点，为每个允许连接过来的普通点建立一个IpTunnel_Connection，对应着conf文件中的allowedConnections配置，调用到IpTunnel_admin中的allowConnection方法，继而调用到IpTunnel中的IpTunnel_allowConnection方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&quot;allowedConnections&quot;: [</div><div class="line">        &#123;</div><div class="line">            &quot;ip4Address&quot;: &quot;192.168.254.2&quot;,</div><div class="line">            &quot;ip4Prefix&quot;: 0,</div><div class="line">            &quot;ip4Alloc&quot;: 32,</div><div class="line">            &quot;publicKey&quot;: &quot;uhmhts49tdm1ryb3q0pw95291uwt4xgvyk5s84vt2z2mnv3zp230.k&quot;</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            &quot;ip4Address&quot;: &quot;192.168.254.3&quot;,</div><div class="line">            &quot;ip4Prefix&quot;: 0,</div><div class="line">            &quot;ip4Alloc&quot;: 32,</div><div class="line">            &quot;publicKey&quot;: &quot;9c3x7hp181dv91tfkbngyhhu2uc3xhxuuh539l3g0gdjgjg1bs10.k&quot;</div><div class="line">        &#125;</div><div class="line">]</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="普通点建立一个离岸点的IpTunnel-Connection"><a href="#普通点建立一个离岸点的IpTunnel-Connection" class="headerlink" title="普通点建立一个离岸点的IpTunnel_Connection"></a>普通点建立一个离岸点的IpTunnel_Connection</h3><h4 id="conf文件配置"><a href="#conf文件配置" class="headerlink" title="conf文件配置"></a>conf文件配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&quot;outgoingConnections&quot;:[</div><div class="line">	&quot;wfzyzrc0q4g83y0dgzxx1l862u0lscucj75yw9q1ymbltzwh2fq0.k&quot;</div><div class="line">]</div></pre></td></tr></table></figure>
<h4 id="读取配置文件"><a href="#读取配置文件" class="headerlink" title="读取配置文件"></a>读取配置文件</h4><p>Configurator.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">List* outgoing = Dict_getListC(ifaceConf, &quot;outgoingConnections&quot;);</div><div class="line">if (outgoing) &#123;</div><div class="line">    String* s;</div><div class="line">    for (int i = 0; (s = List_getString(outgoing, i)) != NULL; i++) &#123;</div><div class="line">        Log_debug(ctx-&gt;logger, &quot;Initiating IpTunnel connection to [%s]&quot;, s-&gt;bytes);</div><div class="line">        Dict requestDict =</div><div class="line">            Dict_CONST(String_CONST(&quot;publicKeyOfNodeToConnectTo&quot;), String_OBJ(s), NULL);</div><div class="line">        Dict* resp = NULL;</div><div class="line">        rpcCall0(String_CONST(&quot;IpTunnel_connectTo&quot;), &amp;requestDict, ctx, tempAlloc, &amp;resp, true);</div><div class="line">        int64_t* num = Dict_getIntC(resp, &quot;connection&quot;);</div><div class="line">        Log_debug(ctx-&gt;logger,&quot;noti outgoing callback %d&quot;,(int)*num);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>读取配置文件中outgoingConnections中的离岸点pubkey信息，rpcall调用IpTunnel_connectTo方法。</p>
<h4 id="IpTunnel-connectTo方法"><a href="#IpTunnel-connectTo方法" class="headerlink" title="IpTunnel_connectTo方法"></a>IpTunnel_connectTo方法</h4><p>IpTunnel_admin.c<br>该方法在文件中注册为connectTo函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">static void connectTo(Dict* args, void* vcontext, String* txid, struct Allocator* requestAlloc)</div><div class="line">&#123;</div><div class="line">    struct Context* context = vcontext;</div><div class="line">    String* publicKeyOfNodeToConnectTo =</div><div class="line">        Dict_getStringC(args, &quot;publicKeyOfNodeToConnectTo&quot;);</div><div class="line"></div><div class="line">    uint8_t pubKey[32];</div><div class="line">    uint8_t ip6[16];</div><div class="line">    int ret;</div><div class="line">    if ((ret = Key_parse(publicKeyOfNodeToConnectTo, pubKey, ip6)) != 0) &#123;</div><div class="line">        sendError(Key_parse_strerror(ret), txid, context-&gt;admin);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    int conn = IpTunnel_connectTo(pubKey, context-&gt;ipTun);</div><div class="line">    sendResponse(conn, txid, context-&gt;admin);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>解析离岸点的pubkey，验证其合法性，调用IpTunnel_connectTo方法，建立IpTunnel_Connection。</p>
<h4 id="IpTunnel-connectTo方法-1"><a href="#IpTunnel-connectTo方法-1" class="headerlink" title="IpTunnel_connectTo方法"></a>IpTunnel_connectTo方法</h4><p>IpTunnel.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">int IpTunnel_connectTo(uint8_t publicKeyOfNodeToConnectTo[32], struct IpTunnel* tunnel)</div><div class="line">&#123;</div><div class="line">    struct IpTunnel_pvt* context = Identity_check((struct IpTunnel_pvt*)tunnel);</div><div class="line">    Log_debug(context-&gt;logger, &quot;noti outgoing call by IpTunnel_connectTo&quot;);</div><div class="line">    struct IpTunnel_Connection* conn = newConnection(true, context);</div><div class="line">    Bits_memcpy(conn-&gt;routeHeader.publicKey, publicKeyOfNodeToConnectTo, 32);</div><div class="line">    AddressCalc_addressForPublicKey(conn-&gt;routeHeader.ip6, publicKeyOfNodeToConnectTo);</div><div class="line"></div><div class="line">    if (Defined(Log_DEBUG)) &#123;</div><div class="line">        uint8_t addr[40];</div><div class="line">        AddrTools_printIp(addr, conn-&gt;routeHeader.ip6);</div><div class="line">        Log_debug(context-&gt;logger, &quot;Trying to connect to [%s]&quot;, addr);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    requestAddresses(conn, context);</div><div class="line">    return conn-&gt;number;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里主要有两个操作：</p>
<ol>
<li>调用newConnection(true, context)创建一个IpTunnel_Connection类型的conn，并将conf配置中的离岸点pubkey赋值给conn-&gt;routeHeader.publicKey。</li>
<li>调用requestAddresses方法，向离岸点申请ipv4地址。</li>
</ol>
<h4 id="创建一个IpTunnel-Connection类型的conn"><a href="#创建一个IpTunnel-Connection类型的conn" class="headerlink" title="创建一个IpTunnel_Connection类型的conn"></a>创建一个IpTunnel_Connection类型的conn</h4><p>调用newConnection方法。<br>IpTunnel.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">static struct IpTunnel_Connection* newConnection(bool isOutgoing, struct IpTunnel_pvt* context)</div><div class="line">&#123;</div><div class="line">    if (context-&gt;pub.connectionList.count == context-&gt;connectionCapacity) &#123;</div><div class="line">        uint32_t newSize = (context-&gt;connectionCapacity + 4) * sizeof(struct IpTunnel_Connection);</div><div class="line">        context-&gt;pub.connectionList.connections =</div><div class="line">            Allocator_realloc(context-&gt;allocator, context-&gt;pub.connectionList.connections, newSize);</div><div class="line">        context-&gt;connectionCapacity += 4;</div><div class="line">    &#125;</div><div class="line">    struct IpTunnel_Connection* conn =</div><div class="line">        &amp;context-&gt;pub.connectionList.connections[context-&gt;pub.connectionList.count];</div><div class="line"></div><div class="line">    // If it&apos;s an incoming connection, it must be lower on the list than any outgoing connections.</div><div class="line">    if (!isOutgoing) &#123;</div><div class="line">        for (int i = (int)context-&gt;pub.connectionList.count - 1; i &gt;= 0; i--) &#123;</div><div class="line">            if (!context-&gt;pub.connectionList.connections[i].isOutgoing</div><div class="line">                &amp;&amp; conn != &amp;context-&gt;pub.connectionList.connections[i + 1])</div><div class="line">            &#123;</div><div class="line">                Bits_memcpy(conn,</div><div class="line">                                 &amp;context-&gt;pub.connectionList.connections[i + 1],</div><div class="line">                                 sizeof(struct IpTunnel_Connection));</div><div class="line">                conn = &amp;context-&gt;pub.connectionList.connections[i + 1];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    context-&gt;pub.connectionList.count++;</div><div class="line"></div><div class="line">    Bits_memset(conn, 0, sizeof(struct IpTunnel_Connection));</div><div class="line">    conn-&gt;number = context-&gt;nextConnectionNumber++;</div><div class="line">    conn-&gt;isOutgoing = isOutgoing;</div><div class="line">    conn-&gt;reachable = false;</div><div class="line"></div><div class="line">    // if there are 2 billion calls, die.</div><div class="line">    Assert_true(context-&gt;nextConnectionNumber &lt; (UINT32_MAX &gt;&gt; 1));</div><div class="line"></div><div class="line">    return conn;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第一个参数指定了是否为离岸点，其他部分没什么特别，普通的赋值操作。</p>
<h4 id="向离岸点申请ipv4地址"><a href="#向离岸点申请ipv4地址" class="headerlink" title="向离岸点申请ipv4地址"></a>向离岸点申请ipv4地址</h4><p>调用requestAddresses方法<br>IpTunnel.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">static void requestAddresses(struct IpTunnel_Connection* conn, struct IpTunnel_pvt* context)</div><div class="line">&#123;</div><div class="line">    if (Defined(Log_DEBUG)) &#123;</div><div class="line">        uint8_t addr[40];</div><div class="line">        AddrTools_printIp(addr, conn-&gt;routeHeader.ip6);</div><div class="line">        Log_debug(context-&gt;logger, &quot;Requesting addresses from [%s] for connection [%d]&quot;,</div><div class="line">                  addr, conn-&gt;number);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    int number = conn-&gt;number;</div><div class="line">    Dict d = Dict_CONST(</div><div class="line">        String_CONST(&quot;q&quot;), String_OBJ(String_CONST(&quot;IpTunnel_getAddresses&quot;)), Dict_CONST(</div><div class="line">        String_CONST(&quot;txid&quot;), String_OBJ((&amp;(String)&#123; .len = 4, .bytes = (char*)&amp;number &#125;)),</div><div class="line">        NULL</div><div class="line">    ));</div><div class="line">    struct Allocator* msgAlloc = Allocator_child(context-&gt;allocator);</div><div class="line">    sendControlMessage(&amp;d, conn, msgAlloc, context);</div><div class="line">    Allocator_free(msgAlloc);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Dict中放入key为q，value为IpTunnel_getAddresses的键值对，调用sendControlMessage方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">static void sendControlMessage(Dict* dict,</div><div class="line">                               struct IpTunnel_Connection* connection,</div><div class="line">                               struct Allocator* requestAlloc,</div><div class="line">                               struct IpTunnel_pvt* context)</div><div class="line">&#123;</div><div class="line">    struct Message* msg = Message_new(0, 1024, requestAlloc);</div><div class="line">    BencMessageWriter_write(dict, msg, NULL);</div><div class="line"></div><div class="line">    int length = msg-&gt;length;</div><div class="line"></div><div class="line">    // do UDP header.</div><div class="line">    Message_shift(msg, Headers_UDPHeader_SIZE, NULL);</div><div class="line">    struct Headers_UDPHeader* uh = (struct Headers_UDPHeader*) msg-&gt;bytes;</div><div class="line">    uh-&gt;srcPort_be = 0;</div><div class="line">    uh-&gt;destPort_be = 0;</div><div class="line">    uh-&gt;length_be = Endian_hostToBigEndian16(length);</div><div class="line">    uh-&gt;checksum_be = 0;</div><div class="line"></div><div class="line">    uint16_t payloadLength = msg-&gt;length;</div><div class="line"></div><div class="line">    Message_shift(msg, Headers_IP6Header_SIZE, NULL);</div><div class="line">    struct Headers_IP6Header* header = (struct Headers_IP6Header*) msg-&gt;bytes;</div><div class="line">    header-&gt;versionClassAndFlowLabel = 0;</div><div class="line">    header-&gt;flowLabelLow_be = 0;</div><div class="line">    header-&gt;nextHeader = 17;</div><div class="line">    header-&gt;hopLimit = 0;</div><div class="line">    header-&gt;payloadLength_be = Endian_hostToBigEndian16(payloadLength);</div><div class="line">    Headers_setIpVersion(header);</div><div class="line"></div><div class="line">    // zero the source and dest addresses.</div><div class="line">    Bits_memset(header-&gt;sourceAddr, 0, 32);</div><div class="line"></div><div class="line">    uh-&gt;checksum_be = Checksum_udpIp6(header-&gt;sourceAddr,</div><div class="line">                                      (uint8_t*) uh,</div><div class="line">                                      msg-&gt;length - Headers_IP6Header_SIZE);</div><div class="line"></div><div class="line">    Iface_CALL(sendToNode, msg, connection, context);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一些初始化操作，然后Iface_CALL调用sendToNode方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">static Iface_DEFUN sendToNode(struct Message* message,</div><div class="line">                              struct IpTunnel_Connection* connection,</div><div class="line">                              struct IpTunnel_pvt* context)</div><div class="line">&#123;</div><div class="line">    Message_push(message, NULL, DataHeader_SIZE, NULL);</div><div class="line">    struct DataHeader* dh = (struct DataHeader*) message-&gt;bytes;</div><div class="line">    DataHeader_setContentType(dh, ContentType_IPTUN);</div><div class="line">    DataHeader_setVersion(dh, DataHeader_CURRENT_VERSION);</div><div class="line">    Message_push(message, &amp;connection-&gt;routeHeader, RouteHeader_SIZE, NULL);</div><div class="line">    return Iface_next(&amp;context-&gt;pub.nodeInterface, message);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>设置了ContentType和Version，调用Message_push方法调整消息内容。最后调用 Iface_next(&amp;context-&gt;pub.nodeInterface, message)方法，将消息发出去。<br>此处的context-&gt;pub.nodeInterface是一个Iface，它的回调函数在IpTunnel_new方法中，被设为incomingFromNode。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">      .pub = &#123;</div><div class="line">..........</div><div class="line">          .nodeInterface = &#123; .send = incomingFromNode &#125;</div><div class="line">      &#125;,</div></pre></td></tr></table></figure></p>
<p>它的connectedIf在Core.c的Core_init方法中通过Iface_plumb方法与nc-&gt;upper-&gt;ipTunnelIf绑定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Iface_plumb(&amp;nc-&gt;upper-&gt;ipTunnelIf, &amp;ipTunnel-&gt;nodeInterface);</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">static inline void Iface_plumb(struct Iface* a, struct Iface* b)</div><div class="line">&#123;</div><div class="line">    Assert_true(!a-&gt;connectedIf);</div><div class="line">    Assert_true(!b-&gt;connectedIf);</div><div class="line">    a-&gt;connectedIf = b;</div><div class="line">    b-&gt;connectedIf = a;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="收到离岸点分配的ipv4地址"><a href="#收到离岸点分配的ipv4地址" class="headerlink" title="收到离岸点分配的ipv4地址"></a>收到离岸点分配的ipv4地址</h4><p>上面讲到，回调函数被设为incomingFromNode，所以，所有从其他点发送过来，进入IpTunnel的数据，都先到incomingFromNode方法中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">static Iface_DEFUN incomingFromNode(struct Message* message, struct Iface* nodeIf)</div><div class="line">&#123;</div><div class="line">    struct IpTunnel_pvt* context =</div><div class="line">        Identity_containerOf(nodeIf, struct IpTunnel_pvt, pub.nodeInterface);</div><div class="line"></div><div class="line">    //Log_debug(context-&gt;logger, &quot;Got incoming message&quot;);</div><div class="line"></div><div class="line">    Assert_true(message-&gt;length &gt;= RouteHeader_SIZE + DataHeader_SIZE);</div><div class="line">    struct RouteHeader* rh = (struct RouteHeader*) message-&gt;bytes;</div><div class="line">    struct DataHeader* dh = (struct DataHeader*) &amp;rh[1];</div><div class="line">    Assert_true(DataHeader_getContentType(dh) == ContentType_IPTUN);</div><div class="line">    struct IpTunnel_Connection* conn = connectionByPubKey(rh-&gt;publicKey, context);</div><div class="line">    if (!conn) &#123;</div><div class="line">        if (Defined(Log_DEBUG)) &#123;</div><div class="line">            uint8_t addr[40];</div><div class="line">            AddrTools_printIp(addr, rh-&gt;ip6);</div><div class="line">            Log_debug(context-&gt;logger, &quot;Got message from unrecognized node [%s]&quot;, addr);</div><div class="line">        &#125;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Message_shift(message, -(RouteHeader_SIZE + DataHeader_SIZE), NULL);</div><div class="line"></div><div class="line">    if (message-&gt;length &gt; 40 &amp;&amp; Headers_getIpVersion(message-&gt;bytes) == 6) &#123;</div><div class="line">        return ip6FromNode(message, conn, context);</div><div class="line">    &#125;</div><div class="line">    if (message-&gt;length &gt; 20 &amp;&amp; Headers_getIpVersion(message-&gt;bytes) == 4) &#123;</div><div class="line">        return ip4FromNode(message, conn, context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (Defined(Log_DEBUG)) &#123;</div><div class="line">        uint8_t addr[40];</div><div class="line">        AddrTools_printIp(addr, rh-&gt;ip6);</div><div class="line">        Log_debug(context-&gt;logger,</div><div class="line">                  &quot;Got message of unknown type, length: [%d], IP version [%d] from [%s]&quot;,</div><div class="line">                  message-&gt;length,</div><div class="line">                  (message-&gt;length &gt; 1) ? Headers_getIpVersion(message-&gt;bytes) : 0,</div><div class="line">                  addr);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li><p>通过publicKey找到对应的conn，也就是离岸点的conn。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">struct IpTunnel_Connection* conn = connectionByPubKey(rh-&gt;publicKey, context);</div></pre></td></tr></table></figure>
</li>
<li><p>调用ip6FromNode</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (message-&gt;length &gt; 40 &amp;&amp; Headers_getIpVersion(message-&gt;bytes) == 6) &#123;</div><div class="line">    return ip6FromNode(message, conn, context);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">static Iface_DEFUN ip6FromNode(struct Message* message,</div><div class="line">                               struct IpTunnel_Connection* conn,</div><div class="line">                               struct IpTunnel_pvt* context)</div><div class="line">&#123;</div><div class="line">    struct Headers_IP6Header* header = (struct Headers_IP6Header*) message-&gt;bytes;</div><div class="line">    if (Bits_isZero(header-&gt;sourceAddr, 16) || Bits_isZero(header-&gt;destinationAddr, 16)) &#123;</div><div class="line">        if (Bits_isZero(header-&gt;sourceAddr, 32)) &#123;</div><div class="line">            return incomingControlMessage(message, conn, context);</div><div class="line">        &#125;</div><div class="line">        ......</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    if (!isValidAddress6(header-&gt;sourceAddr, false, conn)) &#123;</div><div class="line">        ......</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">    return Iface_next(&amp;context-&gt;pub.tunInterface, message);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此时header-&gt;sourceAddr为全0，会调用到incomingControlMessage方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">static Iface_DEFUN incomingControlMessage(struct Message* message,</div><div class="line">                                          struct IpTunnel_Connection* conn,</div><div class="line">                                          struct IpTunnel_pvt* context)</div><div class="line">&#123;</div><div class="line">    ......</div><div class="line"></div><div class="line">    struct Allocator* alloc = Allocator_child(message-&gt;alloc);</div><div class="line"></div><div class="line">    Dict* d = NULL;</div><div class="line"></div><div class="line">    if (Dict_getDictC(d, &quot;addresses&quot;)) &#123;</div><div class="line">        return incomingAddresses(d, conn, alloc, context);</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用到incomingAddresses</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">static Iface_DEFUN incomingAddresses(Dict* d,</div><div class="line">                                     struct IpTunnel_Connection* conn,</div><div class="line">                                     struct Allocator* alloc,</div><div class="line">                                     struct IpTunnel_pvt* context)</div><div class="line">&#123;</div><div class="line">      //一些数据合法性判断</div><div class="line"></div><div class="line">    Dict* addresses = Dict_getDictC(d, &quot;addresses&quot;);</div><div class="line"></div><div class="line">    String* ip4 = Dict_getStringC(addresses, &quot;ip4&quot;);</div><div class="line">    int64_t* ip4Prefix = Dict_getIntC(addresses, &quot;ip4Prefix&quot;);</div><div class="line">    int64_t* ip4Alloc = Dict_getIntC(addresses, &quot;ip4Alloc&quot;);</div><div class="line"></div><div class="line">    if (ip4 &amp;&amp; ip4-&gt;len == 4) &#123;</div><div class="line">        Bits_memcpy(conn-&gt;connectionIp4, ip4-&gt;bytes, 4);</div><div class="line"></div><div class="line">        if (ip4Prefix &amp;&amp; *ip4Prefix &gt;= 0 &amp;&amp; *ip4Prefix &lt;= 32) &#123;</div><div class="line">            conn-&gt;connectionIp4Prefix = (uint8_t) *ip4Prefix;</div><div class="line">        &#125; else &#123;</div><div class="line">            conn-&gt;connectionIp4Prefix = 32;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (ip4Alloc &amp;&amp; *ip4Alloc &gt;= 0 &amp;&amp; *ip4Alloc &lt;= 32) &#123;</div><div class="line">            conn-&gt;connectionIp4Alloc = (uint8_t) *ip4Alloc;</div><div class="line">        &#125; else &#123;</div><div class="line">            conn-&gt;connectionIp4Alloc = 32;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        struct Sockaddr* sa = Sockaddr_clone(Sockaddr_LOOPBACK, alloc);</div><div class="line">        uint8_t* addrBytes = NULL;</div><div class="line">        Sockaddr_getAddress(sa, &amp;addrBytes);</div><div class="line">        Bits_memcpy(addrBytes, ip4-&gt;bytes, 4);</div><div class="line">        char* printedAddr = Sockaddr_print(sa, alloc);</div><div class="line"></div><div class="line">        Log_info(context-&gt;logger, &quot;Got issued address [%s/%d:%d] for connection [%d]&quot;,</div><div class="line">                 printedAddr, conn-&gt;connectionIp4Alloc, conn-&gt;connectionIp4Prefix, conn-&gt;number);</div><div class="line"></div><div class="line">        addAddress(printedAddr, conn-&gt;connectionIp4Prefix, conn-&gt;connectionIp4Alloc, context);</div><div class="line">        Notification_doNotify_af(context-&gt;notification,</div><div class="line">                OUTGOING_REACHABLE,REACHABLE,Ethernet_TYPE_IP4);</div><div class="line">        conn-&gt;reachable = true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //与ipv4类似的，ipv6的处理。不做具体分析。</div><div class="line">    </div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从消息中取出ipv4相关的三个字段，这是离岸点分配给当前点的ipv4地址相关信息。设置conn中相关字段的内容。然后调用addAddress方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">static void addAddress(char* printedAddr, uint8_t prefixLen,</div><div class="line">                       uint8_t allocSize, struct IpTunnel_pvt* ctx)</div><div class="line">&#123;</div><div class="line">    struct Sockaddr_storage ss;</div><div class="line">    if (Sockaddr_parse(printedAddr, &amp;ss)) &#123;</div><div class="line">        Log_error(ctx-&gt;logger, &quot;Invalid ip, setting ip address on TUN&quot;);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    ss.addr.flags |= Sockaddr_flags_PREFIX;</div><div class="line">    ss.addr.prefix = prefixLen;</div><div class="line"></div><div class="line">    bool installRoute = false;</div><div class="line">    if (Sockaddr_getFamily(&amp;ss.addr) == Sockaddr_AF_INET) &#123;</div><div class="line">        installRoute = (prefixLen &lt; 32);</div><div class="line">    &#125; else if (Sockaddr_getFamily(&amp;ss.addr) == Sockaddr_AF_INET6) &#123;</div><div class="line">        installRoute = (prefixLen &lt; 128);</div><div class="line">    &#125; else &#123;</div><div class="line">        Assert_failure(&quot;bad address family&quot;);</div><div class="line">    &#125;</div><div class="line">    if (installRoute) &#123;</div><div class="line">        RouteGen_addPrefix(ctx-&gt;rg, &amp;ss.addr);</div><div class="line">    &#125;</div><div class="line">    if (!ctx-&gt;ifName) &#123;</div><div class="line">        Log_error(ctx-&gt;logger, &quot;Failed to set IP address because TUN interface is not setup&quot;);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ss.addr.prefix = allocSize;</div><div class="line">    struct Jmp j;</div><div class="line">    Jmp_try(j) &#123;</div><div class="line">        NetDev_addAddress(ctx-&gt;ifName-&gt;bytes, &amp;ss.addr, ctx-&gt;logger, &amp;j.handler);</div><div class="line">    &#125; Jmp_catch &#123;</div><div class="line">        Log_error(ctx-&gt;logger, &quot;Error setting ip address on TUN [%s]&quot;, j.message);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里主要调用了两个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">RouteGen_addPrefix(ctx-&gt;rg, &amp;ss.addr);</div><div class="line">NetDev_addAddress(ctx-&gt;ifName-&gt;bytes, &amp;ss.addr, ctx-&gt;logger, &amp;j.handler);</div></pre></td></tr></table></figure></p>
<p>已经不是IpTunnel范围内的代码了，具体内容不分析了。<br>至此，向离岸点申请ipv4，收到回复后设置ipv4的过程就结束了。</p>
<h3 id="离岸点为每个允许连接过来的普通点建立一个IpTunnel-Connection"><a href="#离岸点为每个允许连接过来的普通点建立一个IpTunnel-Connection" class="headerlink" title="离岸点为每个允许连接过来的普通点建立一个IpTunnel_Connection"></a>离岸点为每个允许连接过来的普通点建立一个IpTunnel_Connection</h3><h4 id="conf文件配置-1"><a href="#conf文件配置-1" class="headerlink" title="conf文件配置"></a>conf文件配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&quot;allowedConnections&quot;: [</div><div class="line">        &#123;</div><div class="line">            &quot;ip4Address&quot;: &quot;192.168.254.2&quot;,</div><div class="line">            &quot;ip4Prefix&quot;: 0,</div><div class="line">            &quot;ip4Alloc&quot;: 32,</div><div class="line">            &quot;publicKey&quot;: &quot;uhmhts49tdm1ryb3q0pw95291uwt4xgvyk5s84vt2z2mnv3zp230.k&quot;</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            &quot;ip4Address&quot;: &quot;192.168.254.3&quot;,</div><div class="line">            &quot;ip4Prefix&quot;: 0,</div><div class="line">            &quot;ip4Alloc&quot;: 32,</div><div class="line">            &quot;publicKey&quot;: &quot;9c3x7hp181dv91tfkbngyhhu2uc3xhxuuh539l3g0gdjgjg1bs10.k&quot;</div><div class="line">        &#125;</div><div class="line">]</div></pre></td></tr></table></figure>
<h4 id="读取配置文件-1"><a href="#读取配置文件-1" class="headerlink" title="读取配置文件"></a>读取配置文件</h4><p>Configurator.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">List* incoming = Dict_getListC(ifaceConf, &quot;allowedConnections&quot;);</div><div class="line">if (incoming) &#123;</div><div class="line">    Dict* d;</div><div class="line">    for (int i = 0; (d = List_getDict(incoming, i)) != NULL; i++) &#123;</div><div class="line">        String* key = Dict_getStringC(d, &quot;publicKey&quot;);</div><div class="line">        String* ip4 = Dict_getStringC(d, &quot;ip4Address&quot;);</div><div class="line">        // Note that the prefix length has to be a proper int in the config</div><div class="line">        // (not quoted!)</div><div class="line">        int64_t* ip4Prefix = Dict_getIntC(d, &quot;ip4Prefix&quot;);</div><div class="line">        String* ip6 = Dict_getStringC(d, &quot;ip6Address&quot;);</div><div class="line">        int64_t* ip6Prefix = Dict_getIntC(d, &quot;ip6Prefix&quot;);</div><div class="line">        if (!key) &#123;</div><div class="line">            Log_critical(ctx-&gt;logger, &quot;In router.ipTunnel.allowedConnections[%d]&quot;</div><div class="line">                                      &quot;&apos;publicKey&apos; required.&quot;, i);</div><div class="line">            exit(1);</div><div class="line">        &#125;</div><div class="line">        if (!ip4 &amp;&amp; !ip6) &#123;</div><div class="line">            Log_critical(ctx-&gt;logger, &quot;In router.ipTunnel.allowedConnections[%d]&quot;</div><div class="line">                                      &quot;either &apos;ip4Address&apos; or &apos;ip6Address&apos; required.&quot;, i);</div><div class="line">            exit(1);</div><div class="line">        &#125; else if (ip4Prefix &amp;&amp; !ip4) &#123;</div><div class="line">            Log_critical(ctx-&gt;logger, &quot;In router.ipTunnel.allowedConnections[%d]&quot;</div><div class="line">                                      &quot;&apos;ip4Address&apos; required with &apos;ip4Prefix&apos;.&quot;, i);</div><div class="line">            exit(1);</div><div class="line">        &#125; else if (ip6Prefix &amp;&amp; !ip6) &#123;</div><div class="line">            Log_critical(ctx-&gt;logger, &quot;In router.ipTunnel.allowedConnections[%d]&quot;</div><div class="line">                                      &quot;&apos;ip6Address&apos; required with &apos;ip6Prefix&apos;.&quot;, i);</div><div class="line">            exit(1);</div><div class="line">        &#125;</div><div class="line">        Log_debug(ctx-&gt;logger, &quot;Allowing IpTunnel connections from [%s]&quot;, key-&gt;bytes);</div><div class="line"></div><div class="line">        if (ip4) &#123;</div><div class="line">            Log_debug(ctx-&gt;logger, &quot;Issue IPv4 address %s&quot;, ip4-&gt;bytes);</div><div class="line">            if (ip4Prefix) &#123;</div><div class="line">                Log_debug(ctx-&gt;logger, &quot;Issue IPv4 netmask/prefix length /%d&quot;,</div><div class="line">                    (int) *ip4Prefix);</div><div class="line">            &#125; else &#123;</div><div class="line">                Log_debug(ctx-&gt;logger, &quot;Use default netmask/prefix length /0&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (ip6) &#123;</div><div class="line">            Log_debug(ctx-&gt;logger, &quot;Issue IPv6 address [%s]&quot;, ip6-&gt;bytes);</div><div class="line">            if (ip6Prefix) &#123;</div><div class="line">                Log_debug(ctx-&gt;logger, &quot;Issue IPv6 netmask/prefix length /%d&quot;,</div><div class="line">                    (int) *ip6Prefix);</div><div class="line">            &#125; else &#123;</div><div class="line">                Log_debug(ctx-&gt;logger, &quot;Use default netmask/prefix length /0&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Dict_putStringC(d, &quot;publicKeyOfAuthorizedNode&quot;, key, tempAlloc);</div><div class="line">        rpcCall0(String_CONST(&quot;IpTunnel_allowConnection&quot;), d, ctx, tempAlloc, NULL, true);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>读取配置文件中allowedConnections中各个点的相关信息，rpcall调用IpTunnel_allowConnection方法。</p>
<h4 id="IpTunnel-allowConnection方法"><a href="#IpTunnel-allowConnection方法" class="headerlink" title="IpTunnel_allowConnection方法"></a>IpTunnel_allowConnection方法</h4><p>IpTunnel_admin.c<br>该方法在文件中注册为allowConnection函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">static void allowConnection(Dict* args,</div><div class="line">                            void* vcontext,</div><div class="line">                            String* txid,</div><div class="line">                            struct Allocator* requestAlloc)</div><div class="line">&#123;</div><div class="line">    struct Context* context = (struct Context*) vcontext;</div><div class="line">    String* publicKeyOfAuthorizedNode =</div><div class="line">        Dict_getStringC(args, &quot;publicKeyOfAuthorizedNode&quot;);</div><div class="line">    String* ip6Address = Dict_getStringC(args, &quot;ip6Address&quot;);</div><div class="line">    int64_t* ip6Prefix = Dict_getIntC(args, &quot;ip6Prefix&quot;);</div><div class="line">    int64_t* ip6Alloc = Dict_getIntC(args, &quot;ip6Alloc&quot;);</div><div class="line">    String* ip4Address = Dict_getStringC(args, &quot;ip4Address&quot;);</div><div class="line">    int64_t* ip4Prefix = Dict_getIntC(args, &quot;ip4Prefix&quot;);</div><div class="line">    int64_t* ip4Alloc = Dict_getIntC(args, &quot;ip4Alloc&quot;);</div><div class="line"></div><div class="line">    uint8_t pubKey[32];</div><div class="line">    uint8_t ip6Addr[16];</div><div class="line"></div><div class="line">    struct Sockaddr_storage ip6ToGive;</div><div class="line">    struct Sockaddr_storage ip4ToGive;</div><div class="line"></div><div class="line">    char* error;</div><div class="line">    int ret;</div><div class="line">    if (!ip6Address &amp;&amp; !ip4Address) &#123;</div><div class="line">        error = &quot;Must specify ip6Address or ip4Address&quot;;</div><div class="line">    &#125; else if ((ret = Key_parse(publicKeyOfAuthorizedNode, pubKey, ip6Addr)) != 0) &#123;</div><div class="line">        error = Key_parse_strerror(ret);</div><div class="line"></div><div class="line">    &#125; else if (ip6Prefix &amp;&amp; !ip6Address) &#123;</div><div class="line">        error = &quot;Must specify ip6Address with ip6Prefix&quot;;</div><div class="line">    &#125; else if (ip6Alloc &amp;&amp; !ip6Address) &#123;</div><div class="line">        error = &quot;Must specify ip6Address with ip6Alloc&quot;;</div><div class="line">    &#125; else if (ip6Prefix &amp;&amp; (*ip6Prefix &gt; 128 || *ip6Prefix &lt; 0)) &#123;</div><div class="line">        error = &quot;ip6Prefix out of range: must be 0 to 128&quot;;</div><div class="line">    &#125; else if (ip6Alloc &amp;&amp; (*ip6Alloc &gt; 128 || *ip6Alloc &lt; 1)) &#123;</div><div class="line">        error = &quot;ip6Alloc out of range: must be 1 to 128&quot;;</div><div class="line"></div><div class="line">    &#125; else if (ip4Prefix &amp;&amp; !ip4Address) &#123;</div><div class="line">        error = &quot;Must specify ip4Address with ip4Prefix&quot;;</div><div class="line">    &#125; else if (ip4Alloc &amp;&amp; !ip4Address) &#123;</div><div class="line">        error = &quot;Must specify ip4Address with ip4Alloc&quot;;</div><div class="line">    &#125; else if (ip4Prefix &amp;&amp; (*ip4Prefix &gt; 32 || *ip4Prefix &lt; 0)) &#123;</div><div class="line">        error = &quot;ip4Prefix out of range: must be 0 to 32&quot;;</div><div class="line">    &#125; else if (ip4Alloc &amp;&amp; (*ip4Alloc &gt; 32 || *ip4Alloc &lt; 1)) &#123;</div><div class="line">        error = &quot;ip4Alloc out of range: must be 1 to 32&quot;;</div><div class="line"></div><div class="line">    &#125; else if (ip6Address</div><div class="line">        &amp;&amp; (Sockaddr_parse(ip6Address-&gt;bytes, &amp;ip6ToGive)</div><div class="line">            || Sockaddr_getFamily(&amp;ip6ToGive.addr) != Sockaddr_AF_INET6))</div><div class="line">    &#123;</div><div class="line">        error = &quot;malformed ip6Address&quot;;</div><div class="line">    &#125; else if (ip4Address</div><div class="line">        &amp;&amp; (Sockaddr_parse(ip4Address-&gt;bytes, &amp;ip4ToGive)</div><div class="line">            || Sockaddr_getFamily(&amp;ip4ToGive.addr) != Sockaddr_AF_INET))</div><div class="line">    &#123;</div><div class="line">        error = &quot;malformed ip4Address&quot;;</div><div class="line">    &#125; else &#123;</div><div class="line">        int conn = IpTunnel_allowConnection(pubKey,</div><div class="line">                                            (ip6Address) ? &amp;ip6ToGive.addr : NULL,</div><div class="line">                                            (ip6Prefix) ? (uint8_t) (*ip6Prefix) : 128,</div><div class="line">                                            (ip6Alloc) ? (uint8_t) (*ip6Alloc) : 128,</div><div class="line">                                            (ip4Address) ? &amp;ip4ToGive.addr : NULL,</div><div class="line">                                            (ip4Prefix) ? (uint8_t) (*ip4Prefix) : 32,</div><div class="line">                                            (ip4Alloc) ? (uint8_t) (*ip4Alloc) : 32,</div><div class="line">                                            context-&gt;ipTun);</div><div class="line">        sendResponse(conn, txid, context-&gt;admin);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    sendError(error, txid, context-&gt;admin);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>获取conf中该连接的相关信息，验证其合法性，调用IpTunnel_allowConnection方法，建立IpTunnel_Connection。</p>
<h4 id="IpTunnel-allowConnection方法-1"><a href="#IpTunnel-allowConnection方法-1" class="headerlink" title="IpTunnel_allowConnection方法"></a>IpTunnel_allowConnection方法</h4><p>IpTunnel.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">int IpTunnel_allowConnection(uint8_t publicKeyOfAuthorizedNode[32],</div><div class="line">                             struct Sockaddr* ip6Addr,</div><div class="line">                             uint8_t ip6Prefix,</div><div class="line">                             uint8_t ip6Alloc,</div><div class="line">                             struct Sockaddr* ip4Addr,</div><div class="line">                             uint8_t ip4Prefix,</div><div class="line">                             uint8_t ip4Alloc,</div><div class="line">                             struct IpTunnel* tunnel)</div><div class="line">&#123;</div><div class="line">    struct IpTunnel_pvt* context = Identity_check((struct IpTunnel_pvt*)tunnel);</div><div class="line"></div><div class="line">    Log_debug(context-&gt;logger, &quot;IPv4 Prefix to allow: %d&quot;, ip4Prefix);</div><div class="line"></div><div class="line">    uint8_t* ip6Address = NULL;</div><div class="line">    uint8_t* ip4Address = NULL;</div><div class="line">    if (ip6Addr) &#123;</div><div class="line">        Sockaddr_getAddress(ip6Addr, &amp;ip6Address);</div><div class="line">    &#125;</div><div class="line">    if (ip4Addr) &#123;</div><div class="line">        Sockaddr_getAddress(ip4Addr, &amp;ip4Address);</div><div class="line">    &#125;</div><div class="line">    Log_debug(context-&gt;logger, &quot;noti outgoing call by IpTunnel_allowConnection&quot;);</div><div class="line">    struct IpTunnel_Connection* conn = newConnection(false, context);</div><div class="line">    Bits_memcpy(conn-&gt;routeHeader.publicKey, publicKeyOfAuthorizedNode, 32);</div><div class="line">    AddressCalc_addressForPublicKey(conn-&gt;routeHeader.ip6, publicKeyOfAuthorizedNode);</div><div class="line">    if (ip4Address) &#123;</div><div class="line">        Bits_memcpy(conn-&gt;connectionIp4, ip4Address, 4);</div><div class="line">        conn-&gt;connectionIp4Prefix = ip4Prefix;</div><div class="line">        conn-&gt;connectionIp4Alloc = ip4Alloc;</div><div class="line">        Assert_true(ip4Alloc);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (ip6Address) &#123;</div><div class="line">        Bits_memcpy(conn-&gt;connectionIp6, ip6Address, 16);</div><div class="line">        conn-&gt;connectionIp6Prefix = ip6Prefix;</div><div class="line">        conn-&gt;connectionIp6Alloc = ip6Alloc;</div><div class="line">        Assert_true(ip6Alloc);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return conn-&gt;number;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里主要三个操作：</p>
<ol>
<li>调用newConnection(true, context)创建一个IpTunnel_Connection类型的conn。</li>
<li>将conf配置中的publicKey信息赋值给conn-&gt;routeHeader.publicKey</li>
<li>将conf配置中的ip相关信息赋值给conn相关字段 </li>
</ol>
<h4 id="创建一个IpTunnel-Connection类型的conn-1"><a href="#创建一个IpTunnel-Connection类型的conn-1" class="headerlink" title="创建一个IpTunnel_Connection类型的conn"></a>创建一个IpTunnel_Connection类型的conn</h4><p>调用newConnection方法。<br>IpTunnel.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">static struct IpTunnel_Connection* newConnection(bool isOutgoing, struct IpTunnel_pvt* context)</div><div class="line">&#123;</div><div class="line">    if (context-&gt;pub.connectionList.count == context-&gt;connectionCapacity) &#123;</div><div class="line">        uint32_t newSize = (context-&gt;connectionCapacity + 4) * sizeof(struct IpTunnel_Connection);</div><div class="line">        context-&gt;pub.connectionList.connections =</div><div class="line">            Allocator_realloc(context-&gt;allocator, context-&gt;pub.connectionList.connections, newSize);</div><div class="line">        context-&gt;connectionCapacity += 4;</div><div class="line">    &#125;</div><div class="line">    struct IpTunnel_Connection* conn =</div><div class="line">        &amp;context-&gt;pub.connectionList.connections[context-&gt;pub.connectionList.count];</div><div class="line"></div><div class="line">    // If it&apos;s an incoming connection, it must be lower on the list than any outgoing connections.</div><div class="line">    if (!isOutgoing) &#123;</div><div class="line">        for (int i = (int)context-&gt;pub.connectionList.count - 1; i &gt;= 0; i--) &#123;</div><div class="line">            if (!context-&gt;pub.connectionList.connections[i].isOutgoing</div><div class="line">                &amp;&amp; conn != &amp;context-&gt;pub.connectionList.connections[i + 1])</div><div class="line">            &#123;</div><div class="line">                Bits_memcpy(conn,</div><div class="line">                                 &amp;context-&gt;pub.connectionList.connections[i + 1],</div><div class="line">                                 sizeof(struct IpTunnel_Connection));</div><div class="line">                conn = &amp;context-&gt;pub.connectionList.connections[i + 1];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    context-&gt;pub.connectionList.count++;</div><div class="line"></div><div class="line">    Bits_memset(conn, 0, sizeof(struct IpTunnel_Connection));</div><div class="line">    conn-&gt;number = context-&gt;nextConnectionNumber++;</div><div class="line">    conn-&gt;isOutgoing = isOutgoing;</div><div class="line">    conn-&gt;reachable = false;</div><div class="line"></div><div class="line">    // if there are 2 billion calls, die.</div><div class="line">    Assert_true(context-&gt;nextConnectionNumber &lt; (UINT32_MAX &gt;&gt; 1));</div><div class="line"></div><div class="line">    return conn;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第一个参数指定了是否为离岸点，其他部分没什么特别，普通的赋值操作。</p>
<h4 id="收到其他点发送来的分配地址的请求"><a href="#收到其他点发送来的分配地址的请求" class="headerlink" title="收到其他点发送来的分配地址的请求"></a>收到其他点发送来的分配地址的请求</h4><p>所有从其他点发送过来，进入IpTunnel的数据，都先到incomingFromNode方法中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">static Iface_DEFUN incomingFromNode(struct Message* message, struct Iface* nodeIf)</div><div class="line">&#123;</div><div class="line">    struct IpTunnel_pvt* context =</div><div class="line">        Identity_containerOf(nodeIf, struct IpTunnel_pvt, pub.nodeInterface);</div><div class="line"></div><div class="line">    //Log_debug(context-&gt;logger, &quot;Got incoming message&quot;);</div><div class="line"></div><div class="line">    Assert_true(message-&gt;length &gt;= RouteHeader_SIZE + DataHeader_SIZE);</div><div class="line">    struct RouteHeader* rh = (struct RouteHeader*) message-&gt;bytes;</div><div class="line">    struct DataHeader* dh = (struct DataHeader*) &amp;rh[1];</div><div class="line">    Assert_true(DataHeader_getContentType(dh) == ContentType_IPTUN);</div><div class="line">    struct IpTunnel_Connection* conn = connectionByPubKey(rh-&gt;publicKey, context);</div><div class="line">    if (!conn) &#123;</div><div class="line">        if (Defined(Log_DEBUG)) &#123;</div><div class="line">            uint8_t addr[40];</div><div class="line">            AddrTools_printIp(addr, rh-&gt;ip6);</div><div class="line">            Log_debug(context-&gt;logger, &quot;Got message from unrecognized node [%s]&quot;, addr);</div><div class="line">        &#125;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Message_shift(message, -(RouteHeader_SIZE + DataHeader_SIZE), NULL);</div><div class="line"></div><div class="line">    if (message-&gt;length &gt; 40 &amp;&amp; Headers_getIpVersion(message-&gt;bytes) == 6) &#123;</div><div class="line">        return ip6FromNode(message, conn, context);</div><div class="line">    &#125;</div><div class="line">    if (message-&gt;length &gt; 20 &amp;&amp; Headers_getIpVersion(message-&gt;bytes) == 4) &#123;</div><div class="line">        return ip4FromNode(message, conn, context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (Defined(Log_DEBUG)) &#123;</div><div class="line">        uint8_t addr[40];</div><div class="line">        AddrTools_printIp(addr, rh-&gt;ip6);</div><div class="line">        Log_debug(context-&gt;logger,</div><div class="line">                  &quot;Got message of unknown type, length: [%d], IP version [%d] from [%s]&quot;,</div><div class="line">                  message-&gt;length,</div><div class="line">                  (message-&gt;length &gt; 1) ? Headers_getIpVersion(message-&gt;bytes) : 0,</div><div class="line">                  addr);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li><p>通过publicKey找到对应的conn。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">struct IpTunnel_Connection* conn = connectionByPubKey(rh-&gt;publicKey, context);</div></pre></td></tr></table></figure>
</li>
<li><p>调用ip6FromNode</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (message-&gt;length &gt; 40 &amp;&amp; Headers_getIpVersion(message-&gt;bytes) == 6) &#123;</div><div class="line">    return ip6FromNode(message, conn, context);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">static Iface_DEFUN ip6FromNode(struct Message* message,</div><div class="line">                               struct IpTunnel_Connection* conn,</div><div class="line">                               struct IpTunnel_pvt* context)</div><div class="line">&#123;</div><div class="line">    struct Headers_IP6Header* header = (struct Headers_IP6Header*) message-&gt;bytes;</div><div class="line">    if (Bits_isZero(header-&gt;sourceAddr, 16) || Bits_isZero(header-&gt;destinationAddr, 16)) &#123;</div><div class="line">        if (Bits_isZero(header-&gt;sourceAddr, 32)) &#123;</div><div class="line">            return incomingControlMessage(message, conn, context);</div><div class="line">        &#125;</div><div class="line">        ......</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    if (!isValidAddress6(header-&gt;sourceAddr, false, conn)) &#123;</div><div class="line">        ......</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">    return Iface_next(&amp;context-&gt;pub.tunInterface, message);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此时header-&gt;sourceAddr为全0，会调用到incomingControlMessage方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">static Iface_DEFUN incomingControlMessage(struct Message* message,</div><div class="line">                                          struct IpTunnel_Connection* conn,</div><div class="line">                                          struct IpTunnel_pvt* context)</div><div class="line">&#123;</div><div class="line">       ......</div><div class="line">    Dict* d = NULL;</div><div class="line">    char* err = BencMessageReader_readNoExcept(message, alloc, &amp;d);</div><div class="line">    if (err) &#123;</div><div class="line">        Log_info(context-&gt;logger, &quot;Failed to parse message [%s]&quot;, err);</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">     ....</div><div class="line">    if (String_equals(String_CONST(&quot;IpTunnel_getAddresses&quot;),</div><div class="line">                      Dict_getStringC(d, &quot;q&quot;)))</div><div class="line">    &#123;</div><div class="line">        return requestForAddresses(d, conn, alloc, context);</div><div class="line">    &#125;</div><div class="line">    Log_warn(context-&gt;logger, &quot;Message which is unhandled&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为普通点在向离岸点发送分配ipv4地址的请求时，会将q字段的值设为IpTunnel_getAddresses，所以，在离岸点收到这类信息时，会调用到requestForAddresses方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">static Iface_DEFUN requestForAddresses(Dict* request,</div><div class="line">                                       struct IpTunnel_Connection* conn,</div><div class="line">                                       struct Allocator* requestAlloc,</div><div class="line">                                       struct IpTunnel_pvt* context)</div><div class="line">&#123;</div><div class="line">    ......</div><div class="line">    Dict* addresses = Dict_new(requestAlloc);</div><div class="line">    bool noAddresses = true;</div><div class="line">    if (!Bits_isZero(conn-&gt;connectionIp6, 16)) &#123;</div><div class="line">        ......</div><div class="line">    &#125;</div><div class="line">    if (!Bits_isZero(conn-&gt;connectionIp4, 4)) &#123;</div><div class="line">        Dict_putStringC(addresses,</div><div class="line">                       &quot;ip4&quot;,</div><div class="line">                       String_newBinary((char*)conn-&gt;connectionIp4, 4, requestAlloc),</div><div class="line">                       requestAlloc);</div><div class="line">        Dict_putIntC(addresses,</div><div class="line">                    &quot;ip4Prefix&quot;, (int64_t)conn-&gt;connectionIp4Prefix,</div><div class="line">                    requestAlloc);</div><div class="line">        Dict_putIntC(addresses,</div><div class="line">                    &quot;ip4Alloc&quot;, (int64_t)conn-&gt;connectionIp4Alloc,</div><div class="line">                    requestAlloc);</div><div class="line"></div><div class="line">        noAddresses = false;</div><div class="line">    &#125;</div><div class="line">    if (noAddresses) &#123;</div><div class="line">        Log_warn(context-&gt;logger, &quot;no addresses to provide&quot;);</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Dict* msg = Dict_new(requestAlloc);</div><div class="line">    Dict_putDictC(msg, &quot;addresses&quot;, addresses, requestAlloc);</div><div class="line"></div><div class="line">    String* txid = Dict_getStringC(request, &quot;txid&quot;);</div><div class="line">    if (txid) &#123;</div><div class="line">        Dict_putStringC(msg, &quot;txid&quot;, txid, requestAlloc);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    sendControlMessage(msg, conn, requestAlloc, context);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>将conf文件中，分配给这个连接的ipv4地址相关信息，填入addresses中，再将key为addresses，value为addresses的键值对，放入Dict中，调用sendControlMessage发送出去。当普通点收到这个回复后，会从中取出addresses，并进行ipv4相关字段的设置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">static void sendControlMessage(Dict* dict,</div><div class="line">                               struct IpTunnel_Connection* connection,</div><div class="line">                               struct Allocator* requestAlloc,</div><div class="line">                               struct IpTunnel_pvt* context)</div><div class="line">&#123;</div><div class="line">    struct Message* msg = Message_new(0, 1024, requestAlloc);</div><div class="line">    BencMessageWriter_write(dict, msg, NULL);</div><div class="line"></div><div class="line">    int length = msg-&gt;length;</div><div class="line"></div><div class="line">    // do UDP header.</div><div class="line">    Message_shift(msg, Headers_UDPHeader_SIZE, NULL);</div><div class="line">    struct Headers_UDPHeader* uh = (struct Headers_UDPHeader*) msg-&gt;bytes;</div><div class="line">    uh-&gt;srcPort_be = 0;</div><div class="line">    uh-&gt;destPort_be = 0;</div><div class="line">    uh-&gt;length_be = Endian_hostToBigEndian16(length);</div><div class="line">    uh-&gt;checksum_be = 0;</div><div class="line"></div><div class="line">    uint16_t payloadLength = msg-&gt;length;</div><div class="line"></div><div class="line">    Message_shift(msg, Headers_IP6Header_SIZE, NULL);</div><div class="line">    struct Headers_IP6Header* header = (struct Headers_IP6Header*) msg-&gt;bytes;</div><div class="line">    header-&gt;versionClassAndFlowLabel = 0;</div><div class="line">    header-&gt;flowLabelLow_be = 0;</div><div class="line">    header-&gt;nextHeader = 17;</div><div class="line">    header-&gt;hopLimit = 0;</div><div class="line">    header-&gt;payloadLength_be = Endian_hostToBigEndian16(payloadLength);</div><div class="line">    Headers_setIpVersion(header);</div><div class="line"></div><div class="line">    // zero the source and dest addresses.</div><div class="line">    Bits_memset(header-&gt;sourceAddr, 0, 32);</div><div class="line"></div><div class="line">    uh-&gt;checksum_be = Checksum_udpIp6(header-&gt;sourceAddr,</div><div class="line">                                      (uint8_t*) uh,</div><div class="line">                                      msg-&gt;length - Headers_IP6Header_SIZE);</div><div class="line"></div><div class="line">    Iface_CALL(sendToNode, msg, connection, context);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>调用sendToNode<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">static Iface_DEFUN sendToNode(struct Message* message,</div><div class="line">                              struct IpTunnel_Connection* connection,</div><div class="line">                              struct IpTunnel_pvt* context)</div><div class="line">&#123;</div><div class="line">    Message_push(message, NULL, DataHeader_SIZE, NULL);</div><div class="line">    struct DataHeader* dh = (struct DataHeader*) message-&gt;bytes;</div><div class="line">    DataHeader_setContentType(dh, ContentType_IPTUN);</div><div class="line">    DataHeader_setVersion(dh, DataHeader_CURRENT_VERSION);</div><div class="line">    Message_push(message, &amp;connection-&gt;routeHeader, RouteHeader_SIZE, NULL);</div><div class="line">    return Iface_next(&amp;context-&gt;pub.nodeInterface, message);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>至此，离岸点在收到普通点的ipv4分配申请后的执行流程分析完毕。</p>
<h2 id="处理从其他点发来的消息"><a href="#处理从其他点发来的消息" class="headerlink" title="处理从其他点发来的消息"></a>处理从其他点发来的消息</h2><p>上面讲到，所有从其他点发送过来，进入IpTunnel的数据，都先到incomingFromNode方法中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">static Iface_DEFUN incomingFromNode(struct Message* message, struct Iface* nodeIf)</div><div class="line">&#123;</div><div class="line">    struct IpTunnel_pvt* context =</div><div class="line">        Identity_containerOf(nodeIf, struct IpTunnel_pvt, pub.nodeInterface);</div><div class="line"></div><div class="line">    Assert_true(message-&gt;length &gt;= RouteHeader_SIZE + DataHeader_SIZE);</div><div class="line">    struct RouteHeader* rh = (struct RouteHeader*) message-&gt;bytes;</div><div class="line">    struct DataHeader* dh = (struct DataHeader*) &amp;rh[1];</div><div class="line">    Assert_true(DataHeader_getContentType(dh) == ContentType_IPTUN);</div><div class="line">    struct IpTunnel_Connection* conn = connectionByPubKey(rh-&gt;publicKey, context);</div><div class="line">    if (!conn) &#123;</div><div class="line">        if (Defined(Log_DEBUG)) &#123;</div><div class="line">            uint8_t addr[40];</div><div class="line">            AddrTools_printIp(addr, rh-&gt;ip6);</div><div class="line">            Log_debug(context-&gt;logger, &quot;Got message from unrecognized node [%s]&quot;, addr);</div><div class="line">        &#125;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Message_shift(message, -(RouteHeader_SIZE + DataHeader_SIZE), NULL);</div><div class="line"></div><div class="line">    if (message-&gt;length &gt; 40 &amp;&amp; Headers_getIpVersion(message-&gt;bytes) == 6) &#123;</div><div class="line">        return ip6FromNode(message, conn, context);</div><div class="line">    &#125;</div><div class="line">    if (message-&gt;length &gt; 20 &amp;&amp; Headers_getIpVersion(message-&gt;bytes) == 4) &#123;</div><div class="line">        return ip4FromNode(message, conn, context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (Defined(Log_DEBUG)) &#123;</div><div class="line">        uint8_t addr[40];</div><div class="line">        AddrTools_printIp(addr, rh-&gt;ip6);</div><div class="line">        Log_debug(context-&gt;logger,</div><div class="line">                  &quot;Got message of unknown type, length: [%d], IP version [%d] from [%s]&quot;,</div><div class="line">                  message-&gt;length,</div><div class="line">                  (message-&gt;length &gt; 1) ? Headers_getIpVersion(message-&gt;bytes) : 0,</div><div class="line">                  addr);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以ipv4为例，进入到ip4FromNode<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">static Iface_DEFUN ip4FromNode(struct Message* message,</div><div class="line">                               struct IpTunnel_Connection* conn,</div><div class="line">                               struct IpTunnel_pvt* context)</div><div class="line">&#123;</div><div class="line">    struct Headers_IP4Header* header = (struct Headers_IP4Header*) message-&gt;bytes;</div><div class="line">    if (Bits_isZero(header-&gt;sourceAddr, 4) || Bits_isZero(header-&gt;destAddr, 4)) &#123;</div><div class="line">        Log_debug(context-&gt;logger, &quot;Got message with zero address&quot;);</div><div class="line">        return 0;</div><div class="line">    &#125; else if (!isValidAddress4(header-&gt;sourceAddr, false, conn)) &#123;</div><div class="line">        Log_debug(context-&gt;logger, &quot;Got message with wrong address [%d.%d.%d.%d] for connection &quot;</div><div class="line">                                   &quot;[%d.%d.%d.%d/%d:%d]&quot;,</div><div class="line">                  header-&gt;sourceAddr[0], header-&gt;sourceAddr[1],</div><div class="line">                  header-&gt;sourceAddr[2], header-&gt;sourceAddr[3],</div><div class="line">                  conn-&gt;connectionIp4[0], conn-&gt;connectionIp4[1],</div><div class="line">                  conn-&gt;connectionIp4[2], conn-&gt;connectionIp4[3],</div><div class="line">                  conn-&gt;connectionIp4Alloc, conn-&gt;connectionIp4Prefix);</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    Log_debug(context-&gt;logger, &quot;jin Got message with address [%d.%d.%d.%d] for connection &quot;</div><div class="line">                                   &quot;[%d.%d.%d.%d/%d:%d]&quot;,</div><div class="line">                  header-&gt;sourceAddr[0], header-&gt;sourceAddr[1],</div><div class="line">                  header-&gt;sourceAddr[2], header-&gt;sourceAddr[3],</div><div class="line">                  conn-&gt;connectionIp4[0], conn-&gt;connectionIp4[1],</div><div class="line">                  conn-&gt;connectionIp4[2], conn-&gt;connectionIp4[3],</div><div class="line">                  conn-&gt;connectionIp4Alloc, conn-&gt;connectionIp4Prefix);</div><div class="line">    TUNMessageType_push(message, Ethernet_TYPE_IP4, NULL);</div><div class="line">    return Iface_next(&amp;context-&gt;pub.tunInterface, message);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>此时，header-&gt;sourceAddr是对方的ipv4地址，不会为全0，代码进入到一个ip地址合法性判断：isValidAddress4(header-&gt;sourceAddr, false, conn)。如果地址合法，消息进一步发送到context-&gt;pub.tunInterface中。<br>tunInterface是一个Iface，它的回调函数在IpTunnel_new中设置为incomingFromTun<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.pub = &#123;</div><div class="line">    .tunInterface = &#123; .send = incomingFromTun &#125;,</div><div class="line">&#125;,</div></pre></td></tr></table></figure></p>
<p>它的connectedIf在Core.c的Core_init方法中通过Iface_plumb方法与nc-&gt;tunAdapt-&gt;ipTunnelIf绑定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Iface_plumb(&amp;nc-&gt;tunAdapt-&gt;ipTunnelIf, &amp;ipTunnel-&gt;tunInterface);</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">static inline void Iface_plumb(struct Iface* a, struct Iface* b)</div><div class="line">&#123;</div><div class="line">    Assert_true(!a-&gt;connectedIf);</div><div class="line">    Assert_true(!b-&gt;connectedIf);</div><div class="line">    a-&gt;connectedIf = b;</div><div class="line">    b-&gt;connectedIf = a;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="查看地址合法性判断"><a href="#查看地址合法性判断" class="headerlink" title="查看地址合法性判断"></a>查看地址合法性判断</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">static bool isValidAddress4(uint8_t sourceAndDestIp4[8],</div><div class="line">                            bool isFromTun,</div><div class="line">                            struct IpTunnel_Connection* conn)</div><div class="line">&#123;</div><div class="line">    uint8_t* compareAddr = (isFromTun)</div><div class="line">        ? ((conn-&gt;isOutgoing) ? sourceAndDestIp4 : &amp;sourceAndDestIp4[4])</div><div class="line">        : ((conn-&gt;isOutgoing) ? &amp;sourceAndDestIp4[4] : sourceAndDestIp4);</div><div class="line">    return prefixMatches4(compareAddr, conn-&gt;connectionIp4, conn-&gt;connectionIp4Alloc);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ifFromTun为false，接下来根据isOutgoing的值来决定compareAddr的值，分为两种情况</p>
<ol>
<li>当前点是普通点，那么他收到的消息是从离岸点发送过来的，isOutgoing为<br>true，compareAddr赋值为sourceAndDestIp4[4]，也就是dest ip,从离岸点发来的包的dest ip就是当前这个普通点的ipv4地址。</li>
<li>当前点是离岸点，那么它收到的消息是从普通点发送过来的，isOutgoing为<br>false，compareAddr赋值为sourceAndDestIp4，也就是source ip，从普通点发来的包的source ip就是普通点的ipv4地址。<br>综上，compareAddr一定会被赋值为普通点的ipv4地址。接下来调用prefixMatches4方法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">static bool prefixMatches4(uint8_t* addressA, uint8_t* refAddr, uint32_t prefixLen)</div><div class="line">&#123;</div><div class="line">    if (!prefixLen) &#123;</div><div class="line">        Assert_true(Bits_isZero(refAddr, 4));</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">    Assert_true(prefixLen &amp;&amp; prefixLen &lt;= 32);</div><div class="line">    uint32_t a = GET32(addressA);</div><div class="line">    uint32_t b = GET32(refAddr);</div><div class="line">    return !((a ^ b) &gt;&gt; (32 - prefixLen));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这就只是一个简单的地址比较了。</p>
<h2 id="处理从Tun设备发来的消息"><a href="#处理从Tun设备发来的消息" class="headerlink" title="处理从Tun设备发来的消息"></a>处理从Tun设备发来的消息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">static Iface_DEFUN incomingFromTun(struct Message* message, struct Iface* tunIf)</div><div class="line">&#123;</div><div class="line">    struct IpTunnel_pvt* context = Identity_check((struct IpTunnel_pvt*)tunIf);</div><div class="line"></div><div class="line">    if (message-&gt;length &lt; 20) &#123;</div><div class="line">        Log_debug(context-&gt;logger, &quot;DROP runt&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    struct IpTunnel_Connection* conn = NULL;</div><div class="line">    if (!context-&gt;pub.connectionList.connections) &#123;</div><div class="line">        // No connections authorized, fall through to &quot;unrecognized address&quot;</div><div class="line">    &#125; else if (message-&gt;length &gt; 40 &amp;&amp; Headers_getIpVersion(message-&gt;bytes) == 6) &#123;</div><div class="line">        struct Headers_IP6Header* header = (struct Headers_IP6Header*) message-&gt;bytes;</div><div class="line">        conn = findConnection(header-&gt;sourceAddr, NULL, true, context);</div><div class="line">    &#125; else if (message-&gt;length &gt; 20 &amp;&amp; Headers_getIpVersion(message-&gt;bytes) == 4) &#123;</div><div class="line">        struct Headers_IP4Header* header = (struct Headers_IP4Header*) message-&gt;bytes;</div><div class="line">        conn = findConnection(NULL, header-&gt;sourceAddr, true, context);</div><div class="line">    &#125; else &#123;</div><div class="line">        Log_info(context-&gt;logger, &quot;Message of unknown type from TUN&quot;);</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (!conn) &#123;</div><div class="line">        Log_info(context-&gt;logger, &quot;Message with unrecognized address from TUN&quot;);</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return sendToNode(message, conn, context);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里主要进行了两个操作：</p>
<ol>
<li>调用findConnection查找conn</li>
<li>调用sendToNode</li>
</ol>
<h3 id="查找conn"><a href="#查找conn" class="headerlink" title="查找conn"></a>查找conn</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">static struct IpTunnel_Connection* findConnection(uint8_t sourceAndDestIp6[32],</div><div class="line">                                                  uint8_t sourceAndDestIp4[8],</div><div class="line">                                                  bool isFromTun,</div><div class="line">                                                  struct IpTunnel_pvt* context)</div><div class="line">&#123;</div><div class="line">    for (int i = 0; i &lt; (int)context-&gt;pub.connectionList.count; i++) &#123;</div><div class="line">        struct IpTunnel_Connection* conn = &amp;context-&gt;pub.connectionList.connections[i];</div><div class="line">        if (sourceAndDestIp6 &amp;&amp; isValidAddress6(sourceAndDestIp6, isFromTun, conn)) &#123;</div><div class="line">            return conn;</div><div class="line">        &#125;</div><div class="line">        if (sourceAndDestIp4 &amp;&amp; isValidAddress4(sourceAndDestIp4, isFromTun, conn)) &#123;</div><div class="line">            return conn;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return NULL;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以ipv4为例，调用isValidAddress4检查地址合法性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">static bool isValidAddress4(uint8_t sourceAndDestIp4[8],</div><div class="line">                            bool isFromTun,</div><div class="line">                            struct IpTunnel_Connection* conn)</div><div class="line">&#123;</div><div class="line">    uint8_t* compareAddr = (isFromTun)</div><div class="line">        ? ((conn-&gt;isOutgoing) ? sourceAndDestIp4 : &amp;sourceAndDestIp4[4])</div><div class="line">        : ((conn-&gt;isOutgoing) ? &amp;sourceAndDestIp4[4] : sourceAndDestIp4);</div><div class="line">    return prefixMatches4(compareAddr, conn-&gt;connectionIp4, conn-&gt;connectionIp4Alloc);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ifFromTun为true，接下来根据isOutgoing的值来决定compareAddr的值，分为两种情况</p>
<ol>
<li>当前点是普通点，那么他的消息是发往离岸点的，isOutgoing为<br>true，compareAddr赋值为sourceAndDestIp4，也就是source ip,是当前这个普通点的ipv4地址。</li>
<li>当前点是离岸点，那么他的消息是发往普通点的，isOutgoing为<br>false，compareAddr赋值为sourceAndDestIp4[4]，也就是dest ip，发往普通点的包的dest ip就是普通点的ipv4地址。<br>综上，compareAddr一定会被赋值为普通点的ipv4地址。接下来调用prefixMatches4方法，进行地址对比。</li>
</ol>
<h3 id="sendToNode"><a href="#sendToNode" class="headerlink" title="sendToNode"></a>sendToNode</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">static Iface_DEFUN sendToNode(struct Message* message,</div><div class="line">                              struct IpTunnel_Connection* connection,</div><div class="line">                              struct IpTunnel_pvt* context)</div><div class="line">&#123;</div><div class="line">    Message_push(message, NULL, DataHeader_SIZE, NULL);</div><div class="line">    struct DataHeader* dh = (struct DataHeader*) message-&gt;bytes;</div><div class="line">    DataHeader_setContentType(dh, ContentType_IPTUN);</div><div class="line">    DataHeader_setVersion(dh, DataHeader_CURRENT_VERSION);</div><div class="line">    Message_push(message, &amp;connection-&gt;routeHeader, RouteHeader_SIZE, NULL);</div><div class="line">    return Iface_next(&amp;context-&gt;pub.nodeInterface, message);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至此，IpTunnel收到从Tun上和从其他点发来的包，并进行处理的过程分析完成。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/07/25/cjdns_IpTunnel/" data-id="cje6pjw1b002aweyxrqyqzolu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C/">C/C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cjdns/">cjdns</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cjdns源码分析/">cjdns源码分析</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/Android-everyday/">Android_everyday</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android/Android开发工程师/">Android开发工程师</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/AndroidRom/">AndroidRom</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Anrom/">Anrom</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Anrom/rom7-0/">rom7.0</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/Android开发工程师/">Android开发工程师</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SEAndroid/">SEAndroid</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/cjdns/">cjdns</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/cjdns/cjdns源码分析/">cjdns源码分析</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/cjdns-cjdns源码分析/">cjdns - cjdns源码分析</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/hexo/">hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/music/">music</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/net/">net</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/net/iptables/">iptables</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/树莓派/">树莓派</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/树莓派/配置/">配置</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/算法/Java/">Java</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/Java/">Java</a></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android-everyday/">Android_everyday</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android开发工程师/">Android开发工程师</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Anrom/">Anrom</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-C/">C/C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SEAndroid/">SEAndroid</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SELinux/">SELinux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cjdns/">cjdns</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cjdns源码分析/">cjdns源码分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iptables/">iptables</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/music/">music</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/raspberry配置/">raspberry配置</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rom/">rom</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shadowsocks-vps/">shadowsocks/vps</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tool/">tool</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/填坑/">填坑</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/排序算法/">排序算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/查找算法/">查找算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/树莓派raspberry/">树莓派raspberry</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/Android-everyday/" style="font-size: 16.67px;">Android_everyday</a> <a href="/tags/Android开发工程师/" style="font-size: 15.56px;">Android开发工程师</a> <a href="/tags/Anrom/" style="font-size: 14.44px;">Anrom</a> <a href="/tags/C-C/" style="font-size: 14.44px;">C/C++</a> <a href="/tags/Java/" style="font-size: 18.89px;">Java</a> <a href="/tags/Linux/" style="font-size: 13.33px;">Linux</a> <a href="/tags/SEAndroid/" style="font-size: 10px;">SEAndroid</a> <a href="/tags/SELinux/" style="font-size: 10px;">SELinux</a> <a href="/tags/cjdns/" style="font-size: 14.44px;">cjdns</a> <a href="/tags/cjdns源码分析/" style="font-size: 14.44px;">cjdns源码分析</a> <a href="/tags/git/" style="font-size: 11.11px;">git</a> <a href="/tags/hexo/" style="font-size: 13.33px;">hexo</a> <a href="/tags/iptables/" style="font-size: 10px;">iptables</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/music/" style="font-size: 10px;">music</a> <a href="/tags/raspberry配置/" style="font-size: 10px;">raspberry配置</a> <a href="/tags/rom/" style="font-size: 10px;">rom</a> <a href="/tags/shadowsocks-vps/" style="font-size: 10px;">shadowsocks/vps</a> <a href="/tags/tool/" style="font-size: 11.11px;">tool</a> <a href="/tags/填坑/" style="font-size: 13.33px;">填坑</a> <a href="/tags/排序算法/" style="font-size: 11.11px;">排序算法</a> <a href="/tags/数据结构/" style="font-size: 10px;">数据结构</a> <a href="/tags/查找算法/" style="font-size: 11.11px;">查找算法</a> <a href="/tags/树莓派raspberry/" style="font-size: 11.11px;">树莓派raspberry</a> <a href="/tags/算法/" style="font-size: 12.22px;">算法</a> <a href="/tags/设计模式/" style="font-size: 17.78px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">June 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">April 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02/">February 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">January 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/03/">March 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/02/">February 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/06/">June 2013</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/01/29/cjnds-asymmetric-cryptography/">握手过程中，非对称密钥的应用</a>
          </li>
        
          <li>
            <a href="/2017/12/04/how-to-fix-rebase-still-in-progress/">如何解决报错“prior sync failed; rebase still in progress”</a>
          </li>
        
          <li>
            <a href="/2017/11/22/cjdns-3steps-lladdrsession/">使用SocketAddress来维护的EndpointsBySockaddr map机制中EndpointsBySockaddr session的建立过程</a>
          </li>
        
          <li>
            <a href="/2017/09/05/cjdns-cryptoauth/">cjdns源码分析--CryptoAuth</a>
          </li>
        
          <li>
            <a href="/2017/09/04/how-to-read-staff/">如何看懂五线谱</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Chris King<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>